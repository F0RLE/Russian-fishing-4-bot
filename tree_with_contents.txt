üìÅ ./
    üìÑ config.yaml
        VERSION: "0.5.2"
        
        # ---------------------------------------------------------------------------- #
        #                                    General                                   #
        # ---------------------------------------------------------------------------- #
        SCRIPT:
          LANGUAGE: "ru"
          LAUNCH_OPTIONS: "-FB -D -t -l -r"
          SMTP_VERIFICATION: true
          IMAGE_VERIFICATION: true
          SNAG_DETECTION: true  
          SPOOLING_DETECTION: true
          RANDOM_ROD_SELECTION: false
          SPOOL_CONFIDENCE: 0.98
          SPOD_ROD_RECAST_DELAY: 1800
          LURE_CHANGE_DELAY: 1800
          ALARM_SOUND: "./static/sound/guitar.wav"
          RANDOM_CAST_PROBABILITY: 0.25
          SCREENSHOT_TAGS:
            - "green"
            - "yellow"
            - "blue"
            - "purple"
            - "pink"
        
        # ---------------------------------------------------------------------------- #
        #                                  Key Binding                                 #
        # ---------------------------------------------------------------------------- #
        KEY:
          TEA: 5
          CARROT: 4
          BOTTOM_RODS: [1, 2, 3]
          COFFEE: -1
          DIGGING_TOOL: 5
          ALCOHOL: 6
          MAIN_ROD: 1
          SPOD_ROD: 7
          QUIT: "CTRL-C"
          NET: "SPACE"
        
        # ---------------------------------------------------------------------------- #
        #                                 Player Stats                                 #
        # ---------------------------------------------------------------------------- #
        STAT:
          ENERGY_THRESHOLD: 0.74
          HUNGER_THRESHOLD: 0.5
          COMFORT_THRESHOLD: 0.51
          TEA_DELAY: 300
          COFFEE_LIMIT: 10
          COFFEE_PER_DRINK: 1
          ALCOHOL_DELAY: 900
          ALCOHOL_PER_DRINK: 1
        
        # ---------------------------------------------------------------------------- #
        #                   Friction Brake (Use -FB flag to enable it)                #
        # ---------------------------------------------------------------------------- #
        FRICTION_BRAKE:
          INITIAL: 15
          MAX: 26
          START_DELAY: 0.01
          INCREASE_DELAY: 0.01
          SENSITIVITY: "medium"
        
        # ---------------------------------------------------------------------------- #
        #                                 Fish Fight                                   #
        # ---------------------------------------------------------------------------- #
        FISH_FIGHT:
          RETRIEVAL_INTERVAL: 2.0
          LIFT_ENABLED: true
          AUTO_NET: true
          NET_KEY: "SPACE"
          CONTINUOUS_LIFT: true
          RETRIEVAL_DURING_FIGHT: true
        
        # ---------------------------------------------------------------------------- #
        #                                    Keepnet                                   #
        # ---------------------------------------------------------------------------- #
        KEEPNET:
          CAPACITY: 100
          FISH_DELAY: 0.0
          GIFT_DELAY: 4.0
          FULL_ACTION: "quit"
          WHITELIST:
            - "mackerel"
            - "saithe"
            - "herring"
            - "squid"
            - "scallop"
            - "mussel"
          BLACKLIST: []
          TAGS:
            - "green"
            - "yellow"
            - "blue"
            - "purple"
            - "pink"
        
        # ---------------------------------------------------------------------------- #
        #                                 Notification                                 #
        # ---------------------------------------------------------------------------- #
        NOTIFICATION:
          EMAIL: "email@example.com"
          PASSWORD: "password"
          SMTP_SERVER: "smtp.gmail.com"
          MIAO_CODE: "example"
          DISCORD_WEBHOOK_URL: "https://discord.com/api/webhooks/1381306998586343637/t-6xkZiqrACMLSs_DhzE_p9dPAG-sVhUzN_bXqnf7SukxpRhNxL6jS8QfRKySoeKhgeJ"
        
        # ---------------------------------------------------------------------------- #
        #                       Pause ( use -P flag to enable it)                     #
        # ---------------------------------------------------------------------------- #
        PAUSE:
          DELAY: 1800
          DURATION: 600
        
        # ---------------------------------------------------------------------------- #
        #                                   Profiles                                   #
        # ---------------------------------------------------------------------------- #
        PROFILE:
          # -------------------------------------------------------------------------- #
          #                             Spin Fishing Profile                          #
          # -------------------------------------------------------------------------- #
          SPIN:
            MODE: "spin"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 5.0
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 1.5
            RETRIEVAL_DELAY: 1.5
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: "auto"
            TYPE: "lift"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          SPIN_WITH_PAUSE:
            MODE: "spin"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            TIGHTEN_DURATION: 1.0
            RETRIEVAL_DURATION: 1.3
            RETRIEVAL_DELAY: 1.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: "auto"
            TYPE: "pause"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          SPIN_WITH_LIFT:
            MODE: "spin"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 2.0
            RETRIEVAL_DELAY: 2.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: "auto"
            TYPE: "lift"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                            Bottom Fishing Profile                         #
          # -------------------------------------------------------------------------- #
          BOTTOM:
            MODE: "bottom"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            POST_ACCELERATION: "auto"
            CHECK_DELAY: 32.0
            CHECK_MISS_LIMIT: 16
            PUT_DOWN_DELAY: 0.0
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                      Marine / Wakey Rig Pirking Profile                   #
          # -------------------------------------------------------------------------- #
          PIRK:
            MODE: "pirk"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 4.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: false
            SHIFT: false
            PIRK_DURATION: 0.5
            PIRK_DELAY: 2.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          PIRK_WITH_RETRIEVAL:
            MODE: "pirk"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 0.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: false
            SHIFT: false
            PIRK_DURATION: 0.5
            PIRK_DELAY: 2.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: true
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          WAKEY_RIG:
            MODE: "pirk"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 45.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 4.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: true
            SHIFT: false
            PIRK_DURATION: 1.5
            PIRK_DELAY: 4.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                            Marine Elevator Profile                        #
          # -------------------------------------------------------------------------- #
          ELEVATOR:
            MODE: "elevator"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            ELEVATE_DURATION: 4.0
            ELEVATE_DELAY: 4.0
            ELEVATE_TIMEOUT: 40.0
            DROP: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          ELEVATOR_WITH_DROP:
            MODE: "elevator"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            ELEVATE_DURATION: 4.0
            ELEVATE_DELAY: 4.0
            ELEVATE_TIMEOUT: 40.0
            DROP: true
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                          Telescopic fishing Profile                       #
          # -------------------------------------------------------------------------- #
          TELESCOPIC:
            MODE: "telescopic"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            FLOAT_SENSITIVITY: 0.68
            CHECK_DELAY: 1.0
            PULL_DELAY: 0.5
            DRIFT_TIMEOUT: 16.0
            CAMERA_SHAPE: "square"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                           Bolognese Fishing Profile                       #
          # -------------------------------------------------------------------------- #
          BOLOGNESE:
            MODE: "bolognese"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            FLOAT_SENSITIVITY: 0.68
            CHECK_DELAY: 1.0
            PULL_DELAY: 0.5
            DRIFT_TIMEOUT: 32.0
            CAMERA_SHAPE: "square"
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                           Custom Auto Fight Profile                       #
          # -------------------------------------------------------------------------- #
          AUTO_FIGHT_SPIN:
            MODE: "spin"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 6.0
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 2.0
            RETRIEVAL_DELAY: 2.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: "auto"
            TYPE: "lift"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
            AUTO_FIGHT_MODE: true
            FIGHT_LIFT_INTERVAL: 2.0
            FIGHT_RETRIEVAL_INTERVAL: 2.0
        
          AUTO_FIGHT_BOTTOM:
            MODE: "bottom"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            POST_ACCELERATION: "auto"
            CHECK_DELAY: 32.0
            CHECK_MISS_LIMIT: 16
            PUT_DOWN_DELAY: 0.0
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
            AUTO_FIGHT_MODE: true
            FIGHT_LIFT_INTERVAL: 2.0
            FIGHT_RETRIEVAL_INTERVAL: 2.0
    üìÑ requirements.txt
        pyautogui==0.9.54
        keyboard==0.13.5
        pywin32==306
        pynput==1.7.6
        opencv-python==4.8.0.76
        Pillow==10.1.0
        PyScreeze==0.1.29
        python-dotenv==1.0.1
        matplotlib==3.8.0
        playsound==1.2.2 # downgrade to avoid bug
        pyyaml==6.0.2
        yacs==0.1.8
        rich==13.9.4
        bump-my-version==0.32.1
        discord-webhook==1.4.1
        # reference: https://stackoverflow.com/questions/68704443/python-playsound-error-261-for-command-the-driver-cannot-recognize-the-specifie
    üìÑ setup.bat
        @echo off
        
        echo This might take a while...
        
        @REM for playsound module: https://github.com/TaylorSMarks/playsound/issues/145
        python -m pip install wheel setuptools pip --upgrade
        python -m pip install -r requirements.txt
        
        if not exist ".\screenshots" mkdir screenshots
        if not exist ".\logs" mkdir logs
        if not exist ".\config.yaml" copy ".\rf4s\config\config.yaml" ".\config.yaml"
    üìÑ tree_with_content.py
        import os
        import mimetypes
        
        # –†–∞—Å—à–∏—Ä–µ–Ω–∏—è –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ –∑–≤—É–∫–æ–≤
        IMAGE_EXTS = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.webp'}
        AUDIO_EXTS = {'.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a'}
        
        def is_image(filename):
            ext = os.path.splitext(filename)[1].lower()
            if ext in IMAGE_EXTS:
                return True
            mime, _ = mimetypes.guess_type(filename)
            return mime and mime.startswith('image')
        
        def is_audio(filename):
            ext = os.path.splitext(filename)[1].lower()
            if ext in AUDIO_EXTS:
                return True
            mime, _ = mimetypes.guess_type(filename)
            return mime and mime.startswith('audio')
        
        def get_file_content(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                return content
            except Exception:
                return "[ERROR: Unable to decode as UTF-8 or read file]"
        
        def tree_with_contents(start_path='.'):
            result = []
        
            for root, dirs, files in os.walk(start_path):
                level = root.replace(start_path, '').count(os.sep)
                indent = '    ' * level
                folder_name = os.path.basename(root) or os.path.abspath(root)
                result.append(f"{indent}üìÅ {folder_name}/")
                subindent = '    ' * (level + 1)
                for fname in files:
                    fpath = os.path.join(root, fname)
                    f_disp = f"{subindent}üìÑ {fname}"
                    if is_image(fname):
                        result.append(f"{f_disp} [IMAGE FILE]")
                    elif is_audio(fname):
                        result.append(f"{f_disp} [AUDIO FILE]")
                    else:
                        result.append(f"{f_disp}")
                        content = get_file_content(fpath)
                        # –ö—Ä–∞—Å–∏–≤–æ –≤—ã–≤–æ–¥–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
                        content_lines = content.splitlines()
                        for line in content_lines:
                            result.append(f"{subindent}    {line}")
                        if not content_lines:
                            result.append(f"{subindent}    [EMPTY FILE]")
            return '\n'.join(result)
        
        if __name__ == "__main__":
            output_file = "tree_with_contents.txt"
            folder = '.'
            tree_str = tree_with_contents(folder)
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(tree_str)
            print(f"–î–µ—Ä–µ–≤–æ —Ñ–∞–π–ª–æ–≤ –∏ –∏—Ö —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ {output_file}")
    üìÅ rf4s/
        üìÑ exceptions.py
            """
            A module reserved for exception classes.
            """
            
            
            class FishHookedError(Exception):
                """A fish is hooked during a wrong routine."""
            
            
            class FishCapturedError(Exception):
                """A fish is captured during a wrong routine."""
            
            
            class LineAtEndError(Exception):
                """Fishing line is at the end during retrieval."""
            
            
            class LineSnaggedError(Exception):
                """Fishing line is snagged."""
            
            
            class ItemNotFoundError(Exception):
                """Failed to find an available item for replacement."""
            
            
            class LureBrokenError(Exception):
                """Lure is broken."""
            
            
            class TackleBrokenError(Exception):
                """Tackle is broken."""
            
            
            class DisconnectedError(Exception):
                """Disconnected from the game."""
            
            
            class TicketExpiredError(Exception):
                """Ticket expired."""
        üìÑ player.py
            """Module for Player class.
            
            This module provides the main interface for automating fishing activities in a game.
            It includes functionality for managing fishing loops, handling player stats, and
            automating various fishing techniques.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import logging
            import msvcrt
            import os
            import random
            import sys
            from contextlib import contextmanager
            from datetime import datetime
            from multiprocessing import Lock
            
            # from email.mime.image import MIMEImage
            from pathlib import Path
            from time import sleep
            
            import pyautogui as pag
            from playsound import playsound
            from pynput import keyboard
            from rich import box, print
            from rich.table import Table
            
            from rf4s import exceptions, utils
            from rf4s.component.friction_brake import FrictionBrake
            from rf4s.component.tackle import Tackle
            from rf4s.controller.detection import Detection, TagColor
            from rf4s.controller.notification import (
                DiscordColor,
                DiscordNotification,
                EmailNotification,
                MiaotixingNotification,
            )
            from rf4s.controller.timer import Timer
            from rf4s.controller.window import Window
            from rf4s.result.result import RF4SResult
            
            logger = logging.getLogger("rich")
            random.seed(datetime.now().timestamp())
            
            PRE_RETRIEVAL_DURATION = 0.5
            PULL_OUT_DELAY = 3
            DIG_DELAY = 5
            DIG_TIMEOUT = 32
            ANIMATION_DELAY = 1
            TICKET_EXPIRE_DELAY = 16
            DISCONNECTED_DELAY = 8
            WEAR_TEXT_UPDATE_DELAY = 2
            PUT_DOWN_DELAY = 4
            
            SCREENSHOT_DELAY = 2
            
            TROLLING_KEY = "j"
            
            FORWARD = "w"
            LEFT_KEY = "a"
            RIGHT_KEY = "d"
            
            
            class Player:
                """Main interface of fishing loops and stages.
            
                This class manages the automation of fishing activities, including casting,
                retrieving, and handling fish. It also handles player stats, equipment, and
                various in-game mechanics.
            
                :param cfg: Configuration object containing settings for the fishing process.
                :type cfg: Config
                :param window: Window object for managing the game window.
                :type window: Window
                """
            
                def __init__(self, cfg, window: Window):
                    """Initialize monitor, timer, and some trivial counters.
            
                    :param cfg: Configuration object containing settings for the fishing process.
                    :type cfg: Config
                    :param window: Window object for managing the game window.
                    :type window: Window
                    """
                    self.cfg = cfg
                    self.window = window
                    self.timer = Timer(cfg)
                    self.detection = Detection(cfg, window)
            
                    self.tackle_idx = 0
                    if self.cfg.SELECTED.MODE == "bottom":
                        self.num_tackle = len(self.cfg.KEY.BOTTOM_RODS)
                    else:
                        self.num_tackle = 1
                    self.tackles = [
                        Tackle(cfg, self.timer, self.detection) for _ in range(self.num_tackle)
                    ]
                    self.tackle = self.tackles[self.tackle_idx]
            
                    self.friction_brake_lock = Lock()
                    self.friction_brake = FrictionBrake(
                        cfg, self.friction_brake_lock, self.detection
                    )
            
                    self.cur_coffee = 0
                    self.have_new_lure = True
                    self.have_new_groundbait = True
                    self.have_new_dry_mix = True
                    self.have_new_pva = True
                    self.result = RF4SResult()
            
                    self.clicklock_enabled = False
            
                def start_fishing(self) -> None:
                    """Start the main fishing loop with the specified fishing strategy."""
                    if self.cfg.ARGS.FRICTION_BRAKE:
                        logger.info("Spawing new process, do not quit the script")
                        self.friction_brake.monitor_process.start()
            
                    if (
                        self.cfg.SELECTED.MODE not in ("telescopic", "bottom")
                        and not self.cfg.ARGS.SKIP_CAST
                        and not self.detection.is_retrieval_finished()
                    ):
                        logger.critical(
                            "The spool is not fully loaded, "
                            "try moving your camera, "
                            "changing your game window size or fishing line"
                        )
                        utils.safe_exit()
            
                    logger.info("Starting fishing mode: '%s'", self.cfg.SELECTED.MODE)
                    self._start_trolling()
                    getattr(self, f"start_{self.cfg.SELECTED.MODE}_mode")()
            
                # ---------------------------------------------------------------------------- #
                #                              main fishing loops                              #
                # ---------------------------------------------------------------------------- #
                def start_spin_mode(self) -> None:
                    """Main spin fishing loop for 'spin' and 'spin_with_pause' modes."""
                    skip_cast = self.cfg.ARGS.SKIP_CAST
                    while True:
                        if not skip_cast:
                            self._refill_stats()
                            self._harvest_baits(pickup=True)
                            self.reset_tackle()
                            self._change_tackle_lure()
                            self._cast_tackle()
                        skip_cast = False
            
                        if self.cfg.SELECTED.TYPE != "normal":
                            utils.hold_mouse_button(self.cfg.SELECTED.TIGHTEN_DURATION)
                            getattr(self, f"retrieve_with_{self.cfg.SELECTED.TYPE}")()
                        self.retrieve_line()
            
                        if self.detection.is_fish_hooked():
                            self.pull_fish()
            
                def retrieve_with_pause(self) -> None:
                    """Retrieve the line, pausing periodically."""
                    logger.info("Retrieving fishing line with pause")
                    self.tackle._special_retrieve(button="left")
            
                def retrieve_with_lift(self) -> None:
                    """Retrieve the line, lifting periodically."""
                    logger.info("Retrieving fishing line with lift")
                    with self.toggle_clicklock():
                        self.tackle._special_retrieve(button="right")
            
                def start_bottom_mode(self) -> None:
                    """Main bottom fishing loop."""
                    check_miss_counts = [0] * self.num_tackle
            
                    while True:
                        if self.cfg.ARGS.SPOD_ROD and self.timer.is_spod_rod_castable():
                            self._cast_spod_rod()
                        self._refill_stats()
                        self._harvest_baits()
            
                        logger.info("Checking rod %s", self.tackle_idx + 1)
                        pag.press(str(self.cfg.KEY.BOTTOM_RODS[self.tackle_idx]))
                        sleep(ANIMATION_DELAY)
                        if self.detection.is_fish_hooked():
                            check_miss_counts[self.tackle_idx] = 0
                            self.retrieve_and_recast()
                        else:
                            sleep(self.cfg.SELECTED.PUT_DOWN_DELAY)
                            if self.detection.is_fish_hooked():
                                check_miss_counts[self.tackle_idx] = 0
                                self.retrieve_and_recast()
                            else:
                                self._put_down_tackle(check_miss_counts)
                        self._update_tackle()
            
                def retrieve_and_recast(self) -> None:
                    self.retrieve_line()
                    self.pull_fish()
                    self.reset_tackle()
                    self._refill_groundbait()
                    self._refill_pva()
                    self._cast_tackle(lock=True)
            
                def start_pirk_mode(self) -> None:
                    """Main marine fishing loop for pirk mode."""
                    self._start_sink_mode(pirk=True)
            
                def start_elevator_mode(self) -> None:
                    """Main marine fishing loop for elevator mode."""
                    self._start_sink_mode(pirk=False)
            
                def _start_sink_mode(self, pirk: bool) -> None:
                    """Main marine fishing loop for pirk or elevator mode.
            
                    :param pirk: Whether to perform pirking or elevating.
                    :type pirk: bool
                    """
                    perform_technique = self.do_pirking if pirk else self.do_elevating
                    skip_cast = self.cfg.ARGS.SKIP_CAST
                    while True:
                        if not skip_cast:
                            self._refill_stats()
                            self.reset_tackle()
                            self._cast_tackle()
                            self.tackle.sink()
                        skip_cast = False
            
                        perform_technique()
                        self.retrieve_line()
                        self.pull_fish()
            
                def start_telescopic_mode(self) -> None:
                    """Main telescopic fishing loop."""
                    self._start_float_mode(telescopic=True)
            
                def start_bolognese_mode(self) -> None:
                    """Main bolognese fishing loop."""
                    self._start_float_mode(telescopic=False)
            
                def _start_float_mode(self, telescopic: bool) -> None:
                    """Main float fishing loop.
            
                    :param telescopic: Whether the fishing mode is telescopic.
                    :type telescopic: bool
                    """
                    monitor, hold_mouse_button = self._get_controllers(telescopic)
            
                    while True:
                        self._refill_stats()
                        self._harvest_baits(pickup=True)
                        self.reset_tackle()
                        self._cast_tackle()
            
                        try:
                            with self.error_handler():
                                monitor()
                            sleep(self.cfg.SELECTED.PULL_DELAY)
                            hold_mouse_button(PRE_RETRIEVAL_DURATION)
                            self.pull_fish()
                        except TimeoutError:
                            pass
            
                def _harvest_baits(self, pickup: bool = False) -> None:
                    """Harvest baits if energy is high.
            
                    :param pickup: Whether to pick up the main rod after harvesting.
                    :type pickup: bool
                    """
                    if not self.cfg.ARGS.HARVEST or not self.detection.is_energy_high():
                        return
                    logger.info("Harvesting baits")
                    self._use_item("digging_tool")
                    sleep(PULL_OUT_DELAY)
                    pag.click()
            
                    i = DIG_TIMEOUT
                    while i > 0:
                        i = utils.sleep_and_decrease(i, DIG_DELAY)
                        if self.detection.is_harvest_success():
                            logger.info("Baits harvested successfully")
                            pag.press("space")
                            pag.press("backspace")
                            sleep(ANIMATION_DELAY)
                            self.result.bait += 1
                            break
            
                    if pickup:
                        self._use_item("main_rod")
                        sleep(PULL_OUT_DELAY)
            
                    # When timed out, do not raise a TimeoutError but defer it to resetting stage
            
                def _refill_stats(self) -> None:
                    """Refill player stats using tea and carrot."""
                    if not self.cfg.ARGS.REFILL:
                        return
            
                    logger.info("Refilling player stats")
                    # Comfort is affected by weather, add a check to avoid over drink
                    if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
                        self._use_item("tea")
                        self.result.tea += 1
            
                    if self.detection.is_hunger_low():
                        self._use_item("carrot")
                        self.result.carrot += 1
            
                def _drink_alcohol(self) -> None:
                    """Drink alcohol with the given quantity."""
                    if not self.cfg.ARGS.ALCOHOL or not self.timer.is_alcohol_drinkable():
                        return
            
                    logger.info("Drinking alcohol")
                    for _ in range(self.cfg.STAT.ALCOHOL_PER_DRINK):
                        self._use_item("alcohol")
                    self.result.alcohol += self.cfg.STAT.ALCOHOL_PER_DRINK
            
                def _drink_coffee(self) -> None:
                    """Drink coffee to refill energy if energy is low."""
                    if not self.cfg.ARGS.COFFEE or self.detection.is_energy_high():
                        return
            
                    if self.cur_coffee > self.cfg.STAT.COFFEE_LIMIT:
                        pag.press("esc")  # Just back to control panel to reduce power usage
                        self._handle_termination("Coffee limit reached", shutdown=False)
            
                    logger.info("Drinking coffee")
                    for _ in range(self.cfg.STAT.COFFEE_PER_DRINK):
                        self._use_item("coffee")
                    self.cur_coffee += self.cfg.STAT.COFFEE_PER_DRINK
                    self.result.coffee += self.cfg.STAT.COFFEE_PER_DRINK
            
                def _use_item(self, item: str) -> None:
                    """Access an item by name using quick selection shortcut or menu.
            
                    :param item: The name of the item to access.
                    :type item: str
                    """
                    logger.info("Using %s", item)
                    key = str(self.cfg.KEY[item.upper()])
                    if key != "-1":  # Use shortcut
                        pag.press(key)
                    else:  # Open food menu
                        with pag.hold("t"):
                            sleep(ANIMATION_DELAY)
                            food_position = self.detection.get_food_position(item)
                            pag.moveTo(food_position)
                            pag.click()
                    sleep(ANIMATION_DELAY)
            
                def enable_clicklock(self):
                    pag.mouseDown()
                    sleep(2.2)
                    self.clicklock_enabled = True
            
                def disable_clicklock(self):
                    pag.click()
                    self.clicklock_enabled = False
            
                @contextmanager
                def toggle_clicklock(self):
                    self.enable_clicklock()
                    yield
                    self.disable_clicklock()
            
                @utils.reset_friction_brake_after
                def reset_tackle(self) -> None:
                    """Reset the tackle until it is ready."""
                    sleep(ANIMATION_DELAY)
                    if self.detection.is_tackle_ready():
                        return
            
                    if self.detection.is_lure_broken():
                        self._handle_broken_lure()
                        return
            
                    if self.cfg.ARGS.SPOD_ROD and not self.detection.is_groundbait_chosen():
                        self._refill_dry_mix()
                        return
            
                    if not self.detection.is_bait_chosen():
                        if len(self.tackles) == 1:
                            self.general_quit("Run out of bait")
                        self.tackle.available = False
                        return
            
                    with self.toggle_clicklock():
                        while True:
                            try:
                                # Outer -> inner
                                with (
                                    self.error_handler(),
                                    self.clicklock_disable_handler(),
                                    pag.hold("shift"),
                                ):
                                    self.tackle.reset()
                                break
                            except TimeoutError:
                                # If it's a TimeoutError or an exception was transformed into a
                                # TimeoutError, enable clicklock again if necessary.
                                if not self.clicklock_enabled:
                                    self.enable_clicklock()
            
                @contextmanager
                def error_handler(self):
                    try:
                        yield
                    except exceptions.FishHookedError:
                        self.pull_fish()
                    except exceptions.FishCapturedError:
                        self.handle_fish()
                    except exceptions.LineAtEndError:
                        if self.cfg.ARGS.FRICTION_BRAKE:
                            with self.friction_brake.lock:
                                self.friction_brake.change(increase=False)
                        self.general_quit("Fishing line is at its end")
                    except exceptions.LineSnaggedError:
                        self._handle_snagged_line()
                    except exceptions.LureBrokenError:
                        self._handle_broken_lure()
                        raise TimeoutError  # Transform into TimeoutError to continue
                    except exceptions.TackleBrokenError:
                        self.general_quit("Tackle is broken")
                    except exceptions.DisconnectedError:
                        self.disconnected_quit()
                    except exceptions.TicketExpiredError:
                        self._handle_expired_ticket()
                        raise TimeoutError  # Transform into TimeoutError to continue
                    except TimeoutError:
                        raise
            
                @contextmanager
                def clicklock_disable_handler(self):
                    try:
                        yield
                    except (
                        exceptions.FishHookedError,
                        exceptions.FishCapturedError,
                        exceptions.LineAtEndError,
                        exceptions.LineSnaggedError,
                        exceptions.LureBrokenError,
                        exceptions.TackleBrokenError,
                        exceptions.DisconnectedError,
                        exceptions.TicketExpiredError,
                    ):
                        if self.clicklock_enabled:
                            self.disable_clicklock()
                        raise
            
                def _cast_spod_rod(self) -> None:
                    """Cast the spod rod if dry mix is available."""
                    self._use_item("spod_rod")
                    self.reset_tackle()
            
                    # If no dry mix is available, skip casting
                    if not self.tackle.available:
                        self.tackle.available = True
                        return
                    self._cast_tackle(lock=True, update=False)
                    pag.press("0")
                    sleep(ANIMATION_DELAY)
            
                def _cast_tackle(self, lock: bool = False, update: bool = True) -> None:
                    """Cast the current tackle.
            
                    :param lock: Whether to lock the tackle after casting.
                    :type lock: bool
                    :param update: Whether to update the cast time.
                    :type update: bool
                    """
                    if self.cfg.ARGS.PAUSE and self.timer.is_script_pausable():
                        self._pause_script()
            
                    if self.cfg.ARGS.BITE:
                        self.window.save_screenshot(self.timer.get_cur_timestamp())
            
                    if (
                        self.cfg.ARGS.RANDOM_CAST
                        and random.random() <= self.cfg.SCRIPT.RANDOM_CAST_PROBABILITY
                    ):
                        logger.info("Casting rod redundantly")
                        pag.click()
                        sleep(2)
                        self.reset_tackle()
            
                    self.tackle.cast(lock)
                    if update:
                        self.timer.update_cast_time()
            
                def retrieve_line(self) -> None:
                    """Retrieve the fishing line until it is fully retrieved."""
                    if self.detection.is_retrieval_finished():
                        return
            
                    first = True
                    gr_switched = False
                    if self.cfg.ARGS.ELECTRO:
                        self.tackle.switch_gear_ratio()  # Use electro mode
            
                    self.cur_coffee = 0
            
                    with self.toggle_clicklock():
                        while True:
                            try:
                                with (
                                    self.error_handler(),
                                    self.clicklock_disable_handler(),
                                ):
                                    self.tackle.retrieve(first)
                                break
                            except TimeoutError:
                                if not self.clicklock_enabled:
                                    self.enable_clicklock()
                                first = False
                                if self.cfg.ARGS.GEAR_RATIO and not gr_switched:
                                    self.tackle.switch_gear_ratio()
                                    gr_switched = True
                                pag.keyUp("shift")
                                self._drink_coffee()
            
                        pag.keyUp("shift")
                        if gr_switched:
                            self.tackle.switch_gear_ratio()
            
                def do_pirking(self) -> None:
                    """Perform pirking until a fish is hooked."""
                    if self.cfg.SELECTED.PIRK_RETRIEVAL:
                        with self.toggle_clicklock():
                            self._do_pirking()
                    else:
                        self._do_pirking()
            
                def _do_pirking(self) -> None:
                    while True:
                        try:
                            with self.error_handler(), self.clicklock_disable_handler():
                                self.tackle.pirk()
                            break
                        except TimeoutError:
                            if self.cfg.SELECTED.PIRK_RETRIEVAL:
                                if not self.clicklock_enabled:
                                    self.enable_clicklock()
                                continue
            
                            if self.cfg.SELECTED.DEPTH_ADJUST_DELAY > 0:
                                logger.info("Adjusting lure depth")
                                pag.press("enter")  # Open reel
                                sleep(self.cfg.SELECTED.DEPTH_ADJUST_DELAY)
                                utils.hold_mouse_button(self.cfg.SELECTED.DEPTH_ADJUST_DURATION)
                            else:
                                self.reset_tackle()
                                self._cast_tackle()
                                self.tackle.sink()
            
                def do_elevating(self) -> None:
                    """Perform elevating until a fish is hooked."""
                    dropped = False
                    while True:
                        try:
                            dropped = not dropped
                            with self.error_handler():
                                self.tackle.elevate(dropped)
                            break
                        except TimeoutError:
                            pass
            
                def pull_fish(self) -> None:
                    """Pull the fish up and handle it."""
                    if not self.detection.is_fish_hooked():
                        return
            
                    self._drink_alcohol()
                    with self.toggle_clicklock():
                        while True:
                            try:
                                with self.error_handler(), self.clicklock_disable_handler():
                                    self.tackle.pull()
                                self.handle_fish()
                                break
                            except TimeoutError:
                                self.disable_clicklock()
                                sleep(PUT_DOWN_DELAY)
                                if not self.clicklock_enabled:
                                    self.enable_clicklock()
            
                def _put_down_tackle(self, check_miss_counts: list[int]) -> None:
                    """Put down the tackle and wait for a while.
            
                    :param check_miss_counts: List of miss counts for all rods.
                    :type check_miss_counts: list[int]
                    """
                    check_miss_counts[self.tackle_idx] += 1
                    if check_miss_counts[self.tackle_idx] >= self.cfg.SELECTED.CHECK_MISS_LIMIT:
                        check_miss_counts[self.tackle_idx] = 0
                        self.reset_tackle()
                        self._refill_groundbait()
                        self._refill_pva()
                        self._cast_tackle(lock=True)
            
                    pag.press("0")
                    bound = self.cfg.SELECTED.CHECK_DELAY // 5
                    random_offset = random.uniform(-bound, bound)
                    sleep(self.cfg.SELECTED.CHECK_DELAY + random_offset)
            
                def _start_trolling(self) -> None:
                    """Start trolling and change moving direction based on the trolling setting."""
                    if self.cfg.ARGS.TROLLING is None:
                        return
                    logger.info("Starting trolling")
                    pag.press(TROLLING_KEY)
                    if self.cfg.ARGS.TROLLING not in ("left", "right"):  # Forward
                        return
                    pag.keyDown(LEFT_KEY if self.cfg.ARGS.TROLLING == "left" else RIGHT_KEY)
            
                def _update_tackle(self) -> None:
                    """Update the current tackle (rod) being used."""
                    candidates = self._get_available_rods()
                    if not candidates:
                        self.general_quit("All rods are unavailable")
                    if self.cfg.SCRIPT.RANDOM_ROD_SELECTION:
                        self.tackle_idx = random.choice(candidates)
                    else:
                        self.tackle_idx = candidates[0]
                    self.tackle = self.tackles[self.tackle_idx]
            
                def _get_available_rods(self) -> list[int]:
                    """
                    Get a list of available rods.
            
                    :return: List of indices of available rods.
                    :rtype: list[int]
                    """
                    if self.num_tackle == 1 and self.tackle.available:
                        return [self.tackle]
            
                    candidates = list(range(len(self.tackles)))
                    # Rotate the candidates for sequential polling
                    start = candidates.index(self.tackle_idx)
                    candidates = candidates[start:] + candidates[:start]
                    candidates = [i for i in candidates if self.tackles[i].available]
            
                    #  Exclude current rod only if there's another available tackle
                    if len(candidates) > 1 and self.tackle_idx in candidates:
                        candidates.remove(self.tackle_idx)
                    return candidates
            
                def _change_tackle_lure(self) -> None:
                    """Change the lure on the current tackle if possible."""
                    if not self.cfg.ARGS.LURE or not self.have_new_lure:
                        return
            
                    if self.timer.is_lure_changeable():
                        logger.info("Changing lure randomly")
                        try:
                            self.tackle.equip_item("lure")
                        except exceptions.ItemNotFoundError:
                            logger.error("New lure not found")
                            self.have_new_lure = False
            
                def _refill_pva(self) -> None:
                    """Refill the PVA bag if it has been used up."""
                    if not self.cfg.ARGS.PVA or not self.have_new_pva:
                        return
            
                    if not self.detection.is_pva_chosen():
                        try:
                            self.tackle.equip_item("pva")
                        except exceptions.ItemNotFoundError:
                            logger.error("New pva not found")
                            self.have_new_pva = False
            
                def _refill_dry_mix(self) -> None:
                    """Refill the dry mix if it has been used up."""
                    if not self.cfg.ARGS.DRY_MIX or not self.have_new_dry_mix:
                        return
                    try:
                        self.tackle.equip_item("dry_mix")
                    except exceptions.ItemNotFoundError:
                        logger.error("New dry mix not found")
                        self.tackle.available = False  # Skip following stages
                        self.have_new_dry_mix = False
            
                def _refill_groundbait(self) -> None:
                    """Refill the groundbait if it has been used up."""
                    if not self.cfg.ARGS.GROUNDBAIT or not self.have_new_groundbait:
                        return
            
                    if self.detection.is_groundbait_chosen():
                        logger.info("Groundbait is not used up yet")
                    else:
                        try:
                            self.tackle.equip_item("groundbait")
                        except exceptions.ItemNotFoundError:
                            logger.error("New groundbait not found")
                            self.have_new_groundbait = False
            
                def test(self):
                    """Boo!"""
                    self.retrieve_line()
            
                # TBD: Menu, Plotter, Result, Handler
                def _get_controllers(self, telescopic: bool) -> tuple[callable, callable]:
                    """Get the monitor and hold_mouse_button functions based on the fishing mode.
            
                    :param telescopic: Whether the fishing mode is telescopic.
                    :type telescopic: bool
                    :return: Tuple containing the monitor and hold_mouse_button functions.
                    :rtype: tuple[callable, callable]
                    """
                    if telescopic:
                        hold_mouse_button = utils.hold_mouse_button
                        monitor = self.tackle._monitor_float_state
                    else:
                        if self.detection.is_clip_open():
                            logger.warning("Clip is not set, fall back to camera mode")
                            monitor = self.tackle._monitor_float_state
                        else:
                            monitor = self.tackle._monitor_clip_state
                        hold_mouse_button = utils.hold_mouse_buttons
            
                    return monitor, hold_mouse_button
            
                def _pause_script(self) -> None:
                    """Pause the script for a specified duration."""
                    logger.info("Pausing script")
                    pag.press("esc")
                    bound = self.cfg.PAUSE.DURATION // 5
                    offset = random.randint(-bound, bound)
                    sleep(self.cfg.PAUSE.DURATION + offset)
                    pag.press("esc")
            
                def _handle_timeout(self) -> None:
                    """Handle common timeout events."""
                    if self.detection.is_tackle_broken():
                        self.general_quit("Tackle is broken")
            
                    if self.detection.is_disconnected():
                        self.disconnected_quit()
            
                    if self.detection.is_ticket_expired():
                        self._handle_expired_ticket()
            
                def _handle_broken_lure(self) -> None:
                    """Handle the broken lure event according to the settings."""
                    match self.cfg.ARGS.BROKEN_LURE:
                        case "replace":
                            self._replace_broken_lures()
                        case "alarm":
                            playsound(str(Path(self.cfg.SCRIPT.ALARM_SOUND).resolve()))
                            self.window.activate_script_window()
                            print("Please replace your lure.")
                            print("Press any key to continue...")
                            msvcrt.getch()
                            self.window.activate_game_window()
                        case _:
                            self.general_quit("Lure is broken")
            
                @utils.release_keys_after(arrow_keys=True)
                def _handle_termination(self, msg: str, shutdown: bool) -> None:
                    """Handle script termination.
            
                    :param msg: The reason for termination.
                    :type msg: str
                    :param shutdown: Whether to shutdown the computer after termination.
                    :type shutdown: bool
                    """
                    result = self.build_result_dict(msg)
                    table = self.build_result_table(result)
                    if self.cfg.ARGS.DISCORD:
                        # TODO: dynamic color
                        DiscordNotification(self.cfg, result).send=int(DiscordColor.BLURPLE.value)
                    if self.cfg.ARGS.EMAIL:
                        EmailNotification(self.cfg, result).send()
                    if self.cfg.ARGS.MIAOTIXING:
                        MiaotixingNotification(self.cfg, result).send()
                    if self.cfg.ARGS.DATA and self.result.kept != 0:
                        self.timer.plot_and_save()
                    if shutdown and self.cfg.ARGS.SHUTDOWN:
                        os.system("shutdown /s /t 5")
                    print(table)
                    utils.safe_exit()
            
                def _handle_snagged_line(self) -> None:
                    """Handle a snagged line event."""
                    if len(self.tackles) == 1:
                        self.general_quit("Line is snagged")
                    self.tackle.available = False
            
                def handle_fish(self) -> None:
                    if not self.detection.is_fish_captured():
                        return
                    logger.info("Handling fish")
                    self._handle_fish()
                    sleep(ANIMATION_DELAY)
                    while self.detection.is_gift_receieved():
                        sleep(self.cfg.KEEPNET.GIFT_DELAY)
                        pag.press("space")
            
                def _handle_fish(self) -> None:
                    """Keep or release the fish and record the fish count."""
                    tagged = False
                    for tag in self.cfg.SCRIPT.SCREENSHOT_TAGS:
                        if self.detection.is_tag_exist(TagColor[tag.upper()]):
                            tagged = True
                    tagged = not self.cfg.SCRIPT.SCREENSHOT_TAGS or tagged
                    if self.cfg.ARGS.SCREENSHOT and tagged:
                        self.window.save_screenshot(self.timer.get_cur_timestamp())
            
                    self.result.total += 1
                    if self.detection.is_fish_blacklisted():
                        pag.press("backspace")
                        return
            
                    tagged = False
                    for tag in TagColor:
                        if self.detection.is_tag_exist(tag):
                            tag_color = tag.name.lower()
                            setattr(self.result, tag_color, getattr(self.result, tag_color) + 1)
                            if tag_color in self.cfg.KEEPNET.TAGS:
                                tagged = True
            
                    if (
                        self.cfg.ARGS.TAG
                        and not tagged
                        and not self.detection.is_fish_whitelisted()
                    ):
                        pag.press("backspace")
                        return
            
                    # Fish is tagged, ARGS.TAG is disabled, or fish is in whitelist
                    sleep(self.cfg.KEEPNET.FISH_DELAY)
                    pag.press("space")
            
                    self.result.kept += 1
                    limit = self.cfg.KEEPNET.CAPACITY - self.cfg.ARGS.FISHES_IN_KEEPNET
                    if self.result.kept == limit:
                        self._handle_full_keepnet()
            
                    # Avoid wrong cast hour
                    if self.cfg.SELECTED.MODE in ["bottom", "pirk", "elevator"]:
                        self.timer.update_cast_time()
                    self.timer.add_cast_time()
            
                def _handle_full_keepnet(self) -> None:
                    """Handle a full keepnet event."""
                    match self.cfg.KEEPNET.FULL_ACTION:
                        case "alarm":
                            playsound(str(Path(self.cfg.SCRIPT.ALARM_SOUND).resolve()))
                            self.window.activate_script_window()
                            print("Press any key to continue...")
                            msvcrt.getch()
                            self.window.activate_game_window()
                            with keyboard.Listener(on_release=self._on_release) as listner:
                                listner.join()
                            logger.info("Continue running script")
                        case "quit":
                            self.general_quit("Keepnet is full")
                        case _:
                            raise ValueError
            
                def _on_release(self, _: keyboard.KeyCode) -> None:
                    """Handle key release events."""
                    sys.exit()
            
                def general_quit(self, msg: str) -> None:
                    """Quit the game through the control panel.
            
                    :param msg: reason for termination
                    :type msg: str
                    """
                    logger.critical(msg)
                    sleep(ANIMATION_DELAY)
                    pag.press("esc")
                    sleep(ANIMATION_DELAY)
            
                    if self.cfg.ARGS.SIGNOUT:
                        pag.keyDown("shift")
                    pag.moveTo(self.detection.get_quit_position())
                    pag.click()
                    pag.keyUp("shift")
                    sleep(ANIMATION_DELAY)
                    pag.moveTo(self.detection.get_yes_position())
                    pag.click()
            
                    self._handle_termination(msg, shutdown=True)
            
                def disconnected_quit(self) -> None:
                    """Quit the game through the main menu."""
                    pag.press("space")
                    # Sleep to bypass the black screen (experimental)
                    sleep(DISCONNECTED_DELAY)
                    pag.press("space")
                    sleep(ANIMATION_DELAY)
                    if not self.cfg.ARGS.SIGNOUT:
                        pag.moveTo(self.detection.get_exit_icon_position())
                        pag.click()
                        sleep(ANIMATION_DELAY)
                        pag.moveTo(self.detection.get_confirm_button_position())
                        pag.click()
            
                    self._handle_termination("Game disconnected", shutdown=True)
            
                def build_result_dict(self, msg: str):
                    return self.result.as_dict(msg, self.timer)
            
                def build_result_table(self, result) -> Table:
                    """Create a Rich table from running result.
            
                    :return: formatted running result table
                    :rtype: Table
                    """
                    table = Table(
                        "Field", "Value", title="Running Result", box=box.DOUBLE, show_header=False
                    )
            
                    for k, v in result.items():
                        table.add_row(k, str(v))
                    return table
            
                def _handle_expired_ticket(self) -> None:
                    """Handle an expired boat ticket event."""
                    if self.cfg.ARGS.BOAT_TICKET is None:
                        pag.press("esc")
                        sleep(TICKET_EXPIRE_DELAY)
                        self.general_quit("Boat ticket expired")
            
                    logger.info("Renewing boat ticket")
                    ticket_loc = self.detection.get_ticket_position(self.cfg.ARGS.BOAT_TICKET)
                    if ticket_loc is None:
                        pag.press("esc")  # Close ticket menu
                        sleep(ANIMATION_DELAY)
                        self.general_quit("New boat ticket not found")
                    pag.moveTo(ticket_loc)
                    pag.click(clicks=2, interval=0.1)  # pag.doubleClick() not implemented
                    sleep(ANIMATION_DELAY)
            
                @utils.press_before_and_after("v")
                def _replace_broken_lures(self) -> None:
                    """Replace multiple broken lures."""
                    logger.info("Replacing broken lures")
            
                    scrollbar_position = self.detection.get_scrollbar_position()
                    if scrollbar_position is None:
                        logger.info("Scroll bar not found, changing lures for normal rig")
                        while self._open_broken_lure_menu():
                            self._replace_item()
                        pag.press("v")
                        return
            
                    logger.info("Scroll bar found, changing lures for dropshot rig")
                    pag.moveTo(scrollbar_position)
                    for _ in range(5):
                        sleep(ANIMATION_DELAY)
                        pag.drag(xOffset=0, yOffset=125, duration=0.5, button="left")
            
                        replaced = False
                        while self._open_broken_lure_menu():
                            self._replace_item()
                            replaced = True
            
                        if replaced:
                            pag.moveTo(self.detection.get_scrollbar_position())
            
                def _open_broken_lure_menu(self) -> bool:
                    """Open the broken lure menu.
            
                    :return: True if the broken lure is found, False otherwise.
                    :rtype: bool
                    """
                    logger.info("Looking for broken lure")
                    broken_item_position = self.detection.get_100wear_position()
                    if broken_item_position is None:
                        logger.warning("Broken lure not found")
                        return False
            
                    # click item to open selection menu
                    pag.moveTo(broken_item_position)
                    sleep(ANIMATION_DELAY)
                    pag.click()
                    sleep(ANIMATION_DELAY)
                    return True
            
                def _replace_item(self) -> None:
                    """Replace a broken item with a favorite item."""
                    logger.info("Looking for favorite items")
                    favorite_item_positions = self.detection.get_favorite_item_positions()
                    while True:
                        favorite_item_position = next(favorite_item_positions, None)
                        if favorite_item_position is None:
                            pag.press("esc")
                            sleep(ANIMATION_DELAY)
                            pag.press("esc")
                            sleep(ANIMATION_DELAY)
                            self.general_quit("Favorite item not found")
            
                        # Check if the lure for replacement is already broken
                        x, y = utils.get_box_center(favorite_item_position)
                        if pag.pixel(x - 60, y + 190) != (178, 59, 30):  # Magic value #TODO
                            logger.info("Lure replaced successfully")
                            pag.moveTo(x - 60, y + 190)
                            pag.click(clicks=2, interval=0.1)
                            sleep(WEAR_TEXT_UPDATE_DELAY)
                            break
        üìÑ utils.py
            """Helper functions for automation scripts.
            
            This module provides utility functions for common tasks such as mouse control,
            keyboard input, and result display. It also includes decorators for managing
            key and mouse states during automation.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import ctypes
            import logging
            import msvcrt
            import shlex
            import sys
            from time import sleep
            
            import pyautogui as pag
            from pyscreeze import Box
            from rich.console import Console
            from rich.logging import RichHandler
            from rich.text import Text
            
            # BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
            BASE_DELAY = 1.2
            LOOP_DELAY = 1
            
            ANIMATION_DELAY = 1
            
            logger = logging.getLogger("rich")
            
            # ---------------------------------------------------------------------------- #
            #                            common functionalities                            #
            # ---------------------------------------------------------------------------- #
            
            
            def hold_mouse_button(duration: float = 1, button: str = "left") -> None:
                """Hold left or right mouse button.
            
                :param duration: Hold time, defaults to 1.
                :type duration: float, optional
                :param button: Button to click, defaults to "left".
                :type button: str, optional
                """
                if duration == 0:
                    return
            
                pag.mouseDown(button=button)
                sleep(duration)
                pag.mouseUp(button=button)
                if button == "left" and duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
                    pag.click()
            
            
            def hold_mouse_buttons(duration: float = 1) -> None:
                """Hold left and right mouse buttons simultaneously.
            
                :param duration: Hold time, defaults to 1.
                :type duration: float, optional
                """
                pag.mouseDown()
                pag.mouseDown(button="right")
                sleep(duration)
                pag.mouseUp()
                pag.mouseUp(button="right")
                if duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
                    pag.click()
            
            
            def sleep_and_decrease(num: int, delay: int) -> int:
                """Self-decrement with a delay.
            
                :param num: The variable to decrease.
                :type num: int
                :param delay: Sleep time.
                :type delay: int
                :return: Decreased num.
                :rtype: int
                """
                sleep(delay)
                return num - delay
            
            
            def ask_for_confirmation(msg: str = "Ready to start") -> None:
                """Ask for confirmation of user settings if it's enabled.
            
                :param msg: Confirmation message, defaults to "Ready to start".
                :type msg: str
                """
                while True:
                    ans = input(f"{msg}? [Y/n] ").strip().lower()
                    if ans in ("y", ""):
                        break
                    if ans == "n":
                        sys.exit()
            
            
            def get_box_center(box: Box) -> tuple[int, int]:
                """Get the center coordinate (x, y) of the given box.
            
                # (x, y, w, h) -> (x, y), np.int64 -> int
            
                :param box: Box coordinates (x, y, w, h).
                :type box: Box
                :return: x and y coordinates of the center point.
                :rtype: tuple[int, int]
                """
                return int(box.left + box.width // 2), int(box.top + box.height // 2)
            
            
            def create_rich_logger() -> RichHandler:
                """Create a default RichHandler for logging.
            
                :return: Logging handler from rich.
                :rtype: RichHandler
                """
                # Ignore %(name)s because it's too verbose
                # https://rich.readthedocs.io/en/latest/logging.html
                logging.basicConfig(
                    level=logging.INFO,
                    format="%(message)s",
                    datefmt="%Y-%m-%d %H:%M:%S",
                    handlers=[RichHandler(rich_tracebacks=True)],
                )
                return logging.getLogger("rich")
            
            
            # ---------------------------------------------------------------------------- #
            #                                  decorators                                  #
            # ---------------------------------------------------------------------------- #
            
            
            # def toggle_clicklock(func):
            #     """Toggle clicklock before and after calling the function."""
            
            #     def wrapper(self, *args, **kwargs):
            #         # ELECTRO must be enabled, always use electric mode if GEAR_RATIO is disabled
            #         # otherwise, only use electric mode when it's the first time
            #         if self.cfg.ARGS.ELECTRO and (
            #             not self.cfg.ARGS.GEAR_RATIO or (not args or args[0])
            #         ):
            #             pag.click(clicks=2, interval=0.1)
            #         else:
            #             pag.mouseDown()
            #         sleep(BASE_DELAY + LOOP_DELAY)
            #         try:
            #             func(self, *args, **kwargs)
            #         finally:
            #             if self.cfg.ARGS.ELECTRO:
            #                 pag.click(clicks=2, interval=0.1)
            #             else:
            #                 pag.click()
            
            #     return wrapper
            
            
            def toggle_right_mouse_button(func):
                """Toggle right mouse button before and after calling the function."""
            
                def wrapper(*args, **kwargs):
                    pag.mouseDown(button="right")
                    try:
                        func(*args, **kwargs)
                    finally:
                        pag.mouseUp(button="right")
            
                return wrapper
            
            
            def press_before_and_after(key):
                def func_wrapper(func):
                    def args_wrapper(*args, **kwargs):
                        pag.press(key)
                        sleep(ANIMATION_DELAY)
                        try:
                            func(*args, **kwargs)
                        finally:
                            pag.press(key)
                            sleep(ANIMATION_DELAY)
            
                    return args_wrapper
            
                return func_wrapper
            
            
            def release_keys_after(arrow_keys: bool = False):
                """Release keys that might have been holding down
            
                :param arrow_keys: whether to toggle arrow keys, defaults to False
                :type arrow_keys: bool, optional
                """
            
                def release_keys(arrow_keys):
                    pag.keyUp("ctrl")
                    pag.keyUp("shift")
                    if arrow_keys:
                        pag.keyUp("w")
                        pag.keyUp("a")
                        pag.keyUp("d")
            
                def func_wrapper(func):  # Capture arrow_keys as default arg
                    def args_wrapper(*args, **kwargs):
                        try:
                            return func(*args, **kwargs)
                        finally:
                            release_keys(arrow_keys)  # Uses the captured value
            
                    return args_wrapper
            
                return func_wrapper
            
            
            def print_error(msg):
                text = Text(msg)
                text.stylize("red")
                Console().print(text)
            
            
            # There's lots of early return in player._resetting_stage(),
            # so use a decorator here to simplify the code
            def reset_friction_brake_after(func):
                """Reset friction brake after calling the function."""
            
                def wrapper(self, *args, **kwargs):
                    func(self, *args, **kwargs)
                    if not self.cfg.ARGS.FRICTION_BRAKE:
                        return
            
                    with self.friction_brake_lock:
                        self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)
            
                return wrapper
            
            
            def is_compiled():
                return "__compiled__" in globals()  # Nuitka style
            
            
            def is_run_by_clicking():
                # Load kernel32.dll
                kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
                # Create an array to store the processes in.  This doesn't actually need to
                # be large enough to store the whole process list since GetConsoleProcessList()
                # just returns the number of processes if the array is too small.
                process_array = (ctypes.c_uint * 1)()
                num_processes = kernel32.GetConsoleProcessList(process_array, 1)
                # num_processes may be 1 if your compiled program doesn't have a launcher/wrapper.
                # If run from Python interpreter, num_processes would also be 2
                # We also need to check if it's an executable to make it work
                return is_compiled() and num_processes == 2
            
            
            def update_argv():
                if is_run_by_clicking():
                    logger.info("No launch options used")
                    sys.argv = ["foo"] + shlex.split(
                        input("Enter launch options (press Enter to skip): ")
                    )
            
            
            def safe_exit():
                if is_run_by_clicking():
                    print("Press any key to quit.")
                    # KeyboardInterrupt will mess with stdin, input will crash silently
                    # Use msvcrt.getch() because it doesn't depends on stdin
                    msvcrt.getch()
                sys.exit()
        üìÑ __init__.py
            [EMPTY FILE]
        üìÅ app/
            üìÑ app.py
                """Base application class for other tools.
                
                Provides core functionality for:
                - Configuration management
                - Window control
                - Result display
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                import os
                import signal
                import sys
                from abc import ABC, abstractmethod
                from pathlib import Path
                
                from pynput import keyboard
                from rich import print
                from rich.table import Table
                from yacs.config import CfgNode as CN
                
                from rf4s.config import config
                from rf4s.controller.detection import Detection
                from rf4s.controller.window import Window
                from rf4s.result.result import Result
                from rf4s.utils import is_compiled, safe_exit
                
                # Get the base path depending on runtime environment
                if is_compiled():
                    ROOT = Path(sys.executable).parent  # Running as .exe (Nuitka/PyInstaller)
                else:
                    ROOT = Path(__file__).resolve().parents[2]
                
                logger = logging.getLogger("rich")
                
                
                class App(ABC):
                    """A base application class.
                
                    Attributes:
                        cfg (yacs.config.CfgNode): Default + user's configuration file
                        window (Window): Window controller
                    """
                
                    def __init__(self):
                        """Initialize a mutable cfg node for further modification."""
                        self.cfg = config.setup_cfg()
                
                        config_path = ROOT / "config.yaml"
                        if not config_path.exists():
                            logger.critical("config.yaml not found at %s", config_path)
                            safe_exit()
                
                        self.cfg.merge_from_file(ROOT / "config.yaml")
                        self.window = Window()
                
                    def _on_release(self, key: keyboard.KeyCode) -> None:
                        """Monitor user's keystrokes and convert a key press to a CTRL_C_EVENT.
                
                        :param key: The key that was released.
                        :type key: keyboard.KeyCode
                
                        Exits the application when the configured quit key is pressed.
                        """
                        # Trigger CTRL_C_EVENT, which will be caught in start() to simulate pressing
                        # CTRL-C to terminate the script.
                        if key == keyboard.KeyCode.from_char(self.cfg.KEY.QUIT):
                            os.kill(os.getpid(), signal.CTRL_C_EVENT)
                            sys.exit()
                
                    @abstractmethod
                    def _start(self):
                        raise NotImplementedError("_start() must be implemented in subclass")
                
                    @abstractmethod
                    def start(self):
                        raise NotImplementedError("start() must be implemented in subclass")
                
                    @abstractmethod
                    def create_parser(self):
                        raise NotImplementedError("create_parser() must be implemented in subclass")
                
                    @abstractmethod
                    def display_result(self) -> None:
                        raise NotImplementedError("display_result() must be implemented in subclass")
                
                
                class ToolApp(App):
                    """General application class for other tools.
                
                    Attributes:
                        detection (Detection): Detection controller
                    """
                
                    def __init__(self):
                        """Set up an immutable cfg node for further modification.
                
                        1. Parse command-line arguments and merge them with the existing cfg node.
                        2. Create a Window instance and a Detection instance.
                        3. Create an empty dictionary for result
                        """
                        super().__init__()
                        args = self.create_parser().parse_args()
                        args_cfg = CN({"ARGS": config.dict_to_cfg(vars(args))})
                        self.cfg.merge_from_other_cfg(args_cfg)
                        self.cfg.merge_from_list(args.opts)
                
                        # Dummy node
                        dummy = CN({"SELECTED": config.dict_to_cfg({"MODE": "spin"})})
                        self.cfg.merge_from_other_cfg(dummy)
                        self.cfg.freeze()
                
                        self.detection = Detection(self.cfg, self.window)
                        self.result = Result()  # This will be used in display_result()
                
                    def display_result(self) -> None:
                        """Display the running result in a table format."""
                        result_dict = self.result.as_dict()
                        if not result_dict:
                            return
                
                        table = Table("Result", title="Running Result", show_header=False)
                        for name, value in self.result.as_dict().items():
                            table.add_row(name, str(value))
                        print(table)
                
                    def start(self) -> None:
                        """Wrapper method that handle window activation and result display."""
                        if self.cfg.KEY.QUIT != "CTRL-C":
                            listener = keyboard.Listener(on_release=self._on_release)
                            listener.start()
                
                        self.window.activate_game_window()
                        try:
                            self._start()
                        except KeyboardInterrupt:
                            pass
                        self.display_result()
                        self.window.activate_script_window()
            üìÅ __pycache__/
                üìÑ app.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ component/
            üìÑ friction_brake.py
                """Module for friction brake related methods.
                
                This module provides functionality for managing the friction brake in Russian Fishing 4,
                including resetting, adjusting, and monitoring the friction brake.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                from multiprocessing import Process, Value
                from time import sleep, time
                
                import pyautogui as pag
                
                from rf4s.controller.detection import Detection
                
                MAX_FRICTION_BRAKE = 30
                MIN_FRICTION_BRAKE = 0
                UP = 1
                DOWN = -1
                FRICTION_BRAKE_MONITOR_DELAY = 2
                LOOP_DELAY = 0.04
                
                logger = logging.getLogger("rich")
                
                
                class FrictionBrake:
                    """Friction brake controller.
                
                    This class handles the adjustment and monitoring of the friction brake during gameplay.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for friction brake settings.
                        detection (Detection): Detection instance for in-game state checks.
                        cur (Value): Current value of the friction brake.
                        lock (Lock): Lock for thread synchronization.
                        monitor_process (Process): Process for monitoring the friction brake.
                    """
                
                    def __init__(self, cfg, lock, detection: Detection) -> None:
                        """Initialize the FrictionBrake class with configuration, lock, and detection.
                
                        :param cfg: Configuration node for friction brake settings.
                        :type cfg: CfgNode
                        :param lock: Lock for thread synchronization.
                        :type lock: Lock
                        :param detection: Detection instance for in-game state checks.
                        :type detection: Detection
                        """
                        self.cfg = cfg
                        self.lock = lock
                        self.detection = detection
                        self.cur = Value("i", cfg.FRICTION_BRAKE.INITIAL)
                        self.monitor_process = Process(target=monitor_friction_brake, args=(self,))
                
                    def reset(self, target: int) -> None:
                        """Reset the friction brake to the target value.
                
                        :param target: Target friction brake value.
                        :type target: int
                        """
                        logger.info("Resetting friction brake")
                        for _ in range(MAX_FRICTION_BRAKE):
                            pag.scroll(UP)
                
                        diff = MAX_FRICTION_BRAKE - target
                        for _ in range(abs(diff)):
                            pag.scroll(DOWN)
                        self.cur.value = target
                
                    def change(self, increase: bool) -> None:
                        """Increase or decrease the friction brake.
                
                        :param increase: Whether to increase the friction brake.
                        :type increase: bool
                        """
                        if increase:
                            if self.cur.value < self.cfg.FRICTION_BRAKE.MAX:
                                pag.scroll(UP, _pause=False)
                                self.cur.value = min(self.cur.value + 1, MAX_FRICTION_BRAKE)
                        else:
                            if self.cur.value > 0:
                                pag.scroll(DOWN, _pause=False)
                                self.cur.value = max(self.cur.value - 1, MIN_FRICTION_BRAKE)
                        sleep(LOOP_DELAY)
                
                
                def monitor_friction_brake(friction_brake: FrictionBrake) -> None:
                    """Monitor friction brake bar and change it accordingly.
                
                    This is used as the target function in multiprocess.Process and must be pickable,
                    thus it must be declared as a global function instead of an instance method.
                
                    :param friction_brake: Friction brake controller.
                    :type friction_brake: FrictionBrake
                    """
                    logger.info("Monitoring friction brake")
                
                    pre_time = time()
                    fish_hooked = False
                
                    try:
                        while True:
                            if not friction_brake.detection.is_fish_hooked_pixel():
                                sleep(FRICTION_BRAKE_MONITOR_DELAY)
                                fish_hooked = False
                                continue
                            if not fish_hooked:
                                sleep(friction_brake.cfg.FRICTION_BRAKE.START_DELAY)
                                fish_hooked = True
                            with friction_brake.lock:
                                if friction_brake.detection.is_friction_brake_high():
                                    friction_brake.change(increase=False)
                                if friction_brake.detection.is_reel_burning():
                                    logger.info("Reel burning detected, decreasing friction brake")
                                    friction_brake.change(increase=False)
                                else:
                                    cur_time = time()
                                    if (
                                        cur_time - pre_time
                                        < friction_brake.cfg.FRICTION_BRAKE.INCREASE_DELAY
                                    ):
                                        continue
                                    pre_time = cur_time
                                    friction_brake.change(increase=True)
                    except KeyboardInterrupt:
                        pass
            üìÑ tackle.py
                """Module for Tackle class and some decorators.
                
                This module provides functionality for managing tackle-related actions in Russian Fishing 4,
                such as casting, retrieving, and pulling fish. It also includes decorators for handling
                common tasks like clicklock and key releases.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                import random
                from time import sleep
                from typing import Literal
                
                import pyautogui as pag
                import win32api
                import win32con
                from pyscreeze import Box
                
                from rf4s import exceptions, utils
                from rf4s.controller.detection import Detection
                from rf4s.controller.timer import Timer
                
                logger = logging.getLogger("rich")
                
                RESET_TIMEOUT = 16
                CAST_SCALE = 0.4  # 25% / 0.4s
                
                # BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
                BASE_DELAY = 1.2
                LOOP_DELAY = 1
                
                ANIMATION_DELAY = 1
                
                RETRIEVAL_TIMEOUT = 32
                PULL_TIMEOUT = 16
                RETRIEVAL_WITH_PAUSE_TIMEOUT = 128
                LIFT_DURATION = 3
                TELESCOPIC_PULL_TIMEOUT = 8
                LANDING_NET_DURATION = 6
                LANDING_NET_DELAY = 0.5
                SINK_DELAY = 2
                
                
                OFFSET = 100
                NUM_OF_MOVEMENT = 4
                
                
                class Tackle:
                    """Class for all tackle-dependent methods.
                
                    This class handles actions related to the fishing tackle, such as casting,
                    retrieving, and pulling fish. It also manages tackle resetting and gear ratio switching.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for tackle settings.
                        timer (Timer): Timer instance for timing actions.
                        detection (Detection): Detection instance for in-game state checks.
                        landing_net_out (bool): Whether the landing net is deployed.
                        available (bool): Whether the tackle is available for use.
                    """
                
                    def __init__(self, cfg, timer: Timer, detection: Detection):
                        """Initialize the Tackle class with configuration, timer, and detection.
                
                        :param cfg: Configuration node for tackle settings.
                        :type cfg: CfgNode
                        :param timer: Timer instance for timing actions.
                        :type timer: Timer
                        :param detection: Detection instance for in-game state checks.
                        :type detection: Detection
                        """
                        self.cfg = cfg
                        self.timer = timer
                        self.detection = detection
                        self.landing_net_out = False  # For telescopic pull
                        self.available = True
                
                    @staticmethod
                    def _check_status(func):
                        def wrapper(self, *args, **kwargs):
                            if not self.available:
                                return
                            try:
                                func(self, *args)
                            except Exception as e:
                                raise e
                
                        return wrapper
                
                    def is_disconnected_or_ticketed_expired(self) -> None:
                        """Check if the game disconnected or the boat ticket expired."""
                        if self.detection.is_disconnected():
                            raise exceptions.DisconnectedError
                        if self.detection.is_ticket_expired():
                            raise exceptions.TicketExpiredError
                
                    @_check_status
                    def reset(self) -> None:
                        """Reset the tackle until ready and detect unexpected events.
                
                        :raises exceptions.FishHookedError: A fish is hooked.
                        :raises exceptions.FishCapturedError: A fish is captured.
                        :raises exceptions.LineAtEndError: The line is at its end.
                        :raises exceptions.LineSnaggedError: The line is snagged.
                        :raises TimeoutError: The loop timed out.
                        """
                        logger.info("Resetting tackle")
                        i = RESET_TIMEOUT
                        while i > 0:
                            if self.detection.is_tackle_ready():
                                return
                            if self.detection.is_fish_hooked():
                                raise exceptions.FishHookedError
                            if self.detection.is_fish_captured():
                                raise exceptions.FishCapturedError
                            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                                raise exceptions.LineAtEndError
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                            if self.detection.is_lure_broken():
                                raise exceptions.LureBrokenError
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @_check_status
                    def cast(self, lock: bool) -> None:
                        """Cast the rod, then wait for the lure/bait to fly and sink.
                
                        :param lock: Whether to lock the reel after casting.
                        :type lock: bool
                        """
                        logger.info("Casting rod")
                        if self.cfg.ARGS.MOUSE:
                            self.move_mouse_randomly()
                        match self.cfg.SELECTED.CAST_POWER_LEVEL:
                            case 1:  # 0%
                                pag.click()
                            case 5:  # power cast
                                with pag.hold("shift"):
                                    utils.hold_mouse_button(1)
                            case _:
                                # -1 for backward compatibility
                                duration = CAST_SCALE * (self.cfg.SELECTED.CAST_POWER_LEVEL - 1)
                                utils.hold_mouse_button(duration)
                
                        sleep(self.cfg.SELECTED.CAST_DELAY)
                        if lock:
                            pag.click()
                
                    def sink(self) -> None:
                        """Sink the lure until an event happens, designed for marine and wakey rig."""
                        logger.info("Sinking lure")
                        i = self.cfg.SELECTED.SINK_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_moving_in_bottom_layer():
                                logger.info("Lure has reached bottom layer")
                                sleep(SINK_DELAY)
                                break
                
                            if self.detection.is_fish_hooked_twice():
                                pag.click()  # Lock reel
                                return
                
                        utils.hold_mouse_button(self.cfg.SELECTED.TIGHTEN_DURATION)
                
                    @_check_status
                    @utils.release_keys_after()
                    def retrieve(self, first: bool = True) -> None:
                        """Retrieve the line until the end is reached and detect unexpected events.
                
                        :param first: Whether it's invoked for the first time, defaults to True.
                        :type first: bool, optional
                
                        :raises exceptions.FishCapturedError: A fish is captured.
                        :raises exceptions.LineAtEndError: The line is at its end.
                        :raises exceptions.LineSnaggedError: The line is snagged.
                        :raises TimeoutError: The loop timed out.
                        """
                        logger.info("Retrieving fishing line")
                
                        i = RETRIEVAL_TIMEOUT
                        while i > 0:
                            if self.detection.is_fish_hooked():
                                if self.cfg.SELECTED.POST_ACCELERATION == "on":
                                    pag.keyDown("shift")
                                elif self.cfg.SELECTED.POST_ACCELERATION == "auto" and first:
                                    pag.keyDown("shift")
                
                                if self.cfg.ARGS.LIFT:
                                    utils.hold_mouse_button(LIFT_DURATION, button="right")
                
                            if self.detection.is_retrieval_finished():
                                sleep(0 if self.cfg.ARGS.RAINBOW else 2)
                                return
                
                            if self.detection.is_fish_captured():
                                raise exceptions.FishCapturedError
                            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                                raise exceptions.LineAtEndError
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @utils.release_keys_after()
                    def _special_retrieve(self, button: str) -> None:
                        """Retrieve the line with special conditions (pause or lift).
                
                        :param button: The mouse button to use for retrieval.
                        :type button: str
                        """
                        if self.cfg.SELECTED.PRE_ACCELERATION:
                            pag.keyDown("shift")
                        i = RETRIEVAL_WITH_PAUSE_TIMEOUT
                        while i > 0:
                            utils.hold_mouse_button(self.cfg.SELECTED.RETRIEVAL_DURATION, button)
                            i -= self.cfg.SELECTED.RETRIEVAL_DURATION
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.RETRIEVAL_DELAY)
                            if (
                                self.detection.is_fish_hooked()
                                or self.detection.is_retrieval_finished()
                            ):
                                return
                
                    @utils.release_keys_after()
                    def pirk(self) -> None:
                        """Start pirking until a fish is hooked.
                
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        logger.info("Pirking")
                
                        i = self.cfg.SELECTED.PIRK_TIMEOUT
                        while i > 0:
                            if self.detection.is_tackle_ready():
                                return
                
                            if self.detection.is_fish_hooked_twice():
                                pag.click()
                                return
                
                            if self.cfg.SELECTED.PIRK_DURATION > 0:
                                if self.cfg.SELECTED.CTRL:
                                    pag.keyDown("ctrl")
                                if self.cfg.SELECTED.SHIFT:
                                    pag.keyDown("shift")
                                utils.hold_mouse_button(self.cfg.SELECTED.PIRK_DURATION, button="right")
                                i -= self.cfg.SELECTED.PIRK_DURATION
                                i = utils.sleep_and_decrease(i, self.cfg.SELECTED.PIRK_DELAY)
                            else:
                                i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def elevate(self, dropped: bool) -> None:
                        """Perform elevator tactic (drop/rise) until a fish is hooked.
                
                        :param dropped: Whether the lure is dropped.
                        :type dropped: bool
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        locked = True  # Reel is locked after tackle.sink()
                        i = self.cfg.SELECTED.ELEVATE_TIMEOUT
                        while i > 0:
                            if self.detection.is_fish_hooked_twice():
                                pag.click()
                                return
                
                            if self.cfg.SELECTED.DROP and not dropped:
                                pag.press("enter")
                                if locked:
                                    delay = self.cfg.SELECTED.ELEVATE_DELAY
                                else:
                                    delay = self.cfg.SELECTED.ELEVATE_DURATION
                                i = utils.sleep_and_decrease(i, delay)
                            else:
                                if locked:
                                    i = utils.sleep_and_decrease(i, self.cfg.SELECTED.ELEVATE_DELAY)
                                else:
                                    utils.hold_mouse_button(self.cfg.SELECTED.ELEVATE_DURATION)
                                    i -= self.cfg.SELECTED.ELEVATE_DURATION
                            locked = not locked
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @_check_status
                    def pull(self) -> None:
                        """Pull the fish until it's captured."""
                        logger.info("Pulling fish")
                        if self.cfg.SELECTED.MODE == "telescopic":
                            self._telescopic_pull()
                        else:
                            self._pull()
                
                    @utils.toggle_right_mouse_button
                    def _pull(self) -> None:
                        """Pull the fish until it's captured."""
                        i = PULL_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_fish_captured():
                                return
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                
                        if not self.detection.is_fish_hooked():
                            return
                        if self.detection.is_retrieval_finished():
                            pag.press("space")
                            sleep(LANDING_NET_DURATION)
                            if self.detection.is_fish_captured():
                                return
                            pag.press("space")
                            sleep(LANDING_NET_DELAY)
                        if self.detection.is_tackle_broken():
                            raise exceptions.TackleBrokenError
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def _telescopic_pull(self) -> None:
                        """Pull the fish until it's captured, designed for telescopic rod.
                
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        # Check false postive first because it happens often
                        if not self.detection.is_fish_hooked():
                            return
                
                        # Toggle landing net when pull() is called for the first time
                        if not self.landing_net_out:
                            pag.press("space")
                            self.landing_net_out = True
                        i = TELESCOPIC_PULL_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_fish_captured():
                                self.landing_net_out = False
                                return
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def switch_gear_ratio(self) -> None:
                        """Switch the gear ratio of a conventional reel."""
                        logger.info("Switching gear ratio")
                        with pag.hold("ctrl"):
                            pag.press("space")
                
                    def move_mouse_randomly(self) -> None:
                        """Randomly move the mouse for four times."""
                        logger.info("Moving mouse randomly")
                        coords = []
                        for _ in range(NUM_OF_MOVEMENT - 1):
                            x, y = random.randint(-OFFSET, OFFSET), random.randint(-OFFSET, OFFSET)
                            coords.append((x, y))
                        coords.append((-sum(x for x, _ in coords), -sum(y for _, y in coords)))
                        for x, y in coords:
                            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, x, y, 0, 0)
                            sleep(ANIMATION_DELAY)
                
                    def equip_item(self, item) -> None:
                        """Equip an item from the menu or inventory.
                
                        :param item: The item to equip (e.g., lure, pva, dry_mix, groundbait).
                        :type item: str
                        """
                        if item == "lure":
                            self._equip_item_from_menu(item)
                        self._equip_item_from_inventory(item)  # groundbait, dry_mix, pva
                
                    def _equip_item_from_menu(self, item: str) -> None:
                        """Equip an item from the menu.
                
                        :param item: The item to equip (e.g., lure).
                        :type item: str
                        """
                        logger.info("Equiping new %s from menu", item)
                        with pag.hold("b"):
                            self._equip_favorite_item(item)
                        sleep(ANIMATION_DELAY)
                
                    @utils.press_before_and_after("v")
                    def _equip_item_from_inventory(
                        self, item: Literal["dry_mix", "groundbait"]
                    ) -> None:
                        """Equip an item from the inventory.
                
                        :param item: The item to equip (e.g., dry_mix, groundbait).
                        :type item: Literal["dry_mix", "groundbait"]
                        """
                        logger.info("Equiping new %s from inventory", item)
                        scrollbar_position = self.detection.get_scrollbar_position()
                        if scrollbar_position is None:
                            pag.click(utils.get_box_center(self.get_item_position(item)))
                            self._equip_favorite_item(item)
                            return
                
                        pag.moveTo(scrollbar_position)
                        for _ in range(5):
                            sleep(ANIMATION_DELAY)
                            pag.drag(xOffset=0, yOffset=125, duration=0.5, button="left")
                            position = self.get_item_position(item)
                            if position is not None:
                                pag.click(utils.get_box_center(position))
                                self._equip_favorite_item(item)
                                break
                
                    def get_item_position(self, item: str) -> Box | None:
                        """Get the position of an item.
                        :param item: The item to get the position for (e.g., pva, dry_mix, groundbait)
                        :type item: str
                        :return: position of the item
                        :rtype: Box | None
                        """
                        if item == "groundbait":
                            return self.detection.get_groundbait_position()
                        elif item == "dry_mix":
                            return self.detection.get_dry_mix_position()
                        else:  # pva
                            return self.detection.get_pva_position()
                
                    def _equip_favorite_item(self, item: bool):
                        """Select a favorite item for replacement and replace the broken one.
                
                        :param item: The item to equip (e.g., lure, pva, dry_mix, groundbait).
                        :type item: str
                        :raises exceptions.ItemNotFoundError: The item was not found.
                        """
                        sleep(ANIMATION_DELAY)
                        logger.info("Looking for favorite items")
                        favorite_item_positions = list(self.detection.get_favorite_item_positions())
                        if item == "lure":
                            random.shuffle(favorite_item_positions)
                
                        for favorite_item_position in favorite_item_positions:
                            x, y = utils.get_box_center(favorite_item_position)
                            if item == "lure" and pag.pixel(x - 70, y + 190) == (178, 59, 30):
                                continue
                            pag.click(x - 70, y + 190, clicks=2, interval=0.1)
                            logger.info("New %s equiped successfully", item)
                            return
                
                        # Close selection window when equiping from inventory
                        if item in ("dry_mix", "groundbait"):
                            pag.press("esc")
                        raise exceptions.ItemNotFoundError
                
                    def _monitor_float_state(self) -> None:
                        """Monitor the state of the float."""
                        logger.info("Monitoring float state")
                        reference_img = pag.screenshot(region=self.detection.float_camera_rect)
                        i = self.cfg.SELECTED.DRIFT_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.CHECK_DELAY)
                            if self.detection.is_float_state_changed(reference_img):
                                logger.info("Float status changed")
                                return
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def _monitor_clip_state(self) -> None:
                        """Monitor the state of the bolognese clip."""
                        i = self.cfg.SELECTED.DRIFT_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.CHECK_DELAY)
                            if self.detection.is_clip_open():
                                logger.info("Clip status changed")
                                return
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
            üìÅ __pycache__/
                üìÑ friction_brake.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ tackle.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ config/
            üìÑ config.py
                """
                Configuration module for managing and manipulating configuration settings.
                
                This module provides utilities for setting up, converting, and printing
                configuration nodes using the YACS library.
                """
                
                from yacs.config import CfgNode as CN
                
                from rf4s.config.defaults import get_cfg_defaults
                
                
                def setup_cfg() -> CN:
                    """
                    Set up and return a default configuration node.
                
                    This function initializes a default configuration node and allows new keys
                    to be added to the configuration.
                
                    :return: A cloned configuration node with default settings.
                    :rtype: CN
                    """
                    cfg = get_cfg_defaults()
                    cfg.set_new_allowed(True)
                    return cfg.clone()
                
                
                def dict_to_cfg(args: dict) -> CN:
                    """
                    Convert a dictionary to a configuration node.
                
                    This function recursively converts a dictionary into a configuration node,
                    allowing nested dictionaries to be converted into nested configuration nodes.
                
                    :param args: Dictionary to be converted into a configuration node.
                    :type args: dict
                    :return: Configuration node created from the dictionary.
                    :rtype: CN
                    """
                    cfg = CN()
                    for k, v in args.items():
                        k = k.upper()
                        if isinstance(v, dict):
                            cfg[k] = dict_to_cfg(v)
                        else:
                            cfg[k] = v
                    return cfg
                
                
                def print_cfg(cfg: CN, level: int = 0) -> None:
                    """
                    Print the configuration node in a readable format.
                
                    This function recursively prints the configuration node, with indentation
                    to represent nested levels.
                
                    :param cfg: Configuration node to be printed.
                    :type cfg: CN
                    :param level: Current indentation level (used for recursion).
                    :type level: int
                    """
                    cfg = dict(cfg)
                    indent = "  " * level if level > 0 else ""
                    for k, v in cfg.items():
                        if isinstance(v, CN):
                            print(f"{indent}{k}:")
                            print_cfg(v, level + 1)
                        else:
                            print(f"{indent}{k}: {v}")
                
                
                def to_list(profile: dict) -> list:
                    """
                    Convert a dictionary into a flat list of key-value pairs.
                
                    This function flattens a dictionary into a list where keys and values
                    are alternated.
                
                    :param profile: Dictionary to be converted into a list.
                    :type profile: dict
                    :return: List containing alternating keys and values from the dictionary.
                    :rtype: list
                    """
                    pairs = []
                    for k, v in profile.items():
                        pairs.extend([k, v])
                    return pairs
            üìÑ config.yaml
                VERSION: "0.5.2"
                
                SCRIPT:
                  LANGUAGE: "en"
                  LAUNCH_OPTIONS: ""
                  SMTP_VERIFICATION: true
                  IMAGE_VERIFICATION: true
                  SNAG_DETECTION: true
                  SPOOLING_DETECTION: true
                  RANDOM_ROD_SELECTION: true
                  SPOOL_CONFIDENCE: 0.98
                  SPOD_ROD_RECAST_DELAY: 1800
                  LURE_CHANGE_DELAY: 1800
                  ALARM_SOUND: "./static/sound/guitar.wav"
                  RANDOM_CAST_PROBABILITY: 0.25
                  SCREENSHOT_TAGS:
                    - "green"
                    - "yellow"
                    - "blue"
                    - "purple"
                    - "pink"
                
                KEY:
                  TEA: -1
                  CARROT: -1
                  BOTTOM_RODS: [1, 2, 3]
                  COFFEE: 4
                  DIGGING_TOOL: 5
                  ALCOHOL: 6
                  MAIN_ROD: 1
                  SPOD_ROD: 7
                  QUIT: "CTRL-C"
                
                STAT:
                  ENERGY_THRESHOLD: 0.74
                  HUNGER_THRESHOLD: 0.5
                  COMFORT_THRESHOLD: 0.51
                  TEA_DELAY: 300
                  COFFEE_LIMIT: 10
                  COFFEE_PER_DRINK: 1
                  ALCOHOL_DELAY: 900
                  ALCOHOL_PER_DRINK: 1
                
                FRICTION_BRAKE:
                  INITIAL: 29
                  MAX: 30
                  START_DELAY: 2.0
                  INCREASE_DELAY: 1.0
                  SENSITIVITY: "medium"
                
                KEEPNET:
                  CAPACITY: 100
                  FISH_DELAY: 0.0
                  GIFT_DELAY: 4.0
                  FULL_ACTION: "quit"
                  WHITELIST:
                    - "mackerel"
                    - "saithe"
                    - "herring"
                    - "squid"
                    - "scallop"
                    - "mussel"
                  BLACKLIST: []
                  TAGS:
                    - "green"
                    - "yellow"
                    - "blue"
                    - "purple"
                    - "pink"
                
                NOTIFICATION:
                  EMAIL: "email@example.com"
                  PASSWORD: "password"
                  SMTP_SERVER: "smtp.gmail.com"
                  MIAO_CODE: "example"
                  DISCORD_WEBHOOK_URL: ""
                
                PAUSE:
                  DELAY: 1800
                  DURATION: 600
                
                PROFILE:
                  SPIN:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 0.0
                    RETRIEVAL_DURATION: 0.0
                    RETRIEVAL_DELAY: 0.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "normal"
                  SPIN_WITH_PAUSE:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 1.0
                    RETRIEVAL_DURATION: 1.0
                    RETRIEVAL_DELAY: 3.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "pause"
                  SPIN_WITH_LIFT:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 0.0
                    RETRIEVAL_DURATION: 1.0
                    RETRIEVAL_DELAY: 1.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "lift"
                  BOTTOM:
                    MODE: "bottom"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    POST_ACCELERATION: "off"
                    CHECK_DELAY: 32.0
                    CHECK_MISS_LIMIT: 16
                    PUT_DOWN_DELAY: 0.0
                  PIRK:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 4.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: false
                    SHIFT: false
                    PIRK_DURATION: 0.5
                    PIRK_DELAY: 2.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  PIRK_WITH_RETRIEVAL:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 0.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: false
                    SHIFT: false
                    PIRK_DURATION: 0.5
                    PIRK_DELAY: 2.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: true
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  WAKEY_RIG:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 45.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 4.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: true
                    SHIFT: false
                    PIRK_DURATION: 1.5
                    PIRK_DELAY: 4.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  ELEVATOR:
                    MODE: "elevator"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    ELEVATE_DURATION: 4.0
                    ELEVATE_DELAY: 4.0
                    ELEVATE_TIMEOUT: 40.0
                    DROP: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  ELEVATOR_WITH_DROP:
                    MODE: "elevator"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    ELEVATE_DURATION: 4.0
                    ELEVATE_DELAY: 4.0
                    ELEVATE_TIMEOUT: 40.0
                    DROP: true
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  TELESCOPIC:
                    MODE: "telescopic"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    FLOAT_SENSITIVITY: 0.68
                    CHECK_DELAY: 1.0
                    PULL_DELAY: 0.5
                    DRIFT_TIMEOUT: 16.0
                    CAMERA_SHAPE: "square"
                  BOLOGNESE:
                    MODE: "bolognese"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    FLOAT_SENSITIVITY: 0.68
                    CHECK_DELAY: 1.0
                    PULL_DELAY: 0.5
                    DRIFT_TIMEOUT: 32.0
                    CAMERA_SHAPE: "square"
                    POST_ACCELERATION: "off"
            üìÑ defaults.py
                """Default yacs config node."""
                
                from yacs.config import CfgNode as CN
                
                _C = CN()
                _C.VERSION = "0.5.2"
                
                # ---------------------------------------------------------------------------- #
                #                                    General                                   #
                # ---------------------------------------------------------------------------- #
                _C.SCRIPT = CN()
                _C.SCRIPT.LANGUAGE = "en"  # Language for the script. Options: en, ru, zh-TW, zh-CN
                _C.SCRIPT.LAUNCH_OPTIONS = ""  # Default launch options for the script, e.g., -r -c -H
                _C.SCRIPT.SMTP_VERIFICATION = True
                _C.SCRIPT.IMAGE_VERIFICATION = True
                _C.SCRIPT.SNAG_DETECTION = True
                _C.SCRIPT.SPOOLING_DETECTION = True
                _C.SCRIPT.RANDOM_ROD_SELECTION = True  # For bottom mode
                # Confidence threshold for spooling detection (lower = more sensitive)
                _C.SCRIPT.SPOOL_CONFIDENCE = 0.98
                # Delay before recasting spod rod (in seconds)
                # Use bottom mode and -o to enable it.
                _C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800
                # Delay before changing lure randomly (in seconds)
                # Use spin mode and -L to enable it.
                _C.SCRIPT.LURE_CHANGE_DELAY = 1800
                _C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # Path to alarm sound file
                # Probability to add a redundant rod cast (0.0 to 1.0)
                _C.SCRIPT.RANDOM_CAST_PROBABILITY = 0.25
                # When using -s flag, only take screenshot of the fishes with tags below
                # If left empty, the script will take screenshot of every fish you caught
                _C.SCRIPT.SCREENSHOT_TAGS = ("green", "yellow", "blue", "purple", "pink")
                
                # ---------------------------------------------------------------------------- #
                #                                  Key Binding                                 #
                # ---------------------------------------------------------------------------- #
                _C.KEY = CN()
                _C.KEY.TEA = -1  # Key binding for tea. Set to -1 to use quick selection menu
                _C.KEY.CARROT = -1  # Key binding for carrot. Set to -1 to use quick selection menu
                _C.KEY.BOTTOM_RODS = (1, 2, 3)  # Key bindings for bottom rods
                _C.KEY.COFFEE = 4  # Key binding for coffee. Set to -1 to use quick selection menu
                _C.KEY.DIGGING_TOOL = 5  # Key binding for digging tool
                _C.KEY.ALCOHOL = 6  # Key binding for alcohol
                # Key binding for the main rod (used when harvesting baits with one rod)
                _C.KEY.MAIN_ROD = 1
                _C.KEY.SPOD_ROD = 7  # Key binding for the spod rod (used in bottom mode)
                # Key binding to stop the script (default is Ctrl-C)
                # If you want to use a special quitting shortcut, please refer to pynput's docs:
                # https://pynput.readthedocs.io/en/latest/keyboard.html#pynput.keyboard.Key .
                _C.KEY.QUIT = "CTRL-C"
                
                # ---------------------------------------------------------------------------- #
                #                                 Player Stats                                 #
                # ---------------------------------------------------------------------------- #
                _C.STAT = CN()
                # Minimum energy level before drinking coffee/harvesting baits
                _C.STAT.ENERGY_THRESHOLD = 0.74
                _C.STAT.HUNGER_THRESHOLD = 0.5  # Minimum hunger level before consuming carrot
                _C.STAT.COMFORT_THRESHOLD = 0.51  # Minimum comfort level before consuming tea
                _C.STAT.TEA_DELAY = 300  # Delay between tea drinks (in seconds)
                _C.STAT.COFFEE_LIMIT = 10  # Maximum coffee drinks per fish fight.
                _C.STAT.COFFEE_PER_DRINK = 1  # Amount of coffee consumed per drink
                _C.STAT.ALCOHOL_DELAY = 900  # Delay between alcohol drinks (in seconds)
                _C.STAT.ALCOHOL_PER_DRINK = 1  # Amount of alcohol consumed per drink
                
                # ---------------------------------------------------------------------------- #
                #                   Friction Brake (Use -f flag to enable it)                  #
                # ---------------------------------------------------------------------------- #
                _C.FRICTION_BRAKE = CN()
                _C.FRICTION_BRAKE.INITIAL = 29  # Initial friction brake value
                _C.FRICTION_BRAKE.MAX = 30  # Maximum friction brake value
                # Delay before starting to adjust friction brake after a fish is hooked
                _C.FRICTION_BRAKE.START_DELAY = 2.0
                _C.FRICTION_BRAKE.INCREASE_DELAY = 1.0  # Delay before increasing friction brake
                _C.FRICTION_BRAKE.SENSITIVITY = "medium"  # Sensitivity of friction brake detection
                
                # ---------------------------------------------------------------------------- #
                #                                    Keepnet                                   #
                # ---------------------------------------------------------------------------- #
                _C.KEEPNET = CN()
                _C.KEEPNET.CAPACITY = 100
                _C.KEEPNET.FISH_DELAY = 0.0  # Delay before keeping the fish (for screenshots)
                _C.KEEPNET.GIFT_DELAY = 4.0  # Delay before keeping the gift (for screenshots)
                _C.KEEPNET.FULL_ACTION = "quit"  # Action when keepnet is full. Options: quit, alarm
                # Whitelist for untagged fish releasing when using -t flag
                # Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
                _C.KEEPNET.WHITELIST = (
                    "mackerel",
                    "saithe",
                    "herring",
                    "squid",
                    "scallop",
                    "mussel",
                )
                # Fish in the blacklist will always be released
                # Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
                _C.KEEPNET.BLACKLIST = ()
                # When using -t flag, only the fish with tags below would be kept
                _C.KEEPNET.TAGS = ("green", "yellow", "blue", "purple", "pink")
                
                
                # ---------------------------------------------------------------------------- #
                #                                 Notification                                 #
                # ---------------------------------------------------------------------------- #
                _C.NOTIFICATION = CN()
                _C.NOTIFICATION.EMAIL = "email@example.com"
                _C.NOTIFICATION.PASSWORD = "password"
                _C.NOTIFICATION.SMTP_SERVER = "smtp.gmail.com"
                _C.NOTIFICATION.MIAO_CODE = "example"
                _C.NOTIFICATION.DISCORD_WEBHOOK_URL = ""
                
                # ---------------------------------------------------------------------------- #
                #                       Pause ( use -X flag to enable it)                      #
                # ---------------------------------------------------------------------------- #
                _C.PAUSE = CN()
                _C.PAUSE.DELAY = 1800  # Delay between pauses (in seconds)
                _C.PAUSE.DURATION = 600  # Duration of pause (in seconds)
                
                _C.PROFILE = CN()
                # ---------------------------------------------------------------------------- #
                #                             Spin Fishing Profile                             #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.SPIN = CN()
                _C.PROFILE.SPIN.MODE = "spin"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.SPIN.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.SPIN.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.SPIN.CAST_DELAY = 6.0
                # Duration to tighten the fishing line after casting
                _C.PROFILE.SPIN.TIGHTEN_DURATION = 0.0
                # Duration of retrieving the line or lifting the rod (right mosue button)
                _C.PROFILE.SPIN.RETRIEVAL_DURATION = 0.0
                # Delay after retrieving the line or lifting the rod (right mosue button)
                _C.PROFILE.SPIN.RETRIEVAL_DELAY = 0.0
                # Timeout for retrieving with pause/lift, followed by the normal retrieval
                _C.PROFILE.SPIN.RETRIEVAL_TIMEOUT = 256.0
                # Hold down the Shift key when performing special spin fishing techniques
                _C.PROFILE.SPIN.PRE_ACCELERATION = False
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.SPIN.POST_ACCELERATION = "off"
                # Type of special spin fishing technique to perform. Options: normal, pause, lift
                _C.PROFILE.SPIN.TYPE = "normal"
                
                _C.PROFILE.SPIN_WITH_PAUSE = CN()
                _C.PROFILE.SPIN_WITH_PAUSE.MODE = "spin"
                _C.PROFILE.SPIN_WITH_PAUSE.LAUNCH_OPTIONS = ""
                _C.PROFILE.SPIN_WITH_PAUSE.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.SPIN_WITH_PAUSE.CAST_DELAY = 6.0
                _C.PROFILE.SPIN_WITH_PAUSE.TIGHTEN_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DELAY = 3.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_TIMEOUT = 256.0
                _C.PROFILE.SPIN_WITH_PAUSE.PRE_ACCELERATION = False
                _C.PROFILE.SPIN_WITH_PAUSE.POST_ACCELERATION = "off"
                _C.PROFILE.SPIN_WITH_PAUSE.TYPE = "pause"
                
                
                _C.PROFILE.SPIN_WITH_LIFT = CN()
                _C.PROFILE.SPIN_WITH_LIFT.MODE = "spin"
                _C.PROFILE.SPIN_WITH_LIFT.LAUNCH_OPTIONS = ""
                _C.PROFILE.SPIN_WITH_LIFT.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.SPIN_WITH_LIFT.CAST_DELAY = 6.0
                _C.PROFILE.SPIN_WITH_LIFT.TIGHTEN_DURATION = 0.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DELAY = 1.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_TIMEOUT = 256.0
                _C.PROFILE.SPIN_WITH_LIFT.PRE_ACCELERATION = False
                _C.PROFILE.SPIN_WITH_LIFT.POST_ACCELERATION = "off"
                _C.PROFILE.SPIN_WITH_LIFT.TYPE = "lift"
                
                
                # ---------------------------------------------------------------------------- #
                #                            Bottom Fishing Profile                            #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.BOTTOM = CN()
                _C.PROFILE.BOTTOM.MODE = "bottom"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.BOTTOM.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.BOTTOM.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.BOTTOM.CAST_DELAY = 4.0  # Delay after casting before lure sinks
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.BOTTOM.POST_ACCELERATION = "off"
                # Delay before checking fish bite on next rod
                _C.PROFILE.BOTTOM.CHECK_DELAY = 32.0
                # Maximum allowed misses before recasting the rod
                _C.PROFILE.BOTTOM.CHECK_MISS_LIMIT = 16
                # Delay before checking if a fish is hooked again and putting down the rod
                _C.PROFILE.BOTTOM.PUT_DOWN_DELAY = 0.0
                
                
                # ---------------------------------------------------------------------------- #
                #                      Marine / Wakey Rig Pirking Profile                      #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.PIRK = CN()
                _C.PROFILE.PIRK.MODE = "pirk"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.PIRK.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.PIRK.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.PIRK.CAST_DELAY = 4.0  # Delay after casting before lure sinks
                _C.PROFILE.PIRK.SINK_TIMEOUT = 60.0  # Maximum time allowed for sinking
                # Duration to tighten the line after sinking lure/adjusting lure depth
                _C.PROFILE.PIRK.TIGHTEN_DURATION = 1.0
                # Delay after opening reel to adjust lure depth, set this to 0 to recast the rod instead
                _C.PROFILE.PIRK.DEPTH_ADJUST_DELAY = 4.0
                # Durtion to tighten the line after opening reel for DEPTH_ADJUST_DELAY seconds
                _C.PROFILE.PIRK.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.PIRK.CTRL = False  # Hold Ctrl key during pirking
                _C.PROFILE.PIRK.SHIFT = False  # Hold Shift key during pirking
                # Duration of lifting the rod, set this to 0 if you want to wait instead of pirking
                _C.PROFILE.PIRK.PIRK_DURATION = 0.5
                _C.PROFILE.PIRK.PIRK_DELAY = 2.0  # Delay after lifting the rod
                # Timeout for pirking session
                _C.PROFILE.PIRK.PIRK_TIMEOUT = 32.0
                # Retrieve the fishing line during pirking
                _C.PROFILE.PIRK.PIRK_RETRIEVAL = False
                # When a fish is hooked, check if the fish is still hooked
                # after HOOK_DELAY seconds, continue pirking if not
                _C.PROFILE.PIRK.HOOK_DELAY = 0.5
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.PIRK.POST_ACCELERATION = "auto"
                
                _C.PROFILE.PIRK_WITH_RETRIEVAL = CN()
                _C.PROFILE.PIRK_WITH_RETRIEVAL.MODE = "pirk"
                _C.PROFILE.PIRK_WITH_RETRIEVAL.LAUNCH_OPTIONS = ""
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_DELAY = 4.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.SINK_TIMEOUT = 60.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.TIGHTEN_DURATION = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DELAY = 0.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CTRL = False
                _C.PROFILE.PIRK_WITH_RETRIEVAL.SHIFT = False
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DURATION = 0.5
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DELAY = 2.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_TIMEOUT = 32.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_RETRIEVAL = True
                _C.PROFILE.PIRK_WITH_RETRIEVAL.HOOK_DELAY = 0.5
                _C.PROFILE.PIRK_WITH_RETRIEVAL.POST_ACCELERATION = "auto"
                
                # Spin fishing with wakey rig at Ladoga Archipelago
                _C.PROFILE.WAKEY_RIG = CN()
                _C.PROFILE.WAKEY_RIG.MODE = "pirk"
                _C.PROFILE.WAKEY_RIG.LAUNCH_OPTIONS = ""
                _C.PROFILE.WAKEY_RIG.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.WAKEY_RIG.CAST_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.SINK_TIMEOUT = 45.0
                _C.PROFILE.WAKEY_RIG.TIGHTEN_DURATION = 1.0
                _C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.WAKEY_RIG.CTRL = True
                _C.PROFILE.WAKEY_RIG.CTRL = False
                _C.PROFILE.WAKEY_RIG.PIRK_DURATION = 1.5
                _C.PROFILE.WAKEY_RIG.PIRK_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.PIRK_TIMEOUT = 32.0
                _C.PROFILE.WAKEY_RIG.PIRK_RETRIEVAL = False
                _C.PROFILE.WAKEY_RIG.HOOK_DELAY = 0.5
                _C.PROFILE.WAKEY_RIG.POST_ACCELERATION = "auto"
                
                # ---------------------------------------------------------------------------- #
                #                            Marine Elevator Profile                           #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.ELEVATOR = CN()
                _C.PROFILE.ELEVATOR.MODE = "elevator"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.ELEVATOR.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.ELEVATOR.CAST_POWER_LEVEL = 1.0
                # Delay after casting before lure sinks
                _C.PROFILE.ELEVATOR.CAST_DELAY = 4.0
                # Maximum time allowed for sinking
                _C.PROFILE.ELEVATOR.SINK_TIMEOUT = 60.0
                # Duration to tighten the line after sinking lure
                _C.PROFILE.ELEVATOR.TIGHTEN_DURATION = 1.0
                # Duration of retrieving the fishing line/opening the reel
                _C.PROFILE.ELEVATOR.ELEVATE_DURATION = 4.0
                # Delay after retrieving the fishing line/opening the reel
                _C.PROFILE.ELEVATOR.ELEVATE_DELAY = 4.0
                # Timeout for pirking session
                _C.PROFILE.ELEVATOR.ELEVATE_TIMEOUT = 40.0
                # Lock / Unlocking the reel after elevating timed out to drop the lure level by level
                _C.PROFILE.ELEVATOR.DROP = False
                # When a fish is hooked, check if the fish is still hooked
                # after HOOK_DELAY seconds, continue elevating if not
                _C.PROFILE.ELEVATOR.HOOK_DELAY = 0.5
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.ELEVATOR.POST_ACCELERATION = "auto"
                
                _C.PROFILE.ELEVATOR_WITH_DROP = CN()
                _C.PROFILE.ELEVATOR_WITH_DROP.MODE = "elevator"
                _C.PROFILE.ELEVATOR_WITH_DROP.LAUNCH_OPTIONS = ""
                _C.PROFILE.ELEVATOR_WITH_DROP.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.ELEVATOR_WITH_DROP.CAST_DELAY = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.SINK_TIMEOUT = 60.0
                _C.PROFILE.ELEVATOR_WITH_DROP.TIGHTEN_DURATION = 1.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DURATION = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DELAY = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_TIMEOUT = 40.0
                _C.PROFILE.ELEVATOR_WITH_DROP.DROP = True
                _C.PROFILE.ELEVATOR_WITH_DROP.HOOK_DELAY = 0.5
                _C.PROFILE.ELEVATOR_WITH_DROP.POST_ACCELERATION = "auto"
                
                # ---------------------------------------------------------------------------- #
                #                          Telescopic fishing Profile                          #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.TELESCOPIC = CN()
                _C.PROFILE.TELESCOPIC.MODE = "telescopic"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.TELESCOPIC.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.TELESCOPIC.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.TELESCOPIC.CAST_DELAY = 4.0
                # Sensitivity of float detection
                _C.PROFILE.TELESCOPIC.FLOAT_SENSITIVITY = 0.68
                _C.PROFILE.TELESCOPIC.CHECK_DELAY = 1.0  # Delay between fish bite checks
                _C.PROFILE.TELESCOPIC.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
                # Recast rod after timed out, designed for flowing water maps
                _C.PROFILE.TELESCOPIC.DRIFT_TIMEOUT = 16.0
                # Shape of the float camera, the script tracks the whole camrea window by default
                # Options: square, wide, tall
                _C.PROFILE.TELESCOPIC.CAMERA_SHAPE = "square"
                
                
                # ---------------------------------------------------------------------------- #
                #                           Bolognese Fishing Profile                          #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.BOLOGNESE = CN()
                _C.PROFILE.BOLOGNESE.MODE = "bolognese"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.BOLOGNESE.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.BOLOGNESE.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.BOLOGNESE.CAST_DELAY = 4.0
                # Sensitivity of float detection
                _C.PROFILE.BOLOGNESE.FLOAT_SENSITIVITY = 0.68
                _C.PROFILE.BOLOGNESE.CHECK_DELAY = 1.0  # Delay between fish bite checks
                _C.PROFILE.BOLOGNESE.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
                # Recast rod after timed out, designed for flowing water maps
                _C.PROFILE.BOLOGNESE.DRIFT_TIMEOUT = 32.0
                # Shape of the float camera, the script tracks the whole camrea window by default
                # Options: square, wide, tall
                # (Fallback to float camera detection mode if the window size is not supported)
                _C.PROFILE.BOLOGNESE.CAMERA_SHAPE = "square"
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.BOLOGNESE.POST_ACCELERATION = "off"
                
                
                def get_cfg_defaults():
                    """Get a yacs CfgNode object with default values for my_project."""
                    # Return a clone so that the defaults will not be altered
                    # This is for the "local variable" use pattern
                    return _C.clone()
            üìÑ __init__.py
                [EMPTY FILE]
            üìÅ __pycache__/
                üìÑ config.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ defaults.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ controller/
            üìÑ detection.py
                """Module for pyautogui.locateOnScreen and pag.pixel wrappers.
                
                This module provides functionality for detecting in-game elements using image recognition
                and pixel color analysis. It is used for automating tasks in Russian Fishing 4.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import time
                from enum import Enum
                from functools import partial
                from pathlib import Path
                from typing import Generator
                
                import cv2
                import numpy as np
                import pyautogui as pag
                from PIL import Image
                from pyscreeze import Box
                
                from rf4s.controller.window import Window
                
                CRITICAL_COLOR = (206, 56, 21)
                WARNING_COLOR = (227, 149, 23)
                WHITE = (255, 255, 255)
                
                MIN_GRAY_SCALE_LEVEL = 150
                YELLOW_FRICTION_BRAKE = (200, 214, 63)
                ORANGE_FRICTION_BRAKE = (229, 188, 0)
                RED_FRICTION_BRAKE = (206, 56, 21)
                COLOR_TOLERANCE = 32
                CAMERA_OFFSET = 40
                SIDE_LENGTH = 160
                SIDE_LENGTH_HALF = 80
                ORANGE_REEL = (227, 149, 23)
                
                ROOT = Path(__file__).resolve().parents[2]
                
                
                class TagColor(Enum):
                    GREEN = "green_tag"
                    YELLOW = "yellow_tag"
                    PINK = "pink_tag"
                    BLUE = "blue_tag"
                    PURPLE = "purple_tag"
                
                
                COORD_OFFSETS = {
                    "1600x900": {
                        "friction_brake_very_high": (502, 872),  # Left point only
                        "friction_brake_high": (459, 872),
                        "friction_brake_medium": (417, 872),
                        "friction_brake_low": (396, 872),
                        "fish_icon": (389, 844),
                        "clip_icon": (1042, 844),
                        "spool_icon": (1077, 844),  # x + 15, y + 15
                        "reel_burning_icon": (1112, 842),
                        "snag_icon": (1147, 829),  # x + 15, y
                        "float_camera": (720, 654),
                        "bait_icon": (35, 31),
                    },
                    "1920x1080": {
                        "friction_brake_very_high": (662, 1052),
                        "friction_brake_high": (619, 1052),
                        "friction_brake_medium": (577, 1052),
                        "friction_brake_low": (556, 1052),
                        "fish_icon": (549, 1024),
                        "clip_icon": (1202, 1024),
                        "spool_icon": (1237, 1024),
                        "reel_burning_icon": (1271, 1023),
                        "snag_icon": (1307, 1009),
                        "float_camera": (880, 834),
                        "bait_icon": (35, 31),
                    },
                    "2560x1440": {
                        "friction_brake_very_high": (982, 1412),
                        "friction_brake_high": (939, 1412),
                        "friction_brake_medium": (897, 1412),
                        "friction_brake_low": (876, 1412),
                        "fish_icon": (869, 1384),
                        "clip_icon": (1522, 1384),
                        "spool_icon": (1557, 1384),
                        "reel_burning_icon": (1593, 1383),
                        "snag_icon": (1627, 1369),
                        "float_camera": (1200, 1194),
                        "bait_icon": (35, 31),
                    },
                }
                
                # ------------------------ Friction brake coordinates ------------------------ #
                # ----------------------------- 900p - 1080p - 2k ---------------------------- #
                # ------ left - red - yellow - center(left + 424) - yellow - red - right ----- #
                # "bases": ((480, 270), (320, 180), (0, 0))
                # "absolute": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702, "y": (1146, 1236, 1412)}
                # "1600x900": {"x": (375, 480, 586, 799, 1011, 1118, 1222), "y": 876},
                # "1920x1080": {"x": (535, 640, 746, 959, 1171, 1278, 1382), "y": 1056},
                # "2560x1440": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702), "y": 1412},
                
                
                class Detection:
                    """A class that holds different aliases of locateOnScreen(image).
                
                    This class provides methods for detecting various in-game elements such as fish,
                    icons, and UI components using image recognition and pixel color analysis.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for the detection settings.
                        window (Window): Game window controller instance.
                        image_dir (Path): Directory containing reference images for detection.
                        coord_offsets (dict): Dictionary of coordinate offsets for different window sizes.
                        bait_icon_reference_img (Image): Reference image for bait icon detection.
                    """
                
                    def __init__(self, cfg, window: Window):
                        """Initialize the Detection class with configuration and window settings.
                
                        :param cfg: Configuration node for detection settings.
                        :type cfg: CfgNode
                        :param window: Game window controller instance.
                        :type window: Window
                        """
                        self.cfg = cfg
                        self.window = window
                        self.image_dir = ROOT / "static" / cfg.SCRIPT.LANGUAGE
                
                        if window.is_size_supported():
                            self._set_absolute_coords()
                            self.is_fish_hooked = self.is_fish_hooked_pixel
                        else:
                            self.is_fish_hooked = partial(
                                self._get_image_box,
                                image="fish_icon",
                                confidence="0.9",
                            )
                
                        self.bait_icon_reference_img = Image.open(self.image_dir / "bait_icon.png")
                
                    def _get_image_box(
                        self, image: str, confidence: float, multiple: bool = False
                    ) -> Box | Generator[Box, None, None] | None:
                        """A wrapper for locateOnScreen method and path resolving.
                
                        :param image: Base name of the image.
                        :type image: str
                        :param confidence: Matching confidence for locateOnScreen.
                        :type confidence: float
                        :param multiple: Whether to locate all matching images, defaults to False.
                        :type multiple: bool, optional
                        :return: Image box, None if not found.
                        :rtype: Box | None
                        """
                        image_path = str(self.image_dir / f"{image}.png")
                        if multiple:
                            return pag.locateAllOnScreen(image_path, confidence=confidence)
                        return pag.locateOnScreen(image_path, confidence=confidence)
                
                    def _set_absolute_coords(self) -> None:
                        """Add offsets to the base coordinates to get absolute ones."""
                        self.coord_offsets = COORD_OFFSETS[self.window.get_resolution_str()]
                
                        for key in self.coord_offsets:
                            setattr(self, f"{key}_coord", self._get_absolute_coord(key))
                
                        self.bait_icon_coord = self._get_absolute_coord("bait_icon") + [44, 52]
                        friction_brake_key = f"friction_brake_{self.cfg.FRICTION_BRAKE.SENSITIVITY}"
                        self.friction_brake_coord = self._get_absolute_coord(friction_brake_key)
                
                        bases = self._get_absolute_coord("float_camera")
                        if self.cfg.SELECTED.MODE in ("telescopic", "bolognese"):
                            match self.cfg.SELECTED.CAMERA_SHAPE:
                                case "tall":
                                    bases[0] += CAMERA_OFFSET
                                    width, height = SIDE_LENGTH_HALF, SIDE_LENGTH
                                case "wide":
                                    bases[1] += CAMERA_OFFSET
                                    width, height = SIDE_LENGTH, SIDE_LENGTH_HALF
                                case "square":
                                    width, height = SIDE_LENGTH, SIDE_LENGTH
                                case _:
                                    raise ValueError(self.cfg.SELECTED.CAMERA_SHAPE)
                            self.float_camera_rect = (*bases, width, height)  # (left, top, w, h)
                
                    def _get_absolute_coord(self, offset_key: str) -> list[int]:
                        """Calculate absolute coordinate based on given key.
                
                        :param offset_key: A key in the offset dictionary.
                        :type offset_key: str
                        :return: Converted absolute coordinate.
                        :rtype: list[int]
                        """
                        box = self.window.get_box()
                        return [box[i] + self.coord_offsets[offset_key][i] for i in range(2)]
                
                    # ----------------------------- Untagged release ----------------------------- #
                    def is_tag_exist(self, color: TagColor):
                        match color:
                            case TagColor.GREEN:
                                lower = np.array([30, 128, 128])
                                upper = np.array([36, 255, 255])
                            case TagColor.YELLOW:
                                lower = np.array([22, 128, 128])
                                upper = np.array([28, 255, 255])
                            case TagColor.PINK:
                                lower = np.array([142, 64, 128])
                                upper = np.array([148, 255, 255])
                            case TagColor.BLUE:
                                lower = np.array([101, 64, 128])
                                upper = np.array([107, 255, 255])
                            case TagColor.PURPLE:
                                lower = np.array([127, 64, 128])
                                upper = np.array([133, 255, 255])
                            case _:
                                raise ValueError("Invalid tag color")
                        hsv_img = cv2.cvtColor(np.array(pag.screenshot()), cv2.COLOR_RGB2HSV)
                        mask = cv2.inRange(hsv_img, lower, upper)
                        haystack_img = Image.fromarray(mask)
                        needle_img = Image.open(self.image_dir / f"{color.value}.png")
                        return pag.locate(needle_img, haystack_img, grayscale=True, confidence=0.9)
                
                    def is_fish_species_matched(self, species: str):
                        return self._get_image_box(species, 0.9)
                
                    # -------------------------------- Fish status ------------------------------- #
                    def is_fish_hooked(self):
                        pass  # It's initialized in the constructor
                
                    def is_fish_hooked_pixel(self) -> bool:
                        return all(c > MIN_GRAY_SCALE_LEVEL for c in pag.pixel(*self.fish_icon_coord))
                
                    def is_fish_hooked_twice(self) -> bool:
                        if not self.is_fish_hooked():
                            return False
                
                        # check if the fish got away after a short delay
                        time.sleep(self.cfg.SELECTED.HOOK_DELAY)
                        if self.is_fish_hooked():
                            return True
                        return False
                
                    def is_fish_captured(self):
                        return self._get_image_box("keep", 0.9)
                
                    def is_fish_whitelisted(self) -> bool:
                        """Check if the fish is in the whitelist.
                
                        :return: True if the fish is in the whitelist, False otherwise.
                        :rtype: bool
                        """
                        return self._is_fish_in_list(self.cfg.KEEPNET.WHITELIST)
                
                    def is_fish_blacklisted(self) -> bool:
                        """Check if the fish is in the blacklist.
                
                        :return:  True if the fish is in the blacklist, False otherwise
                        :rtype: bool
                        """
                        return self._is_fish_in_list(self.cfg.KEEPNET.BLACKLIST)
                
                    def _is_fish_in_list(self, fish_species_list: tuple | list) -> bool:
                        """Check if the fish species matches any in the table.
                
                        :param fish_species_list: fish species list
                        :type fish_species_list: tuple | list
                        :return: True if the fish species matches, False otherwise
                        :rtype: bool
                        """
                        for species in fish_species_list:
                            if self.is_fish_species_matched(species):
                                return True
                        return False
                
                    # ---------------------------- Retrieval detection --------------------------- #
                    def is_retrieval_finished(self):
                        ready = self.is_tackle_ready()
                        if self.cfg.ARGS.RAINBOW:
                            return ready or self._is_rainbow_line_0or5m()
                        return ready or self._is_spool_full()
                
                    def _is_rainbow_line_0or5m(self):
                        return self._get_image_box(
                            "5m", self.cfg.SCRIPT.SPOOL_CONFIDENCE
                        ) or self._get_image_box("0m", self.cfg.SCRIPT.SPOOL_CONFIDENCE)
                
                    def _is_spool_full(self):
                        return self._get_image_box("wheel", self.cfg.SCRIPT.SPOOL_CONFIDENCE)
                
                    def is_line_snagged(self) -> bool:
                        return pag.pixel(*self.snag_icon_coord) == CRITICAL_COLOR
                
                    def is_line_at_end(self) -> bool:
                        return pag.pixel(*self.spool_icon_coord) in (WARNING_COLOR, CRITICAL_COLOR)
                
                    def is_clip_open(self) -> bool:
                        return not all(
                            c > MIN_GRAY_SCALE_LEVEL for c in pag.pixel(*self.clip_icon_coord)
                        )
                
                    # ------------------------------ Text detection ------------------------------ #
                    def is_tackle_ready(self):
                        return self._get_image_box("ready", 0.6)
                
                    def is_tackle_broken(self):
                        return self._get_image_box("broke", 0.8)
                
                    def is_lure_broken(self):
                        return self._get_image_box("lure_is_broken", 0.8)
                
                    def is_moving_in_bottom_layer(self):
                        return self._get_image_box("movement", 0.7)
                
                    # ------------------------------ Hint detection ------------------------------ #
                    def is_disconnected(self):
                        return self._get_image_box("disconnected", 0.9)
                
                    def is_ticket_expired(self):
                        return self._get_image_box("ticket", 0.9)
                
                    # ------------------------------- Item crafting ------------------------------ #
                    def is_operation_failed(self):
                        return self._get_image_box("warning", 0.8)
                
                    def is_operation_success(self):
                        return self._get_image_box("ok_black", 0.8) or self._get_image_box(
                            "ok_white", 0.8
                        )
                
                    def is_material_complete(self):
                        return not self._get_image_box("material_slot", 0.7)
                
                    # ---------------------- Quiting game from control panel --------------------- #
                    def get_quit_position(self):
                        return self._get_image_box("quit", 0.8)
                
                    def get_yes_position(self):
                        return self._get_image_box("yes", 0.8)
                
                    def get_make_button_position(self):
                        return self._get_image_box("make", 0.9)
                
                    # ------------------------ Quiting game from main menu ----------------------- #
                    def get_exit_icon_position(self):
                        return self._get_image_box("exit", 0.8)
                
                    def get_confirm_button_position(self):
                        return self._get_image_box("confirm", 0.8)
                
                    # ------------------------------- Player stats ------------------------------- #
                    def _get_energy_icon_position(self):
                        box = self._get_image_box("energy", 0.8)
                        return box if box is None else pag.center(box)
                
                    def _get_food_icon_position(self):
                        box = self._get_image_box("food", 0.8)
                        return box if box is None else pag.center(box)
                
                    def _get_comfort_icon_position(self):
                        box = self._get_image_box("comfort", 0.8)
                        return box if box is None else pag.center(box)
                
                    def get_food_position(self, food: str):
                        return self._get_image_box(food, 0.9)
                
                    def is_energy_high(self) -> bool:
                        pos = self._get_energy_icon_position()
                        if not pos:
                            return False
                        x, y = int(pos.x), int(pos.y)
                        # default threshold: 0.74,  well done FishSoft
                        last_point = int(19 + 152 * self.cfg.STAT.ENERGY_THRESHOLD) - 1
                        return pag.pixel(x + 19, y) == pag.pixel(x + last_point, y)
                
                    def is_hunger_low(self) -> bool:
                        pos = self._get_food_icon_position()
                        if not pos:
                            return False
                        x, y = int(pos.x), int(pos.y)
                        last_point = int(18 + 152 * self.cfg.STAT.HUNGER_THRESHOLD) - 1
                        return not pag.pixel(x + 18, y) == pag.pixel(x + last_point, y)
                
                    def is_comfort_low(self) -> bool:
                        pos = self._get_comfort_icon_position()
                        if not pos:
                            return False
                        x, y = int(pos.x), int(pos.y)
                        last_point = int(18 + 152 * self.cfg.STAT.COMFORT_THRESHOLD) - 1
                        return not pag.pixel(x + 18, y) == pag.pixel(x + last_point, y)
                
                    # ----------------------------- Item replacement ----------------------------- #
                    def get_scrollbar_position(self):
                        return self._get_image_box("scrollbar", 0.97)
                
                    def get_100wear_position(self):
                        return self._get_image_box("100wear", 0.98)
                
                    def get_favorite_item_positions(self):
                        return self._get_image_box("favorite", 0.95, multiple=True)
                
                    def is_pva_chosen(self):
                        return self._get_image_box("pva_icon", 0.6) is None
                
                    def is_bait_chosen(self):
                        if self.cfg.SELECTED.MODE in ("pirk", "elevator"):
                            return True
                
                        # Two bait slots, check only the first one
                        if self.cfg.SELECTED.MODE in ("telescopic", "bolognese"):
                            return (
                                pag.locate(
                                    pag.screenshot(region=self.bait_icon_coord),
                                    self.bait_icon_reference_img,
                                    confidence=0.6,
                                )
                                is None
                            )
                        return self._get_image_box("bait_icon", 0.6) is None
                
                    def is_groundbait_chosen(self):
                        return self._get_image_box("groundbait_icon", 0.6) is None
                
                    def get_groundbait_position(self):
                        return self._get_image_box("classic_feed_mix", 0.95)
                
                    def get_dry_mix_position(self):
                        return self._get_image_box("dry_feed_mix", 0.95)
                
                    def get_pva_position(self):
                        return self._get_image_box("pva_stick_or_pva_stringer", 0.95)
                
                    # ------------------------------ Friction brake ------------------------------ #
                    def is_friction_brake_high(self) -> bool:
                        return pag.pixelMatchesColor(
                            *self.friction_brake_coord, RED_FRICTION_BRAKE, COLOR_TOLERANCE
                        )
                
                    def is_reel_burning(self) -> bool:
                        return pag.pixel(*self.reel_burning_icon_coord) == ORANGE_REEL
                
                    def is_float_state_changed(self, reference_img):
                        current_img = pag.screenshot(region=self.float_camera_rect)
                        return not pag.locate(
                            current_img,
                            reference_img,
                            grayscale=True,
                            confidence=self.cfg.SELECTED.FLOAT_SENSITIVITY,
                        )
                
                    def get_ticket_position(self, duration: int):
                        return self._get_image_box(f"ticket_{duration}", 0.95)
                
                    def is_harvest_success(self):
                        return self._get_image_box("harvest_confirm", 0.8)
                
                    def is_gift_receieved(self):
                        return self._get_image_box("gift", 0.8)
            üìÑ notification.py
                import json
                import logging
                import smtplib
                from datetime import datetime, timezone
                from email.mime.multipart import MIMEMultipart
                from email.mime.text import MIMEText
                from enum import Enum
                from urllib import parse, request
                
                from discord_webhook import DiscordEmbed, DiscordWebhook
                from rich import box
                from rich.console import Console
                from rich.table import Table
                
                logger = logging.getLogger("rich")
                
                ICON_URL = "https://i.ibb.co/RpLYcdkm/icon.png"
                
                # Name                             | Int value | Hex code
                # ---------------------------------|-----------|----------
                # `BLURPLE`                        | 5793266   | `#5865F2`
                # `GREEN`                          | 5763719   | `#57F287`
                # `YELLOW`                         | 16705372  | `#FEE75C`
                # `FUSCHIA`                        | 15418782  | `#EB459E`
                # `RED`                            | 15548997  | `#ED4245`
                # `WHITE`                          | 16777215  | `#FFFFFF`
                # `BLACK`                          | 2303786   | `#23272A`
                
                
                class DiscordColor(Enum):
                    BLURPLE = 5793266
                    GREEN = 5763719
                    YELLOW = 16705372
                    FUSCHIA = 15418782
                    RED = 15548997
                    WHITE = 16777215
                    BLACK = 2303786
                
                
                class DiscordNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def build_raw_table(self) -> str:
                        console = Console(width=100, force_terminal=True, color_system=None)
                        table = Table("Field", "Value", box=box.DOUBLE, show_header=False)
                
                        for key, value in self.result.items():
                            table.add_row(key, str(value))
                
                        with console.capture() as capture:
                            console.print(table)
                
                        return capture.get().strip()
                
                    def send(self, color: DiscordColor):
                        logger.info("Sending Discord notification")
                        raw_table = self.build_raw_table()
                        webhook = DiscordWebhook(
                            url=self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL,
                            username="RF4S",
                            avatar_url=ICON_URL,
                        )
                
                        embed = DiscordEmbed(
                            title="Running Result",
                            color=color,
                            timestamp=datetime.now(timezone.utc).isoformat(),
                            footer={"text": "RF4S: Russian Fishing 4 Script", "icon_url": ICON_URL},
                        )
                        embed.description = f"```\n{raw_table}\n```"  # Wrap in code block
                
                        webhook.add_embed(embed)
                        response = webhook.execute()
                
                        if response.status_code == 200:
                            logger.info("Result successfully sent to Discord")
                        else:
                            logger.error(f"Failed to send result to Discord: {response.text}")
                
                
                class EmailNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def send(self) -> None:
                        """Send a notification email to the user's email address."""
                        logger.info("Sending email notification")
                
                        msg = MIMEMultipart()
                        msg["Subject"] = "RF4S: Notice of Program Termination"
                        msg["From"] = self.cfg.NOTIFICATION.EMAIL
                        recipients = [self.cfg.NOTIFICATION.EMAIL]
                        msg["To"] = ", ".join(recipients)
                
                        text = ""
                        for k, v in self.result.items():
                            text += f"{k}: {v}\n"
                        msg.attach(MIMEText(text))
                
                        try:
                            with smtplib.SMTP_SSL(self.cfg.NOTIFICATION.SMTP_SERVER, 465) as server:
                                # smtp_server.ehlo()
                                server.login(
                                    self.cfg.NOTIFICATION.EMAIL, self.cfg.NOTIFICATION.PASSWORD
                                )
                                server.sendmail(
                                    self.cfg.NOTIFICATION.EMAIL, recipients, msg.as_string()
                                )
                            logger.info("Email sent successfully")
                        except Exception as e:
                            logger.error(f"Failed to send email: {e}")
                
                
                class MiaotixingNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def send(self) -> None:
                        """Send a notification to the user's miaotixing service.
                
                        :param result: running result
                        :type result: dict
                        """
                        logger.info("Sending miaotixing notification")
                
                        text = ""
                        for k, v in self.result.items():
                            text += f"{k}: {v}\n"
                
                        url = "http://miaotixing.com/trigger?" + parse.urlencode(
                            {"id": self.cfg.NOTIFICATION.MIAO_CODE, "text": text, "type": "json"}
                        )
                
                        with request.urlopen(url) as page:
                            result = page.read()
                            json_object = json.loads(result)
                            if json_object["code"] == 0:
                                logger.info("Miaotixing notification sent successfully")
                            else:
                                logger.error(
                                    "Miaotixing notification with error code: %s\nDescription: %s",
                                    str(json_object["code"]),
                                    json_object["msg"],
                                )
            üìÑ timer.py
                """Module for Timer class.
                
                This module provides functionality for managing timers and generating timestamps
                for logging and automation purposes in Russian Fishing 4.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import datetime
                import logging
                import sys
                import time
                from pathlib import Path
                
                from matplotlib import pyplot as plt
                from matplotlib.ticker import MaxNLocator
                
                from rf4s.utils import is_compiled
                
                logger = logging.getLogger("rich")
                
                
                if is_compiled():
                    ROOT = Path(sys.executable).parent  # Running as .exe (Nuitka/PyInstaller)
                else:
                    ROOT = Path(__file__).resolve().parents[2]
                
                
                class Timer:
                    """Class for calculating and generating timestamps for logs.
                
                    This class manages various timers and counters for tracking in-game events,
                    such as casting times, consumable cooldowns, and script pauses.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for timer settings.
                        start_time (float): Timestamp when the timer was initialized.
                        start_datetime (str): Formatted start date and time.
                        cast_rhour (int | None): Real-time hour of the last cast.
                        cast_ghour (int | None): In-game hour of the last cast.
                        cast_rhour_list (list[int]): List of real-time hours for casts.
                        cast_ghour_list (list[int]): List of in-game hours for casts.
                        last_tea_drink (float): Timestamp of the last tea consumption.
                        last_alcohol_drink (float): Timestamp of the last alcohol consumption.
                        last_lure_change (float): Timestamp of the last lure change.
                        last_spod_rod_recast (float): Timestamp of the last spod rod recast.
                        last_pause (float): Timestamp of the last script pause.
                    """
                
                    def __init__(self, cfg):
                        """Initialize the Timer class with configuration settings.
                
                        :param cfg: Configuration node for timer settings.
                        :type cfg: CfgNode
                        """
                        self.cfg = cfg
                        self.start_time = time.time()
                        self.start_datetime = time.strftime("%m/%d %H:%M:%S", time.localtime())
                
                        self.cast_rhour = None
                        self.cast_ghour = None
                        self.cast_rhour_list = []
                        self.cast_ghour_list = []
                
                        self.last_tea_drink = 0
                        self.last_alcohol_drink = 0
                        self.last_lure_change = self.start_time
                        self.last_spod_rod_recast = self.start_time
                        self.last_pause = self.start_time
                
                    def get_running_time(self) -> str:
                        """Calculate the execution time of the program.
                
                        :return: Formatted execution time (hh:mm:ss).
                        :rtype: str
                        """
                        return time.time() - self.start_time
                
                    def get_running_time_str(self) -> str:
                        """Calculate the execution time of the program.
                
                        :return: Formatted execution time (hh:mm:ss).
                        :rtype: str
                        """
                        return str(
                            datetime.timedelta(seconds=int(time.time() - self.start_time))
                        )  # truncate to seconds
                
                    def get_cur_timestamp(self) -> str:
                        """Generate timestamp for images in screenshots/.
                
                        :return: Current timestamp.
                        :rtype: str
                        """
                        return time.strftime("%Y-%m-%d--%H-%M-%S", time.localtime())
                
                    def get_start_datetime(self) -> str:
                        """Generate a simplified timestamp for quit message.
                
                        :return: Start date and time.
                        :rtype: str
                        """
                        return self.start_datetime
                
                    def get_cur_datetime(self) -> str:
                        """Generate a simplified timestamp for quit message.
                
                        :return: Current date and time.
                        :rtype: str
                        """
                        return time.strftime("%m/%d %H:%M:%S", time.localtime())
                
                    def update_cast_time(self) -> None:
                        """Update the latest real and in-game hour of casting."""
                        dt = datetime.datetime.now()
                        self.cast_rhour = int((time.time() - self.start_time) // 3600)
                        self.cast_ghour = int((dt.minute / 60 + dt.second / 3600) * 24 % 24)
                
                    def add_cast_time(self) -> None:
                        """Record the latest real and in-game hour of casting."""
                        self.cast_rhour_list.append(self.cast_rhour)
                        self.cast_ghour_list.append(self.cast_ghour)
                
                    def get_cast_time_list(self) -> tuple[list[int]]:
                        """Get lists of real and in-game hours for casts.
                
                        :return: Lists of real and in-game hours.
                        :rtype: tuple[list[int]]
                        """
                        return self.cast_rhour_list, self.cast_ghour_list
                
                    def is_tea_drinkable(self) -> bool:
                        """Check if it has been a long time since the last tea consumption.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_tea_drink > self.cfg.STAT.TEA_DELAY:
                            self.last_tea_drink = cur_time
                            return True
                        return False
                
                    def is_alcohol_drinkable(self) -> bool:
                        """Check if it has been a long time since the last alcohol consumption.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_alcohol_drink > self.cfg.STAT.ALCOHOL_DELAY:
                            self.last_alcohol_drink = cur_time
                            self.last_tea_drink = cur_time  # Alcohol also refill comfort
                            return True
                        return False
                
                    def is_lure_changeable(self):
                        """Check if it has been a long time since the last lure change.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_lure_change > self.cfg.SCRIPT.LURE_CHANGE_DELAY:
                            self.last_lure_change = cur_time
                            return True
                        return False
                
                    def is_spod_rod_castable(self):
                        """Check if it has been a long time since the last spod rod recast.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_spod_rod_recast > self.cfg.SCRIPT.SPOD_ROD_RECAST_DELAY:
                            self.last_spod_rod_recast = cur_time
                            return True
                        return False
                
                    def is_script_pausable(self):
                        """Check if it has been a long time since the last script pause.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_pause > self.cfg.PAUSE.DELAY:
                            self.last_pause = cur_time
                            return True
                        return False
                
                    def plot_and_save(self) -> None:
                        """Plot and save an image using rhour and ghour lists from the timer object."""
                        logger.info("Plotting line chart")
                
                        cast_rhour_list, cast_ghour_list = self.get_cast_time_list()
                        _, ax = plt.subplots(nrows=1, ncols=2)
                        # _.canvas.manager.set_window_title('Record')
                        ax[0].set_ylabel("Fish")
                
                        last_rhour = cast_rhour_list[-1]  # Hour: 0, 1, 2, 3, 4, "5"
                        fish_per_rhour = [0] * (last_rhour + 1)  # Idx: (0, 1, 2, 3, 4, 5) = 6
                        for hour in cast_rhour_list:
                            fish_per_rhour[hour] += 1
                        ax[0].plot(range(last_rhour + 1), fish_per_rhour)
                        ax[0].set_title("Fish Caughted per Real Hour")
                        ax[0].set_xticks(range(last_rhour + 2))
                        ax[0].set_xlabel("Hour (real running time)")
                        ax[0].yaxis.set_major_locator(MaxNLocator(integer=True))
                
                        fish_per_ghour = [0] * 24
                        for hour in cast_ghour_list:
                            fish_per_ghour[hour] += 1
                        ax[1].bar(range(0, 24), fish_per_ghour)
                        ax[1].set_title("Fish Caughted per Game Hour")
                        ax[1].set_xticks(range(0, 24, 2))
                        ax[1].set_xlabel("Hour (game time)")
                        ax[1].yaxis.set_major_locator(MaxNLocator(integer=True))
                
                        # plt.tight_layout()
                        plt.savefig(str(ROOT / f"logs/{self.get_cur_timestamp()}.png"))
                        logger.info("Chart has been saved under logs/")
            üìÑ window.py
                """Module for window controller.
                
                This module provides functionality for managing and interacting with the game window
                and terminal window in Russian Fishing 4.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                import sys
                from pathlib import Path
                from time import sleep
                
                # import win32api, win32con
                import pyautogui as pag
                import win32con
                import win32gui
                
                sys.path.append(".")  # python -m module -> python file
                from rf4s import utils
                
                logger = logging.getLogger("rich")
                
                ANIMATION_DELAY = 0.25
                
                if utils.is_compiled():
                    ROOT = Path(sys.executable).parent  # Running as .exe (Nuitka/PyInstaller)
                else:
                    ROOT = Path(__file__).resolve().parents[2]
                
                
                class Window:
                    """Controller for terminal and game windows management.
                
                    This class handles window focus, size detection, and screenshot functionality
                    for the game and terminal windows.
                
                    Attributes:
                        game_title (str): Title of the game window.
                        terminal_hwnd (int): Handle of the terminal window.
                    """
                
                    def __init__(self, game_title: str = "Russian Fishing 4"):
                        """Set the hwnd of the terminal where user run the script.
                
                        We didn't retrieve the game window's hwnd here because we don't want to check
                        if the window is open right away. Instead, we perform the check after the
                        configuration is set.
                
                        :param game_title: Title of the game, defaults to "Russian Fishing 4".
                        :type game_title: str, optional
                        """
                        self.game_title = game_title
                        self.terminal_hwnd = win32gui.GetForegroundWindow()
                
                    def _get_game_hwnd(self) -> int:
                        """Get the handle of the game window.
                
                        :return: Process handle of the game window.
                        :rtype: int
                        """
                        hwnd = win32gui.FindWindow(None, self.game_title)  # class name: UnityWndClass
                        if hwnd == 0:
                            logger.critical("Failed to locate the game window: %s", self.game_title)
                            utils.safe_exit()
                        return hwnd
                
                    def is_title_bar_exist(self) -> bool:
                        """Check if the game window is in windowed mode.
                
                        :return: True if the game window has a title bar, False otherwise.
                        :rtype: bool
                        """
                        style = win32gui.GetWindowLong(self._get_game_hwnd(), win32con.GWL_STYLE)
                        return style & win32con.WS_CAPTION
                
                    def get_box(self) -> tuple[int, int, int, int]:
                        """Get the coordinates and dimensions of the game window.
                
                        :return: Tuple containing (x, y, width, height) of the game window.
                        :rtype: tuple[int, int, int, int]
                        """
                        # Absolute coordinates
                        base_x, base_y, _, _ = win32gui.GetWindowRect(self._get_game_hwnd())
                        if self.is_title_bar_exist():
                            base_x += 8
                            base_y += 31
                        # Relative coordinates
                        left, top, right, bottom = win32gui.GetClientRect(self._get_game_hwnd())
                        return base_x, base_y, right - left, bottom - top
                
                    def get_base_coordinates(self) -> tuple[int, int]:
                        """Get the base coordinates of the game window.
                
                        :return: Tuple containing (x, y) of the base coordinates.
                        :rtype: tuple[int, int]
                        """
                        return self.get_box()[:2]
                
                    def get_resolution_str(self) -> tuple[int, int]:
                        """Get the resolution of the game window.
                
                        :return: Tuple containing (width, height) of the game window.
                        :rtype: tuple[int, int]
                        """
                        width, height = self.get_box()[2:]
                        return f"{width}x{height}"
                
                    def activate_script_window(self) -> None:
                        """Focus the terminal where user run the script."""
                        pag.press("alt")
                        win32gui.SetForegroundWindow(self.terminal_hwnd)
                        sleep(ANIMATION_DELAY)
                
                    def activate_game_window(self) -> None:
                        """Focus game window."""
                        pag.press("alt")
                        win32gui.SetForegroundWindow(self._get_game_hwnd())
                        sleep(ANIMATION_DELAY)
                
                    def is_size_supported(self) -> bool:
                        """Check if the game window size is supported.
                
                        :return: True if it's supported, False otherwise.
                        :rtype: bool
                        """
                        return self.get_resolution_str() in (
                            "2560x1440",
                            "1920x1080",
                            "1600x900",
                        )
                
                    def save_screenshot(self, time) -> None:
                        """Save a screenshot of the game window to the screenshots directory.
                
                        :param time: Timestamp for the filename.
                        :type time: str
                        """
                        pag.screenshot(
                            imageFilename=ROOT / "screenshots" / f"{time}.png",
                            region=self.get_box(),
                        )
                
                
                if __name__ == "__main__":
                    w = Window("Russian Fishing 4")
                    # w.activate_game_window()
                    print(w.get_box())
                    print(w.get_base_coordinates())
                    print(w.get_resolution_str())
                    print(w.is_size_supported())
                
                # SetForegroundWindow bug reference :
                # https://stackoverflow.com/questions/56857560/win32gui-setforegroundwindowhandle-not-working-in-loop
            üìÅ __pycache__/
                üìÑ detection.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ notification.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ timer.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ window.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ result/
            üìÑ result.py
                from dataclasses import dataclass
                
                from rf4s.controller.timer import Timer
                
                
                @dataclass
                class Result:
                    """Dummy result."""
                
                    def as_dict(self) -> dict:
                        return {}
                
                
                @dataclass
                class RF4SResult:
                    tea: int = 0
                    carrot: int = 0
                    alcohol: int = 0
                    coffee: int = 0
                    bait: int = 0
                    kept: int = 0
                    total: int = 0
                    green: int = 0
                    yellow: int = 0
                    blue: int = 0
                    purple: int = 0
                    pink: int = 0
                
                    def as_dict(self, msg: str, timer: Timer) -> dict:
                        # Will be 0 if total_fish_count = 0
                        kept_ratio = f"{int(self.kept / max(1, self.total) * 100)}%"
                        bite_rate = f"{int((self.total / (timer.get_running_time() / 3600)))}/hr"
                
                        return {
                            "Stop reason": msg,
                            "Start time": timer.get_start_datetime(),
                            "End time": timer.get_cur_datetime(),
                            "Running time": timer.get_running_time_str(),
                            "Bite rate": bite_rate,
                            "Total fish": self.total,
                            "Kept fish": self.kept,
                            "Kept ratio": kept_ratio,
                            "Green tag fish": self.green,
                            "Yellow tag fish": self.yellow,
                            "Blue tag fish": self.blue,
                            "Purple tag fish": self.purple,
                            "Pink tag fish": self.pink,
                            "Tea consumed": self.tea,
                            "Carrot consumed": self.carrot,
                            "Alcohol consumed": self.alcohol,
                            "Coffee consumed": self.coffee,
                            "Bait harvested": self.bait,
                        }
                
                
                @dataclass
                class CraftResult:
                    succes: int = 0
                    fail: int = 0
                    material: int = 0
                
                    def as_dict(self) -> dict:
                        return {
                            "Successful crafts": self.succes,
                            "Failed crafts": self.fail,
                            "Materials used": self.material,
                        }
                
                
                @dataclass
                class HarvestResult:
                    tea: int = 0
                    carrot: int = 0
                    bait: int = 0
                
                    def as_dict(self) -> dict:
                        return {
                            "Tea consumed": self.tea,
                            "Carrot consumed": self.carrot,
                            "Bait harvested": self.bait,
                        }
            üìÅ __pycache__/
                üìÑ result.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ __pycache__/
            üìÑ exceptions.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ player.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ utils.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ __init__.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
    üìÅ screenshots/
    üìÅ static/
        üìÅ en/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ classic_feed_mix.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ dry_feed_mix.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ ok_black.png [IMAGE FILE]
            üìÑ ok_white.png [IMAGE FILE]
            üìÑ perch.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ pva_stick_or_pva_stringer.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ shorthorn_sculpin.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ readme/
            üìÑ clicklock.png [IMAGE FILE]
            üìÑ favorite_food.png [IMAGE FILE]
            üìÑ favorite_lure.png [IMAGE FILE]
            üìÑ icon.png [IMAGE FILE]
            üìÑ mtx1.png [IMAGE FILE]
            üìÑ mtx2.png [IMAGE FILE]
            üìÑ mtx3.png [IMAGE FILE]
            üìÑ path.png [IMAGE FILE]
            üìÑ RF4S.png [IMAGE FILE]
            üìÑ RF4S_original.png [IMAGE FILE]
            üìÑ status.png [IMAGE FILE]
        üìÅ ru/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ classic_feed_mix.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ dry_feed_mix.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ ok_black.png [IMAGE FILE]
            üìÑ ok_white.png [IMAGE FILE]
            üìÑ perch.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ pva_stick_or_pva_stringer.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ shorthorn_sculpin.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ sound/
            üìÑ app_1.wav [AUDIO FILE]
            üìÑ app_2.wav [AUDIO FILE]
            üìÑ app_3.wav [AUDIO FILE]
            üìÑ bell_1.wav [AUDIO FILE]
            üìÑ bell_2.wav [AUDIO FILE]
            üìÑ bell_3.wav [AUDIO FILE]
            üìÑ digital.wav [AUDIO FILE]
            üìÑ door_bell.wav [AUDIO FILE]
            üìÑ elevator.wav [AUDIO FILE]
            üìÑ fast_alarm.wav [AUDIO FILE]
            üìÑ flute_1.wav [AUDIO FILE]
            üìÑ flute_2.wav [AUDIO FILE]
            üìÑ guitar.wav [AUDIO FILE]
            üìÑ marimba.wav [AUDIO FILE]
            üìÑ ripple.wav [AUDIO FILE]
        üìÅ zh-CN/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ zh-TW/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
    üìÅ tools/
        üìÑ auto_friction_brake.py
            """Automate friction brake adjustments in Russian Fishing 4.
            
            This module provides functionality to automatically adjust the friction brake
            based on in-game conditions. It supports key bindings for exiting the script
            and resetting the friction brake.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from multiprocessing import Lock
            
            from pynput import keyboard
            from rich import print
            
            sys.path.append(".")
            from rf4s.app.app import ToolApp
            from rf4s.component.friction_brake import FrictionBrake
            from rf4s.config.config import print_cfg
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            logger = create_rich_logger()
            
            
            class FrictionBrakeApp(ToolApp):
                """Main application class for automating friction brake adjustments.
            
                This class manages the configuration, detection, and execution of the friction
                brake automation process. It also handles key bindings for exiting and resetting.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
                    friction_brake (FrictionBrake): Friction brake controller instance.
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    1. Check the game window state.
                    2. Format keybinds in cfg node.
                    3. Display cfg node.
                    4. Initialize a friction brake instance.
                    """
                    super().__init__()
                    if not self.is_game_window_valid():
                        safe_exit()
            
                    # Format keys
                    self.cfg.defrost()
                    self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
                    self.cfg.ARGS.RESET_KEY = f"'{self.cfg.ARGS.RESET_KEY}'"
                    self.cfg.freeze()
                    print_cfg(self.cfg.ARGS)
                    print_cfg(self.cfg.FRICTION_BRAKE)
            
                    self.friction_brake = FrictionBrake(self.cfg, Lock(), self.detection)
            
                def is_game_window_valid(self) -> bool:
                    """Check if the game window mode and size are valid.
            
                    :return: True if valid, False otherwise
                    :rtype: bool
                    """
                    if self.window.is_title_bar_exist():
                        logger.info("Window mode detected. Please don't move the game window")
                    if not self.window.is_size_supported():
                        logger.critical(
                            'Window mode must be "Borderless windowed" or "Window mode"'
                        )
                        logger.critical(
                            "Unsupported window size '%s', "
                            "use '2560x1440', '1920x1080' or '1600x900'",
                            self.window.get_resolution_str(),
                        )
                        return False
                    return True
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(description="Automate friction brake.")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-r",
                        "--reset-key",
                        default="g",
                        type=str,
                        help="key to reset friction brake, g by default",
                        metavar="KEY",
                    )
                    parser.add_argument(
                        "-q",
                        "--quit-key",
                        default="h",
                        type=str,
                        help="key to quit the script, h by default",
                        metavar="KEY",
                    )
                    return parser
            
                def _on_release(self, key: keyboard.KeyCode) -> None:
                    """Handle exit and quit events.
            
                    :param key: The key that was released.
                    :type key: keyboard.KeyCode
                    """
                    keystroke = str(key).lower()
                    if keystroke == self.cfg.ARGS.QUIT_KEY:
                        self.friction_brake.monitor_process.terminate()
                        sys.exit()
                    if keystroke == self.cfg.ARGS.RESET_KEY:
                        self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)
            
                def _start(self):
                    """Start the friction brake automation process.
            
                    Begins the friction brake monitoring process and starts a keyboard listener
                    to handle control keys.
                    """
                    print(
                        f"Press {self.cfg.ARGS.RESET_KEY[1:-1]} to reset friction brake, "
                        f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
                    )
                    self.friction_brake.monitor_process.start()
                    with keyboard.Listener(on_release=self._on_release) as listener:
                        listener.join()
            
            
            def run_app_from_main():
                try:
                    FrictionBrakeApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    FrictionBrakeApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ calculate.py
            """Calculate the maximum friction brake you can use on your tackle.
            
            This module provides functionality to calculate the maximum friction brake and tension
            based on the reel's max drag, friction brake wear, leader's load capacity, and wear.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import sys
            
            from rich import print
            from rich.prompt import Prompt
            from rich.table import Table
            
            sys.path.append(".")
            from rf4s import utils
            
            BIAS = 1e-6
            
            
            def get_tackle_stats():
                """Get actual stats of reel and leader based on their wears.
            
                Prompts the user for input and calculates the true max drag and load capacity
                after accounting for wear.
            
                :return: A tuple containing the true max drag and true load capacity.
                :rtype: tuple[float, float]
                """
                prompts = (
                    "Reel's max drag (kg)",
                    "Reel's friction brake wear (%)",
                    "Leader's load capacity (kg)",
                    "Leader's wear (%)",
                )
            
                while True:
                    restart = False
                    stats = []
                    for prompt in prompts:
                        validated_input = get_validated_input(prompt)
                        if validated_input is None:
                            restart = True
                            break
                        stats.append(validated_input)
            
                    if restart:
                        continue
            
                    max_drag, friction_brake_wear, leader_load_capacity, leader_wear = stats
                    true_max_drag = max_drag * (100 - friction_brake_wear) / 100
                    true_load_capacity = leader_load_capacity * (100 - leader_wear) / 100
                    return true_max_drag, true_load_capacity
            
            
            def get_validated_input(prompt: str) -> float | None:
                """Get validated input from the user.
            
                Prompts the user for input and validates it. Supports quitting and restarting.
            
                :param prompt: The prompt message to display to the user.
                :type prompt: str
                :return: The validated input as a float, or None if the user chooses to restart.
                :rtype: float or None
                """
                while True:
                    user_input = Prompt.ask(prompt)
                    if user_input == "q":
                        print("Bye.")
                        sys.exit()
                    if user_input == "r":
                        return None
            
                    try:
                        return float(user_input)
                    except ValueError:
                        utils.print_error("Invalid input. Please enter a number.")
            
            
            def main():
                """Main function to run the friction brake calculation.
            
                Prompts the user for input, calculates the result, and displays them in a table.
                """
                print("Please enter your tackle's stats, type q to quit, r to restart:")
                while True:
                    max_drag, load_capacity = get_tackle_stats()
                    max_friction_brake = int(min(load_capacity * 30 / (max_drag + BIAS) - 1, 29))
                    max_tension = max_drag * max_friction_brake / 30
            
                    table = Table(
                        "Result",
                        title="Your tackle's real stats üé£",
                        show_header=False,
                        min_width=36,
                    )
                    table.add_row("Reel's true max drag", f"{max_drag:.2f} kg")
                    table.add_row("Leader's true load capacity", f"{load_capacity:.2f} kg")
                    table.add_row("Friction brake tension", f"{max_tension:.2f} kg")
                    table.add_row("Maximum friction brake to use", f"{max_friction_brake}")
                    print(table)
            
            
            def run_app_from_main():
                main()
            
            
            if __name__ == "__main__":
                main()
        üìÑ craft.py
            """Activate game window and start crafting things until running out of materials.
            
            This module automates the crafting process in Russian Fishing 4. It supports
            discarding crafted items, fast crafting mode, and a configurable crafting limit.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import random
            import sys
            from datetime import datetime
            from pathlib import Path
            from time import sleep
            
            import pyautogui as pag
            from pynput import keyboard
            
            sys.path.append(".")
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.result.result import CraftResult
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            CRAFT_DELAY = 4.0
            CRAFT_DELAY_3X = CRAFT_DELAY * 1
            LOOP_DELAY = 0.5
            LOOP_DELAY_3X = LOOP_DELAY * 3
            ROOT = Path(__file__).resolve().parents[1]
            
            logger = create_rich_logger()
            
            
            class CraftApp(ToolApp):
                """Main application class for automating crafting.
            
                This class manages the configuration, detection, and execution of the crafting
                process. It tracks the number of successful and failed crafts, as well as the
                total number of materials used.
                """
            
                def __init__(self):
                    """Initialize the application."""
                    super().__init__()
                    print_cfg(self.cfg.ARGS)
                    self.result = CraftResult()
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(description="Craft items automatically.")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-d",
                        "--discard",
                        action="store_true",
                        help="discard all the crafted items (for groundbaits)",
                    )
                    parser.add_argument(
                        "-f",
                        "--fast",
                        action="store_true",
                        help="disable delay randomization to speed up crafting",
                    )
                    parser.add_argument(
                        "-n",
                        "--craft-limit",
                        type=int,
                        default=-1,
                        help="number of items to craft, no limit by default",
                        metavar="LIMIT",
                    )
                    return parser
            
                def get_action_delays(self) -> tuple[float, float]:
                    """Get crafting and checking delays.
            
                    :return: Two delays in seconds
                    :rtype: tuple[float, float]
                    """
                    if self.cfg.ARGS.FAST:
                        return CRAFT_DELAY, LOOP_DELAY
                    return (
                        random.uniform(CRAFT_DELAY, CRAFT_DELAY_3X),
                        random.uniform(LOOP_DELAY, LOOP_DELAY_3X),
                    )
            
                def move_cursor_to_make_button(self) -> None:
                    """Move the cursor to the make button position.
            
                    This method uses the Detection class to find the position of the make button
                    and moves the cursor to that position.
                    """
                    make_button_position = self.detection.get_make_button_position()
                    if make_button_position is None:
                        logger.critical(
                            "Make button not found, please set the interface scale to "
                            "1x or move your mouse around"
                        )
                        self.window.activate_script_window()
                        safe_exit()
                    pag.moveTo(make_button_position)
            
                def craft_item(
                    self, craft_delay: float, accept_delay: float, accept_key: str
                ) -> None:
                    """Craft an item.
            
                    :param craft_delay: Delay in seconds before accepting the crafted item.
                    :type craft_delay: float
                    :param accept_delay: Delay in seconds after accepting the crafted item.
                    :type accept_delay: float
                    :param accept_key: Key to press after accepting the crafted item.
                    :type accept_key: str
                    """
                    logger.info("Crafting item")
                    pag.click()
                    sleep(craft_delay)
                    self.result.material += 1
                    while True:
                        if self.detection.is_operation_success():
                            logger.info("Crafting successed")
                            self.result.succes += 1
                            break
            
                        if self.detection.is_operation_failed():
                            logger.warning("Crafting failed")
                            self.result.fail += 1
                            break
                        sleep(LOOP_DELAY)
                    pag.press(accept_key)
                    sleep(accept_delay)
            
                def _start(self) -> None:
                    """Main loop for crafting items.
            
                    Executes the primary loop for crafting items until materials are exhausted or
                    the crafting limit is reached. Supports fast crafting mode and discarding items.
                    """
                    logger.warning("This might get you banned, use at your own risk")
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
                    random.seed(datetime.now().timestamp())
                    accept_key = "backspace" if self.cfg.ARGS.DISCARD else "space"
                    self.move_cursor_to_make_button()
                    while True:
                        if not self.detection.is_material_complete():
                            logger.critical("Running out of materials")
                            return
                        if self.result.succes == self.cfg.ARGS.CRAFT_LIMIT:
                            logger.info("Crafting limit reached")
                            return
                        self.craft_item(*self.get_action_delays(), accept_key)
            
            
            def run_app_from_main():
                try:
                    CraftApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    CraftApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ harvest.py
            """Script for automatic baits harvesting and hunger/comfort refill.
            
            This module provides functionality to automate the harvesting of baits and refilling
            of hunger and comfort in Russian Fishing 4. It includes options for power-saving
            mode and configurable check delays.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from pathlib import Path
            from time import sleep
            
            import pyautogui as pag
            from pynput import keyboard
            
            sys.path.append(".")
            
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.controller.timer import Timer
            from rf4s.result.result import HarvestResult
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            ROOT = Path(__file__).resolve().parents[1]
            DIG_DELAY = 5  # 4 + 1 s
            CHECK_DELAY = 0.5
            ANIMATION_DELAY = 0.5
            
            logger = create_rich_logger()
            
            
            class HarvestApp(ToolApp):
                """Main application class for automating bait harvesting and hunger/comfort refill.
            
                This class manages the configuration, detection, and execution of the harvesting
                and refill processes. It also handles power-saving mode and check delays.
            
                Attributes:
                    timer (Timer): Timer instance for managing cooldowns.
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    Loads configuration, parses command-line arguments, and sets up the game window,
                    detection, and timer instances.
                    """
                    super().__init__()
                    print_cfg(self.cfg.ARGS)
            
                    self.timer = Timer(self.cfg)
                    self.result = HarvestResult()
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(
                        description="Harvest baits and refill hunger/comfort automatically.",
                    )
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-r",
                        "--refill",
                        action="store_true",
                        help="refill hunger and comfort by consuming tea and carrot",
                    )
                    parser.add_argument(
                        "-s",
                        "--power-saving",
                        action="store_true",
                        help="open control panel between checks to reduce power consumption",
                    )
                    parser.add_argument(
                        "-n",
                        "--check-delay",
                        type=int,
                        default=32,
                        help="delay time between each checks, 32s by default",
                    )
                    return parser
            
                def harvest_baits(self) -> None:
                    """Harvest baits using shovel/spoon.
            
                    The digging tool should be pulled out before calling this method. Waits for
                    harvest success and presses the spacebar to complete the process.
                    """
                    logger.info("Harvesting baits")
                    pag.click()
                    sleep(DIG_DELAY)
                    while not self.detection.is_harvest_success():
                        sleep(CHECK_DELAY)
                    pag.press("space")
                    logger.info("Baits harvested succussfully")
                    sleep(ANIMATION_DELAY)
            
                def refill_player_stats(self) -> None:
                    """Refill player stats using tea and carrot."""
                    if not self.cfg.ARGS.REFILL:
                        return
            
                    logger.info("Refilling player stats")
                    # Comfort is affected by weather, add a check to avoid over drink
                    if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
                        self._use_item("tea")
                        self.result.tea += 1
            
                    if self.detection.is_hunger_low():
                        self._use_item("carrot")
                        self.result.carrot += 1
            
                def _use_item(self, item: str) -> None:
                    """Access an item by name using quick selection shortcut or menu.
            
                    :param item: The name of the item to access.
                    :type item: str
                    """
                    logger.info("Using item: %s", item)
                    key = str(self.cfg.KEY[item.upper()])
                    if key != "-1":  # Use shortcut
                        pag.press(key)
                    else:  # Open food menu
                        with pag.hold("t"):
                            sleep(ANIMATION_DELAY)
                            food_position = self.detection.get_food_position(item)
                            pag.moveTo(food_position)
                            pag.click()
                    sleep(ANIMATION_DELAY)
            
                def _start(self) -> None:
                    """Main loop for eating and harvesting.
            
                    Executes the primary loop for checking hunger/comfort levels, consuming food,
                    and harvesting baits. Supports power-saving mode and configurable check delays.
                    """
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
            
                    pag.press(str(self.cfg.KEY.DIGGING_TOOL))
                    sleep(3)
                    while True:
                        self.refill_player_stats()
                        if self.detection.is_energy_high():
                            self.harvest_baits()
                            self.result.bait += 1
                        else:
                            logger.info("Energy is not high enough")
            
                        if self.cfg.ARGS.POWER_SAVING:
                            pag.press("esc")
                            sleep(self.cfg.ARGS.CHECK_DELAY)
                            pag.press("esc")
                        else:
                            sleep(self.cfg.ARGS.CHECK_DELAY)
                        sleep(ANIMATION_DELAY)
            
            
            def run_app_from_main():
                try:
                    HarvestApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    HarvestApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ main.py
            """Main CLI for Russian Fishing 4 Script.
            
            This module provides the command-line interface and main execution logic
            for automating fishing in Russian Fishing 4. It handles configuration,
            argument parsing, window management, and fishing automation.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import shlex
            import smtplib
            import sys
            from argparse import ArgumentParser, Namespace
            from pathlib import Path
            from socket import gaierror
            
            from pynput import keyboard
            from rich import box, print
            from rich.panel import Panel
            from rich.style import Style
            from rich.table import Column, Table
            from yacs.config import CfgNode as CN
            
            sys.path.append(".")  # python -m module -> python file
            import auto_friction_brake
            import calculate
            import craft
            import harvest
            import move
            
            from rf4s import utils
            from rf4s.app.app import App
            from rf4s.config import config
            from rf4s.player import Player
            from rf4s.utils import create_rich_logger
            
            logger = create_rich_logger()
            
            ARGUMENTS = (
                ("R", "rainbow", "rainbow line meter for retrieval detection"),
                ("t", "tag", "keep only tagged fishes"),
                ("c", "coffee", "drink coffee if stamina is low during a fish fight"),
                ("a", "alcohol", "drink alcohol before keeping the fish"),
                ("r", "refill", "consume tea and carrot if hunger or comfort is low"),
                ("H", "harvest", "harvest baits before casting the rod"),
                ("L", "lure", "change current lure with a random one, mode: spin"),
                ("m", "mouse", "move mouse randomly before casting the rod"),
                ("P", "pause", "pause the script before casting the rod occasionally"),
                ("RC", "random-cast", "do a redundant rod cast randomly"),
                ("SC", "skip-cast", "skip the first rod cast"),
                ("l", "lift", "lift the tackle constantly during a fish fight"),
                ("e", "electro", "enable electric mode for Electro Raptor series reel"),
                ("FB", "friction-brake", "adjust friction brake automatically"),
                ("GR", "gear-ratio", "switch the gear ratio after the retrieval timed out"),
                ("b", "bite", "save a screenshot in screenshots/ before rod cast (for bite spot)"),
                ("s", "screenshot", "save a screenshot in screenshots/ after you caught a fish"),
                ("d", "data", "save fishing data in /logs"),
                ("E", "email", "send email noticication after the script stop"),
                ("M", "miaotixing", "send miaotixing notification after the script stop"),
                ("D", "discord", "send Discord notification after the script stop"),
                ("S", "shutdown", "shutdown computer after the script stop"),
                ("SO", "signout", "sign out instead of closing the game"),
                ("SR", "spod-rod", "recast spod rod"),
                ("DM", "dry-mix", "enable dry mix refill, mode: bottom"),
                ("GB", "groundbait", "enable groundbait refill, mode: bottom"),
                ("PVA", "pva", "enable pva refill, mode: bottom"),
            )
            
            LOGO = """
            ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
            ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
            ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë          ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
            ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù          ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"""
            GITHUB_LINK = "GitHub: https://github.com/dereklee0310/RussianFishing4Script"
            DISCORD_LINK = "Discord: https://discord.gg/BZQWQnAMbY"
            # https://patorjk.com/software/taag/#p=testall&f=3D-ASCII&t=RF4S%0A, ANSI Shadow
            
            ROOT = Path(__file__).resolve().parents[1]
            
            FEATURES = (
                "Fishing Bot",
                "Craft Items",
                "Harvest Baits",
                "Toggle Moving Forward",
                "Automate Friction Brake",
                "Calculate tackle's stats",
            )
            
            
            class RF4SApp(App):
                """Main application class for Russian Fishing 4 automation.
            
                This class orchestrates the entire automation process, from parsing command-line
                arguments to configuring the environment and executing the fishing routine.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments
                    args (Namespace): Parsed command-line arguments
                    window (Window): Game window controller instance
                    player (Player): Player instance for fishing automation
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    Loads configuration, parses command-line arguments, and sets up the environment.
                    """
                    super().__init__()
                    self.parser = self.create_parser()
                    # Parser will use the last occurence if the arguments are duplicated,
                    # so put argv at the end to overwrite launch options.
                    self.args = self.parser.parse_args(
                        shlex.split(self.cfg.SCRIPT.LAUNCH_OPTIONS) + sys.argv[1:]
                    )
                    if not self.is_args_valid(self.args):
                        utils.safe_exit()
                    self.cfg.merge_from_other_cfg(CN({"ARGS": config.dict_to_cfg(vars(self.args))}))
            
                def create_parser(self) -> ArgumentParser:
                    """Configure the argument parser with all supported command-line options.
            
                    :return: Configured ArgumentParser instance with all options and flags.
                    :rtype: ArgumentParser
                    """
                    parser = ArgumentParser(description="Start AFK script for Russian Fishing 4")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
            
                    for argument in ARGUMENTS:
                        flag1 = f"-{argument[0]}"
                        flag2 = f"--{argument[1]}"
                        help_message = argument[2]
                        parser.add_argument(flag1, flag2, action="store_true", help=help_message)
            
                    profile_selection_strategy = parser.add_mutually_exclusive_group()
                    profile_selection_strategy.add_argument(
                        "-p",
                        "--pid",
                        type=int,
                        help="id of the profile you want to use",
                        metavar="PID",
                    )
                    profile_selection_strategy.add_argument(
                        "-N",
                        "--pname",
                        type=str,
                        help="name of the profile you want to use",
                        metavar="PROFILE_NAME",
                    )
                    parser.add_argument(
                        "-n",
                        "--fishes-in-keepnet",
                        default=0,
                        type=int,
                        help="number of fishes in your keepnet, 0 by default",
                        metavar="FISH_COUNT",
                    )
                    parser.add_argument(
                        "-BT",
                        "--boat-ticket",
                        nargs="?",
                        const=5,
                        type=int,
                        choices=[1, 2, 3, 5],
                        help=("renew boat ticket, DURATION: 1, 2, 3 or 5, 5 by default"),
                        metavar="DURATION",
                    )
                    parser.add_argument(
                        "-T",
                        "--trolling",
                        nargs="?",
                        const="forward",
                        type=str,
                        choices=["forward", "left", "right"],
                        help=(
                            "enable trolling mode, DIRECTION: 'forward', 'left', or 'right', "
                            "'forward' by default"
                        ),
                        metavar="DIRECTION",
                    )
                    parser.add_argument(
                        "-BL",
                        "--broken-lure",
                        nargs="?",
                        const="replace",
                        type=str,
                        choices=["replace", "alarm"],
                        help=(
                            "replace broken lure, ACTION: 'replace' or 'alarm', "
                            "'replace' by default"
                        ),
                        metavar="ACTION",
                    )
                    return parser
            
                def is_args_valid(self, args: Namespace) -> bool:
                    """Validate provided command-line arguments.
            
                    :param args: Parsed command-line arguments to validate.
                    :type args: Namespace
                    :return: Whether the arguments are valid.
                    :rtype: bool
                    """
                    if not 0 <= args.fishes_in_keepnet < self.cfg.KEEPNET.CAPACITY:
                        logger.critical(
                            "Invalid number of fishes in keepnet: '%s'", args.fishes_in_keepnet
                        )
                        return False
            
                    if args.pid is not None and not self.is_pid_valid(str(args.pid)):
                        logger.critical("Invalid profile id: '%s'", args.pid)
                        return False
            
                    if args.pname is not None and args.pname not in self.cfg.PROFILE:
                        logger.critical("Invalid profile name: '%s'", args.pname)
                        return False
            
                    # boat_ticket_duration already checked by choices[...]
                    return True
            
                def is_pid_valid(self, pid: str) -> bool:
                    """Check if the profile ID is valid.
            
                    :param pid: Profile ID to validate.
                    :type pid: str
                    :return: Whether the profile ID is valid.
                    :rtype: bool
                    """
                    return pid.isdigit() and 0 <= int(pid) < len(self.cfg.PROFILE)
            
                def is_smtp_valid(self) -> bool:
                    """Verify SMTP server connection for email notifications.
            
                    Tests the connection to the configured SMTP server using stored
                    credentials if email notifications are enabled.
            
                    :return: Whether the SMTP configuration is valid or not needed.
                    :rtype: bool
                    """
                    if not self.cfg.ARGS.EMAIL or not self.cfg.SCRIPT.SMTP_VERIFICATION:
                        return True
            
                    logger.info("Verifying SMTP connection")
            
                    email = self.cfg.NOTIFICATION.EMAIL
                    password = self.cfg.NOTIFICATION.PASSWORD
                    smtp_server_name = self.cfg.NOTIFICATION.SMTP_SERVER
            
                    try:
                        with smtplib.SMTP_SSL(smtp_server_name, 465) as smtp_server:
                            smtp_server.login(email, password)
                    except smtplib.SMTPAuthenticationError:
                        logger.critical(
                            "Email address or app password not accepted,\n"
                            "please check your email address and password.\n"
                            "For Gmail users, please refer to\n"
                            "https://support.google.com/accounts/answer/185833\n"
                        )
                        return False
                    except (TimeoutError, gaierror):
                        logger.critical("Invalid SMTP Server or connection timed out")
                        return False
                    return True
            
                def is_discord_webhook_url_valid(self) -> bool:
                    if not self.cfg.ARGS.DISCORD:
                        return True
                    if not self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL:
                        logger.critical(
                            "Discord Webhook url is not set, see\n"
                            "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks"
                        )
                        return False
                    return True
            
                def is_images_valid(self) -> bool:
                    """Verify that all required image files exist for the selected language.
            
                    Compares files in the reference 'en' directory with those in the current
                    language directory and reports any missing files.
            
                    :return: Whether all required image files are present.
                    :rtype: bool
                    """
                    if not self.cfg.SCRIPT.IMAGE_VERIFICATION:
                        return True
            
                    logger.info("Verifying image files")
                    if self.cfg.SCRIPT.LANGUAGE == "en":
                        return True
                    logger.warning(
                        "Language '%s' is not fully supported, consider using EN version",
                        self.cfg.SCRIPT.LANGUAGE,
                    )
                    image_dir = ROOT / "static" / self.cfg.SCRIPT.LANGUAGE
                    try:
                        current_images = [f.name for f in image_dir.iterdir() if f.is_file()]
                    except FileNotFoundError:
                        logger.critical("Invalid language: '%s'", self.cfg.SCRIPT.LANGUAGE)
                        return False
                    template_dir = ROOT / "static" / "en"
                    target_images = [f.name for f in template_dir.iterdir() if f.is_file()]
                    missing_images = set(target_images) - set(current_images)
                    if len(missing_images) > 0:
                        logger.critical("Some images are missing, please add them manually")
                        table = Table(
                            # "Filename",
                            Column("Filename", style=Style(color="red")),
                            title="Missing Images",
                            box=box.DOUBLE,
                            show_header=False,
                        )
                        for filename in missing_images:
                            table.add_row(f"static/{self.cfg.SCRIPT.LANGUAGE}/{filename}")
                        print(table)
                        return False
                    return True
            
                def is_profile_valid(self, profile_name: str) -> bool:
                    """Check if a profile configuration is valid and complete.
            
                    :param profile_name: Name of the profile to validate.
                    :type profile_name: str
                    :return: Whether the profile is valid.
                    :rtype: bool
                    """
                    if profile_name not in self.cfg.PROFILE:
                        logger.critical("Invalid profile name: '%s'", profile_name)
                        return False
            
                    mode = self.cfg.PROFILE[profile_name].MODE
                    if mode.upper() not in self.cfg.PROFILE:
                        logger.critical("Invalid mode: '%s'", mode)
                        return False
            
                    expected_keys = set(self.cfg.PROFILE[mode.upper()])
                    actual_keys = set(self.cfg.PROFILE[profile_name])
            
                    invalid_keys = actual_keys - expected_keys
                    missing_keys = expected_keys - actual_keys
            
                    if invalid_keys or missing_keys:
                        for key in invalid_keys:
                            logger.warning("Invalid setting: '%s'", key)
                        for key in missing_keys:
                            logger.warning("Missing setting: '%s'", key)
                    return True
            
                def display_profiles(self) -> None:
                    """Display a table of available profiles for user selection.
            
                    Shows a formatted table with profile IDs and names.
                    """
                    table = Table(
                        "Profiles",
                        title="Select a profile to start ‚öôÔ∏è",
                        show_header=False,
                        min_width=36,
                    )
                    for i, profile in enumerate(self.cfg.PROFILE):
                        table.add_row(f"{i:>2}. {profile}")
                    print(table)
            
                def get_pid(self) -> None:
                    """Prompt the user to enter a profile ID and validate the input.
            
                    Continuously prompts until a valid profile ID is entered or the
                    user chooses to quit.
                    """
                    print("Enter profile id to use, h to see help message, q to quit:")
            
                    while True:
                        user_input = input(">>> ")
                        if self.is_pid_valid(user_input):
                            break
                        if user_input == "q":
                            print("Bye.")
                            sys.exit()
                        if user_input == "h":
                            self.parser.print_help()
                            continue
                        utils.print_error("Invalid profile id, please try again.")
            
                    self.cfg.ARGS.PID = int(user_input)
            
                def create_user_profile(self) -> None:
                    """Configure the user profile based on arguments or interactive selection.
            
                    Selects a profile based on command-line arguments or user input,
                    validates the profile, and merges it with the configuration.
                    """
                    if self.cfg.ARGS.PNAME is not None:
                        profile_name = self.cfg.ARGS.PNAME
                    else:
                        if self.cfg.ARGS.PID is None:
                            self.display_profiles()
                            self.get_pid()
                        profile_name = list(self.cfg.PROFILE)[self.cfg.ARGS.PID]
            
                    if not self.is_profile_valid(profile_name):
                        utils.safe_exit()
            
                    # Merge args.opts here because we can only overwrite cfg.SELECTED
                    # after it's constructed using profile id or name.
                    # Process list-like values if possible
                    if "KEY.BOTTOM_RODS" in self.args.opts:
                        value_idx = self.args.opts.index("KEY.BOTTOM_RODS") + 1
                        self.args.opts[value_idx] = [
                            x.strip() for x in self.args.opts[value_idx].split(",")
                        ]
                    self.cfg.merge_from_list(self.args.opts)
            
                    mode = self.cfg.PROFILE[profile_name].MODE.upper()
                    self.cfg.SELECTED = CN({"NAME": profile_name}, new_allowed=True)
                    self.cfg.SELECTED.merge_from_other_cfg(self.cfg.PROFILE[mode])
                    self.cfg.SELECTED.merge_from_other_cfg(self.cfg.PROFILE[profile_name])
            
                    if (
                        hasattr(self.cfg.SELECTED, "LAUNCH_OPTIONS")
                        and self.cfg.SELECTED.LAUNCH_OPTIONS
                    ):  # Overwrite
                        args_list = shlex.split(self.cfg.SELECTED.LAUNCH_OPTIONS) + sys.argv[1:]
                        self.args = self.parser.parse_args(args_list)
                        self.cfg.ARGS = config.dict_to_cfg(vars(self.args))
            
                    # Check here because config might got overwritten
                    if (
                        not self.is_smtp_valid()
                        or not self.is_images_valid()
                        or not self.is_discord_webhook_url_valid()
                    ):
                        utils.safe_exit()
                    config.print_cfg(self.cfg.ARGS)
                    config.print_cfg(self.cfg.SELECTED)
            
                def is_window_valid(self) -> None:
                    """Set up and validate the game window.
            
                    Creates a Window object, checks if the window size is supported,
                    and disables incompatible features if needed.
                    """
                    if self.window.is_title_bar_exist():
                        logger.info("Window mode detected. Please don't move the game window")
                    if not self.window.is_size_supported():
                        logger.warning('Window mode must be "Borderless windowed" or "Window mode"')
                        logger.warning(
                            "Unsupported window size '%s', "
                            "use '2560x1440', '1920x1080' or '1600x900'",
                            self.window.get_resolution_str(),
                        )
                        logger.error(
                            "Snag detection will be disabled\n"
                            "Spooling detection will be disabled\n"
                            "Auto friction brake will be disabled\n"
                        )
            
                        self.cfg.ARGS.FRICTION_BRAKE = False
                        self.cfg.SCRIPT.SNAG_DETECTION = False
                        self.cfg.SCRIPT.SPOOLING_DETECTION = False
            
                    if (
                        self.cfg.SELECTED.MODE in ("telescopic", "bolognese")
                        and not self.window.is_size_supported()
                    ):
                        logger.critical(
                            "Fishing mode '%s' doesn't support window size '%s'",
                            self.cfg.SELECTED.MODE,
                            self.window.get_resolution_str(),
                        )
                        return False
                    return True
            
                def is_electro_valid(self):
                    """Display helpful information about the current configuration.
            
                    Checks configuration compatibility and prints warnings for
                    potential issues.
                    """
                    if not self.cfg.ARGS.ELECTRO:
                        return True
            
                    if self.cfg.SELECTED.MODE in ("pirk", "elevator"):
                        logger.info(
                            "Electric mode is enabled, make sure you're using Electro Raptor"
                        )
                    else:
                        logger.error(
                            "Electric mode is not compatible with mode '%s'"
                            "Electric mode will be disabled",
                            self.cfg.SELECTED.MODE,
                        )
                        self.cfg.ARGS.ELECTRO = False
                    return True
            
                def _start(self) -> None:
                    """Entry point."""
                    self.player = Player(self.cfg, self.window)
                    self.player.start_fishing()
            
                def start(self) -> None:
                    """Start the fishing automation process.
            
                    Sets up all required components, activates the game window,
                    registers key listeners, and begins the fishing automation.
                    Handles termination and displays result.
                    """
                    self.create_user_profile()
                    if not self.is_window_valid() or not self.is_electro_valid():
                        utils.safe_exit()
                    self.cfg.freeze()
            
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
                    self.window.activate_game_window()
                    try:
                        self._start()
                    except KeyboardInterrupt:
                        pass
            
                    self.display_result()
                    if self.cfg.ARGS.DATA:
                        self.player.timer.plot_and_save()
            
                def display_result(self):
                    print(
                        self.player.build_result_table(
                            self.player.build_result_dict("Terminated by user")
                        )
                    )
            
            
            def display_features() -> None:
                """Display a table of available features for user selection.
            
                Shows a formatted table with feature IDs and names.
                """
                table = Table(
                    "Features",
                    title="Select a feature to start üöÄ",
                    show_header=False,
                    min_width=36,
                )
            
                for i, feature in enumerate(FEATURES):
                    table.add_row(f"{i:>2}. {feature}")
                print(table)
            
            
            def get_pid() -> None:
                """Prompt the user to enter a profile ID and validate the input.
            
                Continuously prompts until a valid profile ID is entered or the
                user chooses to quit.
                """
                # print("Enter profile id to use, h to see help message, q to quit:")
                print("Enter feature id to use, q to quit:")
            
                while True:
                    user_input = input(">>> ")
                    if user_input.isdigit() and 0 <= int(user_input) < len(FEATURES):
                        break
                    if user_input == "q":
                        print("Bye.")
                        sys.exit()
                    utils.print_error("Invalid feature id, please try again.")
            
                return int(user_input)
            
            
            if __name__ == "__main__":
                print(Panel.fit(LOGO, box=box.HEAVY), GITHUB_LINK, DISCORD_LINK, sep="\n")
                utils.update_argv()
                display_features()
                match get_pid():
                    case 0:
                        try:
                            RF4SApp().start()
                        except Exception as e:
                            logger.critical(e, exc_info=True)
                        utils.safe_exit()
                    case 1:
                        craft.run_app_from_main()
                    case 2:
                        harvest.run_app_from_main()
                    case 3:
                        move.run_app_from_main()
                    case 4:
                        auto_friction_brake.run_app_from_main()
                    case 5:
                        calculate.run_app_from_main()
        üìÑ move.py
            """Movement automation for Russian Fishing 4 using keyboard controls.
            
            This module automates character movement in Russian Fishing 4 by simulating W key presses.
            Supports toggling movement state and includes optional Shift key integration for sprinting.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from pathlib import Path
            
            import pyautogui as pag
            from pynput import keyboard
            from rich import print
            
            sys.path.append(".")
            from rf4s import utils
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            ROOT = Path(__file__).resolve().parents[1]
            
            logger = create_rich_logger()
            
            
            class MoveApp(ToolApp):
                """Main controller for movement automation in Russian Fishing 4.
            
                Manages configuration, keyboard event listeners, and W/Shift key simulation.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
                    w_key_pressed (bool): Tracks current state of W key simulation.
                """
            
                def __init__(self):
                    """Initialize configuration, CLI arguments, and game window.
            
                    1. Format keybinds in cfg node.
                    2. Create w key flag.
                    """
                    super().__init__()
            
                    # Format key
                    self.cfg.defrost()
                    self.cfg.ARGS.PAUSE_KEY = f"'{self.cfg.ARGS.PAUSE_KEY}'"
                    self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
                    self.cfg.freeze()
                    print_cfg(self.cfg.ARGS)
            
                    self.w_key_pressed = True
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(
                        description="Moving the game character forward with W key."
                    )
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-s", "--shift", action="store_true", help="Hold Shift key while moving"
                    )
                    parser.add_argument(
                        "-p",
                        "--pause-key",
                        default="w",
                        type=str,
                        help="key to pause the script, w by default",
                        metavar="KEY",
                    )
                    parser.add_argument(
                        "-q",
                        "--quit-key",
                        default="s",
                        type=str,
                        help="key to quit the script, s by default",
                        metavar="KEY",
                    )
                    return parser
            
                def _on_release(self, key: keyboard.KeyCode) -> None:
                    """Handle keyboard release events for script control.
            
                    :param key: Key released by the user.
                    :type key: keyboard.KeyCode
                    """
                    if str(key).lower() == self.cfg.ARGS.QUIT_KEY:
                        sys.exit()
                    elif str(key).lower() == self.cfg.ARGS.PAUSE_KEY:
                        if self.w_key_pressed:
                            self.w_key_pressed = False
                            return
                        pag.keyDown("w")
                        self.w_key_pressed = True
            
                @utils.release_keys_after(arrow_keys=True)
                def _start(self) -> None:
                    """Start W key automation and keyboard listener."""
                    print(
                        f"Press {self.cfg.ARGS.PAUSE_KEY[1:-1]} to pause, "
                        f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
                    )
                    if self.cfg.ARGS.SHIFT:
                        pag.keyDown("shift")
                    pag.keyDown("w")
                    # Blocking listener loop
                    with keyboard.Listener(on_release=self._on_release) as listener:
                        listener.join()
            
            
            def run_app_from_main():
                try:
                    MoveApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    MoveApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÅ __pycache__/
            üìÑ auto_friction_brake.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ calculate.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ craft.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ harvest.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ move.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]