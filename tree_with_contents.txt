üìÅ ./
    üìÑ .gitignore
        # Byte-compiled / optimized / DLL files
        __pycache__/
        *.py[cod]
        *$py.class
        
        # C extensions
        *.so
        
        # Distribution / packaging
        .Python
        build/
        develop-eggs/
        dist/
        downloads/
        eggs/
        .eggs/
        lib/
        lib64/
        parts/
        sdist/
        var/
        wheels/
        pip-wheel-metadata/
        share/python-wheels/
        *.egg-info/
        .installed.cfg
        *.egg
        MANIFEST
        
        # PyInstaller
        *.manifest
        *.spec
        
        # Installer logs
        pip-log.txt
        pip-delete-this-directory.txt
        
        # Unit test / coverage reports
        htmlcov/
        .tox/
        .nox/
        .coverage
        .coverage.*
        .cache
        nosetests.xml
        coverage.xml
        *.cover
        *.py,cover
        .hypothesis/
        .pytest_cache/
        
        # Translations
        *.mo
        *.pot
        
        # Django stuff:
        *.log
        local_settings.py
        db.sqlite3
        db.sqlite3-journal
        
        # Flask stuff:
        instance/
        .webassets-cache
        
        # Scrapy stuff:
        .scrapy
        
        # Sphinx documentation
        docs/_build/
        
        # PyBuilder
        target/
        
        # Jupyter Notebook
        .ipynb_checkpoints
        
        # IPython
        profile_default/
        ipython_config.py
        
        # pyenv
        .python-version
        
        # pipenv
        Pipfile.lock
        
        # PEP 582
        __pypackages__/
        
        # Celery stuff
        celerybeat-schedule
        celerybeat.pid
        
        # SageMath parsed files
        *.sage.py
        
        # Environments
        .env
        .venv
        env/
        venv/
        ENV/
        env.bak/
        venv.bak/
        
        # Spyder project settings
        .spyderproject
        .spyproject
        
        # Rope project settings
        .ropeproject
        
        # mkdocs documentation
        /site
        
        # mypy
        .mypy_cache/
        .dmypy.json
        dmypy.json
        
        # Pyre type checker
        .pyre/
        
        # Russian Fishing 4 Bot specific
        config.yaml
        config.yaml.backup
        logs/
        screenshots/
        data/
        *.exe
        *.zip
        
        # IDE
        .vscode/
        .idea/
        *.swp
        *.swo
        *~
        
        # OS
        .DS_Store
        .DS_Store?
        ._*
        .Spotlight-V100
        .Trashes
        ehthumbs.db
        Thumbs.db
    üìÑ config.yaml
        VERSION: 0.5.2
        SCRIPT:
          LANGUAGE: en
          LAUNCH_OPTIONS: ''
          SMTP_VERIFICATION: false
          IMAGE_VERIFICATION: false
          SNAG_DETECTION: false
          SPOOLING_DETECTION: false
          RANDOM_ROD_SELECTION: false
          SPOOL_CONFIDENCE: 0.98
          SPOD_ROD_RECAST_DELAY: 1800
          LURE_CHANGE_DELAY: 1800
          ALARM_SOUND: ./static/sound/guitar.wav
          RANDOM_CAST_PROBABILITY: 0.25
          SCREENSHOT_TAGS:
          - green
          - yellow
          - blue
          - purple
          - pink
        KEY:
          TEA: -1
          CARROT: -1
          BOTTOM_RODS:
          - 1
          - 2
          - 3
          COFFEE: -1
          DIGGING_TOOL: 5
          ALCOHOL: 6
          MAIN_ROD: 1  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –±—ã–ª–æ -1, —Ç–µ–ø–µ—Ä—å 1
          SPOD_ROD: 7
          QUIT: CTRL-C
        STAT:
          ENERGY_THRESHOLD: 0.74
          HUNGER_THRESHOLD: 0.5
          COMFORT_THRESHOLD: 0.51
          TEA_DELAY: 300
          COFFEE_LIMIT: 10
          COFFEE_PER_DRINK: 1
          ALCOHOL_DELAY: 900
          ALCOHOL_PER_DRINK: 1
        FRICTION_BRAKE:
          INITIAL: 29
          MAX: 30
          START_DELAY: 2.0
          INCREASE_DELAY: 1.0
          SENSITIVITY: medium
        KEEPNET:
          CAPACITY: 100
          FISH_DELAY: 0.0
          GIFT_DELAY: 4.0
          FULL_ACTION: quit
          WHITELIST:
          - mackerel
          - saithe
          - herring
          - squid
          - scallop
          - mussel
          BLACKLIST: []
          TAGS:
          - green
          - yellow
          - blue
          - purple
          - pink
        NOTIFICATION:
          EMAIL: ''
          PASSWORD: ''
          SMTP_SERVER: ''
          MIAO_CODE: ''
          DISCORD_WEBHOOK_URL: ''  # –û—á–∏—â–µ–Ω–æ –∏–∑ —Å–æ–æ–±—Ä–∞–∂–µ–Ω–∏–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        PAUSE:
          DELAY: 1800
          DURATION: 600
        PROFILE:
          SPIN:
            MODE: spin
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 6.0
            POST_ACCELERATION: 'off'
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 0.0
            RETRIEVAL_DELAY: 0.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            TYPE: normal
          SPIN_WITH_PAUSE:
            MODE: spin
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 6.0
            TIGHTEN_DURATION: 1.0
            RETRIEVAL_DURATION: 1.0
            RETRIEVAL_DELAY: 3.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: 'off'
            TYPE: pause
          SPIN_WITH_LIFT:
            MODE: spin
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 6.0
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 1.0
            RETRIEVAL_DELAY: 1.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: 'off'
            TYPE: lift
          BOTTOM:
            MODE: bottom
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            POST_ACCELERATION: 'off'
            CHECK_DELAY: 32.0
            CHECK_MISS_LIMIT: 16
            PUT_DOWN_DELAY: 0.0
          PIRK:
            MODE: pirk
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 4.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: false
            SHIFT: false
            PIRK_DURATION: 0.5
            PIRK_DELAY: 2.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          PIRK_WITH_RETRIEVAL:
            MODE: pirk
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 0.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: false
            SHIFT: false
            PIRK_DURATION: 0.5
            PIRK_DELAY: 2.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: true
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          WAKEY_RIG:
            MODE: pirk
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 45.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 4.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: true
            SHIFT: false
            PIRK_DURATION: 1.5
            PIRK_DELAY: 4.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          ELEVATOR:
            MODE: elevator
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            ELEVATE_DURATION: 4.0
            ELEVATE_DELAY: 4.0
            ELEVATE_TIMEOUT: 40.0
            DROP: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          ELEVATOR_WITH_DROP:
            MODE: elevator
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            ELEVATE_DURATION: 4.0
            ELEVATE_DELAY: 4.0
            ELEVATE_TIMEOUT: 40.0
            DROP: true
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          TELESCOPIC:
            MODE: telescopic
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            FLOAT_SENSITIVITY: 0.68
            CHECK_DELAY: 1.0
            PULL_DELAY: 0.5
            DRIFT_TIMEOUT: 16.0
            CAMERA_SHAPE: square
          BOLOGNESE:
            MODE: bolognese
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            FLOAT_SENSITIVITY: 0.68
            CHECK_DELAY: 1.0
            PULL_DELAY: 0.5
            DRIFT_TIMEOUT: 32.0
            CAMERA_SHAPE: square
            POST_ACCELERATION: 'off'
    üìÑ config.yaml.backup
        VERSION: 0.5.2
        SCRIPT:
          LANGUAGE: en
          LAUNCH_OPTIONS: ''
          SMTP_VERIFICATION: false
          IMAGE_VERIFICATION: false
          SNAG_DETECTION: false
          SPOOLING_DETECTION: false
          RANDOM_ROD_SELECTION: false
          SPOOL_CONFIDENCE: 0.98
          SPOD_ROD_RECAST_DELAY: 1800
          LURE_CHANGE_DELAY: 1800
          ALARM_SOUND: ./static/sound/guitar.wav
          RANDOM_CAST_PROBABILITY: 0.25
          SCREENSHOT_TAGS:
          - green
          - yellow
          - blue
          - purple
          - pink
        KEY:
          TEA: -1
          CARROT: -1
          BOTTOM_RODS:
          - 1
          - 2
          - 3
          COFFEE: -1
          DIGGING_TOOL: -1
          ALCOHOL: -1
          MAIN_ROD: -1
          SPOD_ROD: -1
          QUIT: CTRL-C
        STAT:
          ENERGY_THRESHOLD: 0.74
          HUNGER_THRESHOLD: 0.5
          COMFORT_THRESHOLD: 0.51
          TEA_DELAY: 300
          COFFEE_LIMIT: 10
          COFFEE_PER_DRINK: 1
          ALCOHOL_DELAY: 900
          ALCOHOL_PER_DRINK: 1
        FRICTION_BRAKE:
          INITIAL: 15
          MAX: 26
          START_DELAY: 0.01
          INCREASE_DELAY: 0.01
          SENSITIVITY: medium
        KEEPNET:
          CAPACITY: 100
          FISH_DELAY: 0.0
          GIFT_DELAY: 4.0
          FULL_ACTION: quit
          WHITELIST:
          - mackerel
          - saithe
          - herring
          - squid
          - scallop
          - mussel
          BLACKLIST: []
          TAGS:
          - green
          - yellow
          - blue
          - purple
          - pink
        NOTIFICATION:
          EMAIL: ''
          PASSWORD: ''
          SMTP_SERVER: ''
          MIAO_CODE: ''
          DISCORD_WEBHOOK_URL: https://discord.com/api/webhooks/1381306998586343637/t-6xkZiqrACMLSs_DhzE_p9dPAG-sVhUzN_bXqnf7SukxpRhNxL6jS8QfRKySoeKhgeJ
        PAUSE:
          DELAY: 1800
          DURATION: 600
        PROFILE:
          SPIN:
            MODE: spin
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 6.0
            POST_ACCELERATION: 'off'
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 0.0
            RETRIEVAL_DELAY: 0.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            TYPE: normal
          SPIN_WITH_PAUSE:
            MODE: spin
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 6.0
            TIGHTEN_DURATION: 1.0
            RETRIEVAL_DURATION: 1.0
            RETRIEVAL_DELAY: 3.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: 'off'
            TYPE: pause
          SPIN_WITH_LIFT:
            MODE: spin
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 6.0
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 1.0
            RETRIEVAL_DELAY: 1.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: 'off'
            TYPE: lift
          BOTTOM:
            MODE: bottom
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            POST_ACCELERATION: 'off'
            CHECK_DELAY: 32.0
            CHECK_MISS_LIMIT: 16
            PUT_DOWN_DELAY: 0.0
          PIRK:
            MODE: pirk
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 4.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: false
            SHIFT: false
            PIRK_DURATION: 0.5
            PIRK_DELAY: 2.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          PIRK_WITH_RETRIEVAL:
            MODE: pirk
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 0.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: false
            SHIFT: false
            PIRK_DURATION: 0.5
            PIRK_DELAY: 2.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: true
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          WAKEY_RIG:
            MODE: pirk
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 45.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 4.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: true
            SHIFT: false
            PIRK_DURATION: 1.5
            PIRK_DELAY: 4.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          ELEVATOR:
            MODE: elevator
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            ELEVATE_DURATION: 4.0
            ELEVATE_DELAY: 4.0
            ELEVATE_TIMEOUT: 40.0
            DROP: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          ELEVATOR_WITH_DROP:
            MODE: elevator
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            ELEVATE_DURATION: 4.0
            ELEVATE_DELAY: 4.0
            ELEVATE_TIMEOUT: 40.0
            DROP: true
            HOOK_DELAY: 0.5
            POST_ACCELERATION: auto
          TELESCOPIC:
            MODE: telescopic
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            FLOAT_SENSITIVITY: 0.68
            CHECK_DELAY: 1.0
            PULL_DELAY: 0.5
            DRIFT_TIMEOUT: 16.0
            CAMERA_SHAPE: square
          BOLOGNESE:
            MODE: bolognese
            LAUNCH_OPTIONS: ''
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            FLOAT_SENSITIVITY: 0.68
            CHECK_DELAY: 1.0
            PULL_DELAY: 0.5
            DRIFT_TIMEOUT: 32.0
            CAMERA_SHAPE: square
            POST_ACCELERATION: 'off'
    üìÑ config_manager.py
        """
        Configuration management for Russian Fishing 4 Script GUI
        Enhanced with better validation and error handling
        """
        
        import yaml
        import os
        from pathlib import Path
        from typing import Dict, Any, List, Tuple
        import copy
        import re
        from dotenv import load_dotenv
        
        
        class ConfigManager:
            """Manages configuration loading, saving, and validation with enhanced features."""
            
            def __init__(self):
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env —Ñ–∞–π–ª–∞
                load_dotenv()
                
                self.config = {}
                self.default_config = self._get_default_config()
                self.config_file_path = None
                
            def _get_default_config(self) -> Dict[str, Any]:
                """Get comprehensive default configuration structure."""
                return {
                    "VERSION": "0.5.2",
                    "SCRIPT": {
                        "LANGUAGE": "en",
                        "LAUNCH_OPTIONS": "",
                        "SMTP_VERIFICATION": True,
                        "IMAGE_VERIFICATION": True,
                        "SNAG_DETECTION": True,
                        "SPOOLING_DETECTION": True,
                        "RANDOM_ROD_SELECTION": True,
                        "SPOOL_CONFIDENCE": 0.98,
                        "SPOD_ROD_RECAST_DELAY": 1800,
                        "LURE_CHANGE_DELAY": 1800,
                        "ALARM_SOUND": "./static/sound/guitar.wav",
                        "RANDOM_CAST_PROBABILITY": 0.25,
                        "SCREENSHOT_TAGS": ["green", "yellow", "blue", "purple", "pink"]
                    },
                    "KEY": {
                        "TEA": -1,
                        "CARROT": -1,
                        "BOTTOM_RODS": [1, 2, 3],
                        "COFFEE": -1,
                        "DIGGING_TOOL": 5,
                        "ALCOHOL": 6,
                        "MAIN_ROD": 1,  # –ò–∑–º–µ–Ω–µ–Ω–æ —Å -1 –Ω–∞ 1 –∫–∞–∫ –±–∞–∑–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                        "SPOD_ROD": 7,
                        "QUIT": "CTRL-C"
                    },
                    "STAT": {
                        "ENERGY_THRESHOLD": 0.74,
                        "HUNGER_THRESHOLD": 0.5,
                        "COMFORT_THRESHOLD": 0.51,
                        "TEA_DELAY": 300,
                        "COFFEE_LIMIT": 10,
                        "COFFEE_PER_DRINK": 1,
                        "ALCOHOL_DELAY": 900,
                        "ALCOHOL_PER_DRINK": 1
                    },
                    "FRICTION_BRAKE": {
                        "INITIAL": 29,
                        "MAX": 30,
                        "START_DELAY": 2.0,
                        "INCREASE_DELAY": 1.0,
                        "SENSITIVITY": "medium"
                    },
                    "KEEPNET": {
                        "CAPACITY": 100,
                        "FISH_DELAY": 0.0,
                        "GIFT_DELAY": 4.0,
                        "FULL_ACTION": "quit",
                        "WHITELIST": ["mackerel", "saithe", "herring", "squid", "scallop", "mussel"],
                        "BLACKLIST": [],
                        "TAGS": ["green", "yellow", "blue", "purple", "pink"]
                    },
                    "NOTIFICATION": {
                        "EMAIL": os.getenv("EMAIL", ""),
                        "PASSWORD": os.getenv("EMAIL_PASSWORD", ""),
                        "SMTP_SERVER": os.getenv("SMTP_SERVER", "smtp.gmail.com"),
                        "MIAO_CODE": os.getenv("MIAO_CODE", ""),
                        "DISCORD_WEBHOOK_URL": os.getenv("DISCORD_WEBHOOK_URL", "")
                    },
                    "PAUSE": {
                        "DELAY": 1800,
                        "DURATION": 600
                    },
                    "PROFILE": {
                        "SPIN": {
                            "MODE": "spin",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 5.0,
                            "CAST_DELAY": 6.0,
                            "TIGHTEN_DURATION": 0.0,
                            "RETRIEVAL_DURATION": 0.0,
                            "RETRIEVAL_DELAY": 0.0,
                            "RETRIEVAL_TIMEOUT": 256.0,
                            "PRE_ACCELERATION": False,
                            "POST_ACCELERATION": "off",
                            "TYPE": "normal"
                        },
                        "SPIN_WITH_PAUSE": {
                            "MODE": "spin",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 5.0,
                            "CAST_DELAY": 6.0,
                            "TIGHTEN_DURATION": 1.0,
                            "RETRIEVAL_DURATION": 1.0,
                            "RETRIEVAL_DELAY": 3.0,
                            "RETRIEVAL_TIMEOUT": 256.0,
                            "PRE_ACCELERATION": False,
                            "POST_ACCELERATION": "off",
                            "TYPE": "pause"
                        },
                        "SPIN_WITH_LIFT": {
                            "MODE": "spin",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 5.0,
                            "CAST_DELAY": 6.0,
                            "TIGHTEN_DURATION": 0.0,
                            "RETRIEVAL_DURATION": 1.0,
                            "RETRIEVAL_DELAY": 1.0,
                            "RETRIEVAL_TIMEOUT": 256.0,
                            "PRE_ACCELERATION": False,
                            "POST_ACCELERATION": "off",
                            "TYPE": "lift"
                        },
                        "BOTTOM": {
                            "MODE": "bottom",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 5.0,
                            "CAST_DELAY": 4.0,
                            "POST_ACCELERATION": "off",
                            "CHECK_DELAY": 32.0,
                            "CHECK_MISS_LIMIT": 16,
                            "PUT_DOWN_DELAY": 0.0
                        },
                        "PIRK": {
                            "MODE": "pirk",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 1.0,
                            "CAST_DELAY": 4.0,
                            "SINK_TIMEOUT": 60.0,
                            "TIGHTEN_DURATION": 1.0,
                            "DEPTH_ADJUST_DELAY": 4.0,
                            "DEPTH_ADJUST_DURATION": 1.0,
                            "CTRL": False,
                            "SHIFT": False,
                            "PIRK_DURATION": 0.5,
                            "PIRK_DELAY": 2.0,
                            "PIRK_TIMEOUT": 32.0,
                            "PIRK_RETRIEVAL": False,
                            "HOOK_DELAY": 0.5,
                            "POST_ACCELERATION": "auto"
                        },
                        "PIRK_WITH_RETRIEVAL": {
                            "MODE": "pirk",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 1.0,
                            "CAST_DELAY": 4.0,
                            "SINK_TIMEOUT": 60.0,
                            "TIGHTEN_DURATION": 1.0,
                            "DEPTH_ADJUST_DELAY": 0.0,
                            "DEPTH_ADJUST_DURATION": 1.0,
                            "CTRL": False,
                            "SHIFT": False,
                            "PIRK_DURATION": 0.5,
                            "PIRK_DELAY": 2.0,
                            "PIRK_TIMEOUT": 32.0,
                            "PIRK_RETRIEVAL": True,
                            "HOOK_DELAY": 0.5,
                            "POST_ACCELERATION": "auto"
                        },
                        "WAKEY_RIG": {
                            "MODE": "pirk",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 1.0,
                            "CAST_DELAY": 4.0,
                            "SINK_TIMEOUT": 45.0,
                            "TIGHTEN_DURATION": 1.0,
                            "DEPTH_ADJUST_DELAY": 4.0,
                            "DEPTH_ADJUST_DURATION": 1.0,
                            "CTRL": True,
                            "SHIFT": False,
                            "PIRK_DURATION": 1.5,
                            "PIRK_DELAY": 4.0,
                            "PIRK_TIMEOUT": 32.0,
                            "PIRK_RETRIEVAL": False,
                            "HOOK_DELAY": 0.5,
                            "POST_ACCELERATION": "auto"
                        },
                        "ELEVATOR": {
                            "MODE": "elevator",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 1.0,
                            "CAST_DELAY": 4.0,
                            "SINK_TIMEOUT": 60.0,
                            "TIGHTEN_DURATION": 1.0,
                            "ELEVATE_DURATION": 4.0,
                            "ELEVATE_DELAY": 4.0,
                            "ELEVATE_TIMEOUT": 40.0,
                            "DROP": False,
                            "HOOK_DELAY": 0.5,
                            "POST_ACCELERATION": "auto"
                        },
                        "ELEVATOR_WITH_DROP": {
                            "MODE": "elevator",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 1.0,
                            "CAST_DELAY": 4.0,
                            "SINK_TIMEOUT": 60.0,
                            "TIGHTEN_DURATION": 1.0,
                            "ELEVATE_DURATION": 4.0,
                            "ELEVATE_DELAY": 4.0,
                            "ELEVATE_TIMEOUT": 40.0,
                            "DROP": True,
                            "HOOK_DELAY": 0.5,
                            "POST_ACCELERATION": "auto"
                        },
                        "TELESCOPIC": {
                            "MODE": "telescopic",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 5.0,
                            "CAST_DELAY": 4.0,
                            "FLOAT_SENSITIVITY": 0.68,
                            "CHECK_DELAY": 1.0,
                            "PULL_DELAY": 0.5,
                            "DRIFT_TIMEOUT": 16.0,
                            "CAMERA_SHAPE": "square"
                        },
                        "BOLOGNESE": {
                            "MODE": "bolognese",
                            "LAUNCH_OPTIONS": "",
                            "CAST_POWER_LEVEL": 5.0,
                            "CAST_DELAY": 4.0,
                            "FLOAT_SENSITIVITY": 0.68,
                            "CHECK_DELAY": 1.0,
                            "PULL_DELAY": 0.5,
                            "DRIFT_TIMEOUT": 32.0,
                            "CAMERA_SHAPE": "square",
                            "POST_ACCELERATION": "off"
                        }
                    }
                }
                
            def validate_startup_config(self) -> List[str]:
                """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º —Å–∫—Ä–∏–ø—Ç–∞."""
                errors = []
                
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—ã–µ –∫–ª—é—á–∏
                keys = self.config.get('KEY', {})
                if keys.get('MAIN_ROD', -1) == -1:
                    errors.append("MAIN_ROD –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω (–∑–Ω–∞—á–µ–Ω–∏–µ -1)")
                
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª–∏
                profiles = self.config.get('PROFILE', {})
                if not profiles:
                    errors.append("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è")
                
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–µ—Ä—Å–∏—é
                version = self.config.get('VERSION')
                if not version:
                    errors.append("–í–µ—Ä—Å–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–∞")
                
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞
                script = self.config.get('SCRIPT', {})
                if not isinstance(script.get('SPOOL_CONFIDENCE'), (int, float)):
                    errors.append("SPOOL_CONFIDENCE –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
                
                return errors
            
            def load_config(self, file_path: str) -> None:
                """Load configuration from YAML file with enhanced error handling."""
                try:
                    self.config_file_path = file_path
                    
                    if not os.path.exists(file_path):
                        raise FileNotFoundError(f"Configuration file not found: {file_path}")
                        
                    with open(file_path, 'r', encoding='utf-8') as f:
                        loaded_config = yaml.safe_load(f) or {}
                        
                    # Validate and merge with defaults
                    self.config = self._merge_with_defaults(loaded_config)
                    self._validate_config()
                    
                    # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –∑–∞–ø—É—Å–∫–∞
                    startup_errors = self.validate_startup_config()
                    if startup_errors:
                        print("‚ö†Ô∏è  –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:")
                        for error in startup_errors:
                            print(f"   - {error}")
                        print("–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å —ç—Ç–∏ –ø—Ä–æ–±–ª–µ–º—ã –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º —Å–∫—Ä–∏–ø—Ç–∞.")
                    
                except yaml.YAMLError as e:
                    raise Exception(f"Invalid YAML format in {file_path}: {str(e)}")
                except Exception as e:
                    raise Exception(f"Failed to load configuration from {file_path}: {str(e)}")
                    
            def save_config(self, file_path: str) -> None:
                """Save configuration to YAML file with backup."""
                try:
                    # Create backup if file exists
                    if os.path.exists(file_path):
                        backup_path = f"{file_path}.backup"
                        try:
                            import shutil
                            shutil.copy2(file_path, backup_path)
                        except Exception as e:
                            print(f"Warning: Could not create backup: {e}")
                            
                    # Ensure directory exists
                    os.makedirs(os.path.dirname(file_path) if os.path.dirname(file_path) else ".", exist_ok=True)
                    
                    # –û—á–∏—Å—Ç–∏—Ç—å —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
                    config_to_save = self._sanitize_config_for_save(self.config)
                    
                    # Save configuration
                    with open(file_path, 'w', encoding='utf-8') as f:
                        yaml.dump(
                            config_to_save, 
                            f, 
                            default_flow_style=False,
                            allow_unicode=True, 
                            sort_keys=False,
                            indent=2,
                            width=120
                        )
                        
                    self.config_file_path = file_path
                    
                except Exception as e:
                    raise Exception(f"Failed to save configuration to {file_path}: {str(e)}")
            
            def _sanitize_config_for_save(self, config: dict) -> dict:
                """–û—á–∏—Å—Ç–∏—Ç—å —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º."""
                sanitized = copy.deepcopy(config)
                
                # –û—á–∏—Å—Ç–∏—Ç—å —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ NOTIFICATION
                if 'NOTIFICATION' in sanitized:
                    notification = sanitized['NOTIFICATION']
                    notification['EMAIL'] = ""
                    notification['PASSWORD'] = ""
                    notification['DISCORD_WEBHOOK_URL'] = ""
                    notification['MIAO_CODE'] = ""
                    
                return sanitized
                    
            def _merge_with_defaults(self, loaded_config: dict) -> dict:
                """Merge loaded config with defaults, preserving user settings."""
                def merge_dict(default, loaded):
                    result = default.copy()
                    for key, value in loaded.items():
                        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                            result[key] = merge_dict(result[key], value)
                        else:
                            result[key] = value
                    return result
                    
                return merge_dict(self.default_config, loaded_config)
                
            def reset_to_defaults(self) -> None:
                """Reset configuration to default values."""
                self.config = copy.deepcopy(self.default_config)
                
            def _validate_config(self) -> None:
                """Comprehensive configuration validation."""
                errors = []
                
                try:
                    # Validate script section
                    errors.extend(self._validate_script_section())
                    
                    # Validate key section
                    errors.extend(self._validate_key_section())
                    
                    # Validate stat section
                    errors.extend(self._validate_stat_section())
                    
                    # Validate profiles
                    errors.extend(self._validate_profiles())
                    
                    if errors:
                        print("Configuration validation warnings:")
                        for error in errors:
                            print(f"  - {error}")
                            
                except Exception as e:
                    print(f"Configuration validation error: {e}")
                    
            def _validate_script_section(self) -> List[str]:
                """Validate SCRIPT section."""
                errors = []
                script = self.config.get('SCRIPT', {})
                defaults = self.default_config['SCRIPT']
                
                # Language validation
                valid_languages = ['en', 'ru', 'zh-TW', 'zh-CN']
                if script.get('LANGUAGE') not in valid_languages:
                    script['LANGUAGE'] = defaults['LANGUAGE']
                    errors.append(f"Invalid language, reset to {defaults['LANGUAGE']}")
                    
                # Spool confidence range
                spool_conf = script.get('SPOOL_CONFIDENCE', defaults['SPOOL_CONFIDENCE'])
                if not isinstance(spool_conf, (int, float)) or not (0.0 <= spool_conf <= 1.0):
                    script['SPOOL_CONFIDENCE'] = defaults['SPOOL_CONFIDENCE']
                    errors.append("Invalid spool confidence, reset to default")
                    
                # Random cast probability range
                cast_prob = script.get('RANDOM_CAST_PROBABILITY', defaults['RANDOM_CAST_PROBABILITY'])
                if not isinstance(cast_prob, (int, float)) or not (0.0 <= cast_prob <= 1.0):
                    script['RANDOM_CAST_PROBABILITY'] = defaults['RANDOM_CAST_PROBABILITY']
                    errors.append("Invalid random cast probability, reset to default")
                    
                return errors
                
            def _validate_key_section(self) -> List[str]:
                """Validate KEY section."""
                errors = []
                keys = self.config.get('KEY', {})
                defaults = self.default_config['KEY']
                
                # Validate bottom rods
                bottom_rods = keys.get('BOTTOM_RODS', defaults['BOTTOM_RODS'])
                if not isinstance(bottom_rods, list) or not all(isinstance(x, int) for x in bottom_rods):
                    keys['BOTTOM_RODS'] = defaults['BOTTOM_RODS']
                    errors.append("Invalid bottom rods configuration, reset to default")
                    
                # Validate individual keys
                for key_name in ['TEA', 'CARROT', 'COFFEE', 'DIGGING_TOOL', 'ALCOHOL', 'MAIN_ROD', 'SPOD_ROD']:
                    value = keys.get(key_name, defaults[key_name])
                    if not isinstance(value, int) or value < -1:
                        keys[key_name] = defaults[key_name]
                        errors.append(f"Invalid {key_name} key, reset to default")
                        
                return errors
                
            def _validate_stat_section(self) -> List[str]:
                """Validate STAT section."""
                errors = []
                stat = self.config.get('STAT', {})
                defaults = self.default_config['STAT']
                
                # Validate threshold ranges (0.0 to 1.0)
                thresholds = ['ENERGY_THRESHOLD', 'HUNGER_THRESHOLD', 'COMFORT_THRESHOLD']
                for threshold in thresholds:
                    value = stat.get(threshold, defaults[threshold])
                    if not isinstance(value, (int, float)) or not (0.0 <= value <= 1.0):
                        stat[threshold] = defaults[threshold]
                        errors.append(f"Invalid {threshold}, reset to default")
                        
                # Validate delays (positive integers)
                delays = ['TEA_DELAY', 'ALCOHOL_DELAY']
                for delay in delays:
                    value = stat.get(delay, defaults[delay])
                    if not isinstance(value, int) or value < 0:
                        stat[delay] = defaults[delay]
                        errors.append(f"Invalid {delay}, reset to default")
                        
                return errors
                
            def _validate_profiles(self) -> List[str]:
                """Validate PROFILE section."""
                errors = []
                profiles = self.config.get('PROFILE', {})
                
                valid_modes = ['spin', 'bottom', 'pirk', 'elevator', 'telescopic', 'bolognese']
                valid_acceleration = ['on', 'off', 'auto']
                valid_spin_types = ['normal', 'pause', 'lift']
                
                for profile_name, profile_config in profiles.items():
                    if not isinstance(profile_config, dict):
                        continue
                        
                    # Validate mode
                    mode = profile_config.get('MODE')
                    if mode not in valid_modes:
                        errors.append(f"Profile {profile_name}: Invalid mode '{mode}'")
                        
                    # Validate cast power level
                    cast_power = profile_config.get('CAST_POWER_LEVEL')
                    if isinstance(cast_power, (int, float)) and not (1.0 <= cast_power <= 5.0):
                        errors.append(f"Profile {profile_name}: Cast power level should be 1.0-5.0")
                        
                    # Validate POST_ACCELERATION
                    post_acc = profile_config.get('POST_ACCELERATION')
                    if post_acc and post_acc not in valid_acceleration:
                        errors.append(f"Profile {profile_name}: Invalid POST_ACCELERATION value")
                        
                    # Validate spin-specific settings
                    if mode == 'spin':
                        spin_type = profile_config.get('TYPE')
                        if spin_type and spin_type not in valid_spin_types:
                            errors.append(f"Profile {profile_name}: Invalid spin TYPE value")
                            
                return errors
                
            def get_profile_list(self) -> List[str]:
                """Get list of available profiles."""
                return list(self.config.get('PROFILE', {}).keys())
                
            def get_profile_config(self, profile_name: str) -> dict:
                """Get configuration for specific profile."""
                profiles = self.config.get('PROFILE', {})
                return profiles.get(profile_name, {}).copy()
                
            def set_profile_config(self, profile_name: str, profile_config: dict) -> None:
                """Set configuration for specific profile."""
                if 'PROFILE' not in self.config:
                    self.config['PROFILE'] = {}
                self.config['PROFILE'][profile_name] = profile_config.copy()
                
            def validate_launch_options(self, options: str) -> Tuple[bool, List[str]]:
                """Validate launch options string and return invalid options."""
                valid_options = {
                    # Boolean flags
                    '-R', '--rainbow', '-t', '--tag', '-c', '--coffee', '-a', '--alcohol',
                    '-r', '--refill', '-H', '--harvest', '-L', '--lure', '-m', '--mouse',
                    '-P', '--pause', '-RC', '--random-cast', '-SC', '--skip-cast',
                    '-l', '--lift', '-e', '--electro', '-FB', '--friction-brake',
                    '-GR', '--gear-ratio', '-b', '--bite', '-s', '--screenshot',
                    '-d', '--data', '-E', '--email', '-M', '--miaotixing',
                    '-D', '--discord', '-S', '--shutdown', '-SO', '--signout',
                    '-SR', '--spod-rod', '-DM', '--dry-mix', '-GB', '--groundbait',
                    '-PVA', '--pva',
                    # Options with arguments
                    '-p', '--pid', '-N', '--pname', '-n', '--fishes-in-keepnet',
                    '-BT', '--boat-ticket', '-T', '--trolling', '-BL', '--broken-lure'
                }
                
                # Options that take arguments
                options_with_args = {
                    '-p', '--pid', '-N', '--pname', '-n', '--fishes-in-keepnet',
                    '-BT', '--boat-ticket', '-T', '--trolling', '-BL', '--broken-lure'
                }
                
                if not options.strip():
                    return True, []
                    
                try:
                    import shlex
                    parsed_options = shlex.split(options)
                except ValueError:
                    parsed_options = options.split()
                    
                invalid_options = []
                i = 0
                
                while i < len(parsed_options):
                    option = parsed_options[i]
                    
                    if option.startswith('-'):
                        if option in valid_options:
                            # If this option takes an argument, skip the next item
                            if option in options_with_args and i + 1 < len(parsed_options):
                                i += 1  # Skip the argument
                        else:
                            invalid_options.append(option)
                    else:
                        # This might be an argument to a previous option or an invalid standalone argument
                        if i == 0 or not parsed_options[i-1].startswith('-'):
                            invalid_options.append(option)
                            
                    i += 1
                    
                return len(invalid_options) == 0, invalid_options
                
            def export_config(self, file_path: str) -> None:
                """Export current configuration to specified file."""
                self.save_config(file_path)
                
            def import_config(self, file_path: str) -> None:
                """Import configuration from specified file."""
                self.load_config(file_path)
                
            def get_config_summary(self) -> dict:
                """Get a summary of current configuration."""
                summary = {
                    'version': self.config.get('VERSION', 'Unknown'),
                    'language': self.config.get('SCRIPT', {}).get('LANGUAGE', 'Unknown'),
                    'profiles_count': len(self.config.get('PROFILE', {})),
                    'profiles': list(self.config.get('PROFILE', {}).keys()),
                    'email_configured': bool(self.config.get('NOTIFICATION', {}).get('EMAIL')),
                    'discord_configured': bool(self.config.get('NOTIFICATION', {}).get('DISCORD_WEBHOOK_URL')),
                    'config_file': self.config_file_path or 'Not saved'
                }
                return summary
    üìÑ env.example
        # Discord webhook URL –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        DISCORD_WEBHOOK_URL=your_webhook_url_here
        
        # Email –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        EMAIL=your_email@example.com
        EMAIL_PASSWORD=your_app_password
        SMTP_SERVER=smtp.gmail.com
        
        # Miao Code –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        MIAO_CODE=your_miao_code_here
    üìÑ main_window.py
        """
        Modern PyQt6 GUI for Russian Fishing 4 Script
        –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä—É—Å—Å–∫–æ–≥–æ —è–∑—ã–∫–∞
        """
        
        import sys
        import os
        import subprocess
        from pathlib import Path
        from datetime import datetime
        from ui_theme import get_discord_theme
        from PyQt6.QtWidgets import (
            QApplication, QMainWindow, QTabWidget, QVBoxLayout, QHBoxLayout,
            QWidget, QLabel, QPushButton, QComboBox, QSpinBox, QDoubleSpinBox,
            QCheckBox, QLineEdit, QTextEdit, QGroupBox, QGridLayout, QScrollArea,
            QMessageBox, QFileDialog, QSplitter, QProgressBar, QStatusBar,
            QFrame, QInputDialog, QGraphicsDropShadowEffect
        )
        from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer, QSettings
        from PyQt6.QtGui import QFont, QIcon, QPixmap, QTextCursor, QColor
        
        try:
            from config_manager import ConfigManager
            from script_runner import ScriptRunner
        except ImportError:
            # Fallback classes if modules not available
            class ConfigManager:
                def __init__(self):
                    self.config = {}
                def load_config(self, path): pass
                def save_config(self, path): pass
                def reset_to_defaults(self): pass
                def get_profile_config(self, name): return {}
                def set_profile_config(self, name, config): pass
                def get_profile_list(self): return []
                def validate_launch_options(self, options): return True, []
            
            class ScriptRunner:
                def __init__(self):
                    pass
                output_received = pyqtSignal(str)
                error_received = pyqtSignal(str)
                finished = pyqtSignal(int)
                def start_script(self, options, profile): pass
                def stop_script(self): pass
                def validate_script_environment(self): return []
                def get_script_info(self): return []
                def _find_script_path(self): return True
        
        
        class Translations:
            """Manages interface translations with full Russian support."""
            
            def __init__(self):
                self.translations = {
                    "en": {
                        # Main window
                        "window_title": "üé£ Russian Fishing 4 Script ‚Ä¢ Modern UI",
                        "language": "Language:",
                        "load_config": "üìÅ Load",
                        "save_config": "üíæ Save", 
                        "reset_default": "üîÑ Reset",
                        
                        # Tabs
                        "script_settings": "‚öôÔ∏è Script Settings",
                        "key_bindings": "üéÆ Key Bindings",
                        "player_stats": "üìä Player Stats",
                        "fishing_profiles": "üé£ Fishing Profiles",
                        "friction_brake": "üîß Friction Brake",
                        "keepnet": "üóÉÔ∏è Keepnet",
                        "notifications": "üìß Notifications",
                        
                        # Script settings
                        "general_settings": "General Settings",
                        "detection_settings": "Detection Settings",
                        "advanced_settings": "Advanced Settings",
                        "script_language": "Script Language:",
                        "default_launch_options": "Default Launch Options:",
                        "smtp_verification": "SMTP Verification",
                        "image_verification": "Image Verification",
                        "snag_detection": "Snag Detection",
                        "spooling_detection": "Spooling Detection",
                        "random_rod_selection": "Random Rod Selection",
                        "spool_confidence": "Spool Confidence:",
                        "spod_recast_delay": "Spod Rod Recast Delay (sec):",
                        "lure_change_delay": "Lure Change Delay (sec):",
                        "random_cast_probability": "Random Cast Probability:",
                        
                        # Key bindings
                        "key_info": "Configure key bindings for game controls. Use -1 to open selection menu.",
                        "tea_key": "Tea Key",
                        "carrot_key": "Carrot Key", 
                        "coffee_key": "Coffee Key",
                        "digging_tool_key": "Digging Tool Key",
                        "alcohol_key": "Alcohol Key",
                        "main_rod_key": "Main Rod Key",
                        "spod_rod_key": "Spod Rod Key",
                        "bottom_rods": "Bottom Rods:",
                        "quit_key": "Quit Key:",
                        
                        # Player stats
                        "stat_info": "Configure thresholds and consumption settings for player stats.",
                        "stat_thresholds": "Stat Thresholds (0.0 - 1.0)",
                        "consumption_settings": "Consumption Settings",
                        "energy_threshold": "Energy Threshold:",
                        "hunger_threshold": "Hunger Threshold:",
                        "comfort_threshold": "Comfort Threshold:",
                        "tea_delay": "Tea Delay (seconds):",
                        "coffee_limit": "Coffee Limit:",
                        "coffee_per_drink": "Coffee Per Drink:",
                        "alcohol_delay": "Alcohol Delay (seconds):",
                        "alcohol_per_drink": "Alcohol Per Drink:",
                        
                        # Profiles
                        "profile_selection": "Profile Selection",
                        "current_profile": "Current Profile:",
                        "copy_profile": "Copy Profile",
                        "delete_profile": "Delete Profile",
                        
                        # Friction brake
                        "friction_info": "Configure automatic friction brake adjustment (use -FB flag to enable).",
                        "friction_settings": "Friction Brake Settings",
                        "initial_value": "Initial Value:",
                        "max_value": "Max Value:",
                        "start_delay": "Start Delay (sec):",
                        "increase_delay": "Increase Delay (sec):",
                        "sensitivity": "Sensitivity:",
                        
                        # Keepnet
                        "keepnet_info": "Configure keepnet settings for fish management.",
                        "basic_settings": "Basic Settings",
                        "fish_management": "Fish Management",
                        "capacity": "Capacity:",
                        "full_action": "Full Action:",
                        "fish_delay": "Fish Delay (sec):",
                        "gift_delay": "Gift Delay (sec):",
                        "keep_tags": "Keep Tags:",
                        "whitelist": "Whitelist:",
                        "blacklist": "Blacklist:",
                        
                        # Notifications
                        "notification_info": "Configure notifications for script events.",
                        "email_notifications": "Email Notifications (use -E flag)",
                        "discord_notifications": "Discord Notifications (use -D flag)",
                        "miaotixing_notifications": "Miaotixing Notifications (use -M flag)",
                        "email": "Email:",
                        "password": "Password:",
                        "smtp_server": "SMTP Server:",
                        "webhook_url": "Webhook URL:",
                        "miao_code": "Miao Code:",
                        
                        # Control panel
                        "quick_profile_selection": "üéØ Quick Profile Selection",
                        "launch_options": "üöÄ Launch Options",
                        "script_control": "üéÆ Script Control",
                        "start_script": "‚ñ∂Ô∏è Start Script",
                        "stop_script": "‚èπÔ∏è Stop Script",
                        "script_output": "üìù Script Output",
                        "clear": "üóëÔ∏è Clear",
                        "save_log": "üíæ Save Log",
                        "auto_scroll": "üîÑ Auto-scroll",
                        "fishes_in_keepnet": "üêü Fishes in keepnet:",
                        
                        # Launch options
                        "refill_stats": "üîÑ Refill stats",
                        "drink_coffee": "‚òï Drink coffee",
                        "harvest_baits": "üå± Harvest baits",
                        "keep_tagged_only": "üè∑Ô∏è Keep tagged only",
                        "save_screenshots": "üì∏ Save screenshots",
                        "save_data_logs": "üìä Save data logs",
                        "friction_brake": "üîß Friction brake",
                        "lift_tackle": "‚¨ÜÔ∏è Lift tackle",
                        
                        # Messages
                        "ready": "üü¢ Ready",
                        "config_loaded": "Configuration loaded successfully",
                        "config_saved": "Configuration saved successfully",
                        "script_running": "Script is running...",
                        "script_stopped": "Script stopped",
                        "script_completed": "Script completed successfully",
                        "profile_selected": "Profile selected",
                        "language_changed": "Language changed to",
                        "log_cleared": "Log cleared",
                        "log_saved": "Log saved to",
                        
                        # Status
                        "no_config": "üìÅ No config loaded",
                        "script_status_stopped": "‚èπÔ∏è Script: Stopped",
                        "script_status_running": "üü¢ Script: Running",
                        "script_status_completed": "‚úÖ Script: Completed",
                        "script_status_error": "‚ùå Script: Error",
                        
                        # Profiles
                        "spin_fishing": "Spin Fishing",
                        "bottom_fishing": "Bottom Fishing", 
                        "pirk_fishing": "Pirk Fishing",
                        "telescopic": "Telescopic",
                        
                        # Tooltips
                        "refill_tooltip": "Consume tea and carrot when needed",
                        "coffee_tooltip": "Drink coffee during fish fights",
                        "harvest_tooltip": "Harvest baits before casting",
                        "tagged_tooltip": "Keep only tagged fishes",
                        "screenshots_tooltip": "Save fish screenshots",
                        "data_tooltip": "Save detailed fishing data",
                        "friction_tooltip": "Auto adjust friction brake",
                        "lift_tooltip": "Lift tackle during fights",
                    },
                    "ru": {
                        # Main window
                        "window_title": "üé£ Russian Fishing 4 Script ‚Ä¢ –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å",
                        "language": "–Ø–∑—ã–∫:",
                        "load_config": "üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å",
                        "save_config": "üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
                        "reset_default": "üîÑ –°–±—Ä–æ—Å–∏—Ç—å",
                        
                        # Tabs
                        "script_settings": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞",
                        "key_bindings": "üéÆ –ü—Ä–∏–≤—è–∑–∫–∏ –∫–ª–∞–≤–∏—à",
                        "player_stats": "üìä –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞",
                        "fishing_profiles": "üé£ –ü—Ä–æ—Ñ–∏–ª–∏ —Ä—ã–±–∞–ª–∫–∏",
                        "friction_brake": "üîß –§—Ä–∏–∫—Ü–∏–æ–Ω–Ω—ã–π —Ç–æ—Ä–º–æ–∑",
                        "keepnet": "üóÉÔ∏è –°–∞–¥–æ–∫",
                        "notifications": "üìß –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è",
                        
                        # Script settings
                        "general_settings": "–û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
                        "detection_settings": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è",
                        "advanced_settings": "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
                        "script_language": "–Ø–∑—ã–∫ —Å–∫—Ä–∏–ø—Ç–∞:",
                        "default_launch_options": "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –æ–ø—Ü–∏–∏ –∑–∞–ø—É—Å–∫–∞:",
                        "smtp_verification": "SMTP –ø—Ä–æ–≤–µ—Ä–∫–∞",
                        "image_verification": "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π",
                        "snag_detection": "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∑–∞—Ü–µ–ø–æ–≤",
                        "spooling_detection": "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Å–º–∞—Ç—ã–≤–∞–Ω–∏—è",
                        "random_rod_selection": "–°–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä —É–¥–æ—á–∫–∏",
                        "spool_confidence": "–¢–æ—á–Ω–æ—Å—Ç—å —Å–º–∞—Ç—ã–≤–∞–Ω–∏—è:",
                        "spod_recast_delay": "–ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–∑–∞–±—Ä–æ—Å–∞ —Å–ø–æ–¥-—É–¥–æ—á–∫–∏ (—Å–µ–∫):",
                        "lure_change_delay": "–ó–∞–¥–µ—Ä–∂–∫–∞ —Å–º–µ–Ω—ã –ø—Ä–∏–º–∞–Ω–∫–∏ (—Å–µ–∫):",
                        "random_cast_probability": "–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∑–∞–±—Ä–æ—Å–∞:",
                        
                        # Key bindings
                        "key_info": "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø—Ä–∏–≤—è–∑–∫–∏ –∫–ª–∞–≤–∏—à –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–≥—Ä–æ–π. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –º–µ–Ω—é –≤—ã–±–æ—Ä–∞.",
                        "tea_key": "–ö–ª–∞–≤–∏—à–∞ —á–∞—è",
                        "carrot_key": "–ö–ª–∞–≤–∏—à–∞ –º–æ—Ä–∫–æ–≤–∏",
                        "coffee_key": "–ö–ª–∞–≤–∏—à–∞ –∫–æ—Ñ–µ",
                        "digging_tool_key": "–ö–ª–∞–≤–∏—à–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞",
                        "alcohol_key": "–ö–ª–∞–≤–∏—à–∞ –∞–ª–∫–æ–≥–æ–ª—è",
                        "main_rod_key": "–ö–ª–∞–≤–∏—à–∞ –æ—Å–Ω–æ–≤–Ω–æ–π —É–¥–æ—á–∫–∏",
                        "spod_rod_key": "–ö–ª–∞–≤–∏—à–∞ —Å–ø–æ–¥-—É–¥–æ—á–∫–∏",
                        "bottom_rods": "–î–æ–Ω–Ω—ã–µ —É–¥–æ—á–∫–∏:",
                        "quit_key": "–ö–ª–∞–≤–∏—à–∞ –≤—ã—Ö–æ–¥–∞:",
                        
                        # Player stats
                        "stat_info": "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–æ—Ä–æ–≥–∏ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è –¥–ª—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ –∏–≥—Ä–æ–∫–∞.",
                        "stat_thresholds": "–ü–æ—Ä–æ–≥–∏ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ (0.0 - 1.0)",
                        "consumption_settings": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è",
                        "energy_threshold": "–ü–æ—Ä–æ–≥ —ç–Ω–µ—Ä–≥–∏–∏:",
                        "hunger_threshold": "–ü–æ—Ä–æ–≥ –≥–æ–ª–æ–¥–∞:",
                        "comfort_threshold": "–ü–æ—Ä–æ–≥ –∫–æ–º—Ñ–æ—Ä—Ç–∞:",
                        "tea_delay": "–ó–∞–¥–µ—Ä–∂–∫–∞ —á–∞—è (—Å–µ–∫—É–Ω–¥—ã):",
                        "coffee_limit": "–õ–∏–º–∏—Ç –∫–æ—Ñ–µ:",
                        "coffee_per_drink": "–ö–æ—Ñ–µ –∑–∞ —Ä–∞–∑:",
                        "alcohol_delay": "–ó–∞–¥–µ—Ä–∂–∫–∞ –∞–ª–∫–æ–≥–æ–ª—è (—Å–µ–∫—É–Ω–¥—ã):",
                        "alcohol_per_drink": "–ê–ª–∫–æ–≥–æ–ª—å –∑–∞ —Ä–∞–∑:",
                        
                        # Profiles
                        "profile_selection": "–í—ã–±–æ—Ä –ø—Ä–æ—Ñ–∏–ª—è",
                        "current_profile": "–¢–µ–∫—É—â–∏–π –ø—Ä–æ—Ñ–∏–ª—å:",
                        "copy_profile": "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å",
                        "delete_profile": "–£–¥–∞–ª–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å",
                        
                        # Friction brake
                        "friction_info": "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–Ω—ã–π —Ç–æ—Ä–º–æ–∑ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–ª–∞–≥ -FB –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è).",
                        "friction_settings": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ç–æ—Ä–º–æ–∑–∞",
                        "initial_value": "–ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:",
                        "max_value": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:",
                        "start_delay": "–ù–∞—á–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ (—Å–µ–∫):",
                        "increase_delay": "–ó–∞–¥–µ—Ä–∂–∫–∞ —É–≤–µ–ª–∏—á–µ–Ω–∏—è (—Å–µ–∫):",
                        "sensitivity": "–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:",
                        
                        # Keepnet
                        "keepnet_info": "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∞–¥–∫–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä—ã–±–æ–π.",
                        "basic_settings": "–û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
                        "fish_management": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä—ã–±–æ–π",
                        "capacity": "–í–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:",
                        "full_action": "–î–µ–π—Å—Ç–≤–∏–µ –ø—Ä–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–∏:",
                        "fish_delay": "–ó–∞–¥–µ—Ä–∂–∫–∞ —Ä—ã–±—ã (—Å–µ–∫):",
                        "gift_delay": "–ó–∞–¥–µ—Ä–∂–∫–∞ –ø–æ–¥–∞—Ä–∫–∞ (—Å–µ–∫):",
                        "keep_tags": "–°–æ—Ö—Ä–∞–Ω—è—Ç—å –º–µ—Ç–∫–∏:",
                        "whitelist": "–ë–µ–ª—ã–π —Å–ø–∏—Å–æ–∫:",
                        "blacklist": "–ß—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫:",
                        
                        # Notifications
                        "notification_info": "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–æ–±—ã—Ç–∏—è—Ö —Å–∫—Ä–∏–ø—Ç–∞.",
                        "email_notifications": "Email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–ª–∞–≥ -E)",
                        "discord_notifications": "Discord —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–ª–∞–≥ -D)",
                        "miaotixing_notifications": "Miaotixing —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–ª–∞–≥ -M)",
                        "email": "Email:",
                        "password": "–ü–∞—Ä–æ–ª—å:",
                        "smtp_server": "SMTP —Å–µ—Ä–≤–µ—Ä:",
                        "webhook_url": "URL –≤–µ–±—Ö—É–∫–∞:",
                        "miao_code": "–ö–æ–¥ Miao:",
                        
                        # Control panel
                        "quick_profile_selection": "üéØ –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä –ø—Ä–æ—Ñ–∏–ª—è",
                        "launch_options": "üöÄ –û–ø—Ü–∏–∏ –∑–∞–ø—É—Å–∫–∞",
                        "script_control": "üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–æ–º",
                        "start_script": "‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–∫—Ä–∏–ø—Ç",
                        "stop_script": "‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–∫—Ä–∏–ø—Ç",
                        "script_output": "üìù –í—ã–≤–æ–¥ —Å–∫—Ä–∏–ø—Ç–∞",
                        "clear": "üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å",
                        "save_log": "üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ª–æ–≥",
                        "auto_scroll": "üîÑ –ê–≤—Ç–æ-–ø—Ä–æ–∫—Ä—É—Ç–∫–∞",
                        "fishes_in_keepnet": "üêü –†—ã–± –≤ —Å–∞–¥–∫–µ:",
                        
                        # Launch options
                        "refill_stats": "üîÑ –ü–æ–ø–æ–ª–Ω–∏—Ç—å —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏",
                        "drink_coffee": "‚òï –ü–∏—Ç—å –∫–æ—Ñ–µ",
                        "harvest_baits": "üå± –°–æ–±–∏—Ä–∞—Ç—å –Ω–∞–∂–∏–≤–∫—É",
                        "keep_tagged_only": "üè∑Ô∏è –¢–æ–ª—å–∫–æ —Å –º–µ—Ç–∫–∞–º–∏",
                        "save_screenshots": "üì∏ –°–æ—Ö—Ä–∞–Ω—è—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç—ã",
                        "save_data_logs": "üìä –°–æ—Ö—Ä–∞–Ω—è—Ç—å –¥–∞–Ω–Ω—ã–µ",
                        "friction_brake": "üîß –§—Ä–∏–∫—Ü–∏–æ–Ω–Ω—ã–π —Ç–æ—Ä–º–æ–∑",
                        "lift_tackle": "‚¨ÜÔ∏è –ü–æ–¥–Ω–∏–º–∞—Ç—å —Å–Ω–∞—Å—Ç—å",
                        
                        # Messages
                        "ready": "üü¢ –ì–æ—Ç–æ–≤",
                        "config_loaded": "–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ",
                        "config_saved": "–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ",
                        "script_running": "–°–∫—Ä–∏–ø—Ç –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è...",
                        "script_stopped": "–°–∫—Ä–∏–ø—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                        "script_completed": "–°–∫—Ä–∏–ø—Ç –∑–∞–≤–µ—Ä—à—ë–Ω —É—Å–ø–µ—à–Ω–æ",
                        "profile_selected": "–ü—Ä–æ—Ñ–∏–ª—å –≤—ã–±—Ä–∞–Ω",
                        "language_changed": "–Ø–∑—ã–∫ –∏–∑–º–µ–Ω—ë–Ω –Ω–∞",
                        "log_cleared": "–õ–æ–≥ –æ—á–∏—â–µ–Ω",
                        "log_saved": "–õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤",
                        
                        # Status
                        "no_config": "üìÅ –ö–æ–Ω—Ñ–∏–≥ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω",
                        "script_status_stopped": "‚èπÔ∏è –°–∫—Ä–∏–ø—Ç: –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                        "script_status_running": "üü¢ –°–∫—Ä–∏–ø—Ç: –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è",
                        "script_status_completed": "‚úÖ –°–∫—Ä–∏–ø—Ç: –ó–∞–≤–µ—Ä—à—ë–Ω",
                        "script_status_error": "‚ùå –°–∫—Ä–∏–ø—Ç: –û—à–∏–±–∫–∞",
                        
                        # Profiles
                        "spin_fishing": "–°–ø–∏–Ω–Ω–∏–Ω–≥",
                        "bottom_fishing": "–î–æ–Ω–Ω–∞—è —Ä—ã–±–∞–ª–∫–∞",
                        "pirk_fishing": "–ü–∏—Ä–∫",
                        "telescopic": "–¢–µ–ª–µ—Å–∫–æ–ø",
                        
                        # Tooltips
                        "refill_tooltip": "–ü–æ–ø–æ–ª–Ω—è—Ç—å —á–∞–π –∏ –º–æ—Ä–∫–æ–≤—å –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ",
                        "coffee_tooltip": "–ü–∏—Ç—å –∫–æ—Ñ–µ –≤–æ –≤—Ä–µ–º—è –±–æ—Ä—å–±—ã —Å —Ä—ã–±–æ–π",
                        "harvest_tooltip": "–°–æ–±–∏—Ä–∞—Ç—å –Ω–∞–∂–∏–≤–∫—É –ø–µ—Ä–µ–¥ –∑–∞–±—Ä–æ—Å–æ–º",
                        "tagged_tooltip": "–û—Å—Ç–∞–≤–ª—è—Ç—å —Ç–æ–ª—å–∫–æ —Ä—ã–±—É —Å –º–µ—Ç–∫–∞–º–∏",
                        "screenshots_tooltip": "–°–æ—Ö—Ä–∞–Ω—è—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç—ã —Ä—ã–±—ã",
                        "data_tooltip": "–°–æ—Ö—Ä–∞–Ω—è—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Ä—ã–±–∞–ª–∫–∏",
                        "friction_tooltip": "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞—Ç—å —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–Ω—ã–π —Ç–æ—Ä–º–æ–∑",
                        "lift_tooltip": "–ü–æ–¥–Ω–∏–º–∞—Ç—å —Å–Ω–∞—Å—Ç—å –≤–æ –≤—Ä–µ–º—è –±–æ—Ä—å–±—ã",
                    }
                }
                
            def get_text(self, key: str, language: str = "en") -> str:
                """Get translated text for key."""
                return self.translations.get(language, {}).get(key, key)
                
            def get_all_keys(self, language: str = "en") -> dict:
                """Get all translations for a language."""
                return self.translations.get(language, {})
        
        
        class ModernWindow(QMainWindow):
            """Modern GUI window with Discord-inspired design and Russian support."""
            
            def __init__(self):
                super().__init__()
                
                # Initialize translations first
                self.translations = Translations()
                
                # Initialize managers
                self.config_manager = ConfigManager()
                self.script_runner = ScriptRunner()
                
                # UI state
                self.current_language = "ru"  # Default to Russian
                self.script_process = None
                self.is_script_running = False
                
                # Settings
                self.settings = QSettings("RF4S", "ModernGUI")
                
                # Initialize UI
                self.setup_window()
                self.init_ui()
                self.apply_theme()
                self.load_config()
                self.connect_signals()
                self.load_window_state()
                
                # Update language after everything is created
                self.update_interface_language()
                
            def get_text(self, key: str) -> str:
                """Get translated text for current language."""
                return self.translations.get_text(key, self.current_language)
                
            def setup_window(self):
                """Setup main window properties."""
                self.setWindowTitle(self.get_text("window_title"))
                self.setGeometry(100, 100, 1500, 950)
                self.setMinimumSize(1200, 800)
                
            def apply_theme(self):
                """Apply Discord theme."""
                self.setStyleSheet(get_discord_theme())
                
                # Set custom properties for special styling
                if hasattr(self, 'toolbar_widget'):
                    self.toolbar_widget.setObjectName("toolbar_widget")
                    
                if hasattr(self, 'log_viewer'):
                    self.log_viewer.setObjectName("log_viewer")
            
            def init_ui(self):
                """Initialize the modern user interface."""
                # Central widget with modern layout
                central_widget = QWidget()
                self.setCentralWidget(central_widget)
                
                layout = QVBoxLayout(central_widget)
                layout.setContentsMargins(12, 8, 12, 8)
                layout.setSpacing(12)
                
                # Modern toolbar
                self.create_modern_toolbar(layout)
                
                # Modern separator
                separator = self.create_modern_separator()
                layout.addWidget(separator)
                
                # Main content with modern splitter
                splitter = QSplitter(Qt.Orientation.Horizontal)
                splitter.setChildrenCollapsible(False)
                layout.addWidget(splitter)
                
                # Left panel - Configuration tabs
                self.create_modern_tabs(splitter)
                
                # Right panel - Control and logs
                self.create_modern_control_panel(splitter)
                
                # Modern status bar
                self.create_modern_status_bar()
                
                # Set splitter proportions
                splitter.setSizes([950, 550])
                
            def create_modern_toolbar(self, layout):
                """Create modern toolbar."""
                self.toolbar_widget = QWidget()
                self.toolbar_widget.setObjectName("toolbar_widget")
                toolbar_layout = QHBoxLayout(self.toolbar_widget)
                toolbar_layout.setContentsMargins(16, 12, 16, 12)
                toolbar_layout.setSpacing(16)
                
                # App title with icon
                title_layout = QHBoxLayout()
                
                # App icon
                icon_label = QLabel("üé£")
                icon_label.setStyleSheet("font-size: 24px; margin-right: 8px;")
                title_layout.addWidget(icon_label)
                
                # App title
                self.title_label = QLabel("Russian Fishing 4 Script")
                self.title_label.setObjectName("title")
                self.title_label.setStyleSheet("""
                    QLabel#title {
                        font-size: 16pt;
                        font-weight: 700;
                        color: #ffffff;
                        margin: 0;
                    }
                """)
                title_layout.addWidget(self.title_label)
                
                # Version badge
                version_label = QLabel("v1.0")
                version_label.setStyleSheet("""
                    background-color: #5865f2;
                    color: white;
                    padding: 4px 8px;
                    border-radius: 12px;
                    font-size: 8pt;
                    font-weight: 600;
                    margin-left: 8px;
                """)
                title_layout.addWidget(version_label)
                
                toolbar_layout.addLayout(title_layout)
                toolbar_layout.addStretch()
                
                # Language selector
                lang_layout = QHBoxLayout()
                lang_layout.setSpacing(8)
                
                self.lang_label = QLabel(self.get_text("language"))
                self.lang_label.setStyleSheet("color: #b9bbbe; font-weight: 500;")
                self.language_combo = QComboBox()
                self.language_combo.addItems(["üá∑üá∫ –†—É—Å—Å–∫–∏–π", "üá∫üá∏ English"])
                self.language_combo.setCurrentText("üá∑üá∫ –†—É—Å—Å–∫–∏–π")
                self.language_combo.currentTextChanged.connect(self.change_language)
                
                lang_layout.addWidget(self.lang_label)
                lang_layout.addWidget(self.language_combo)
                
                toolbar_layout.addLayout(lang_layout)
                
                # Separator
                separator = QFrame()
                separator.setFrameShape(QFrame.Shape.VLine)
                separator.setStyleSheet("color: #4f545c; background-color: #4f545c; max-width: 1px;")
                toolbar_layout.addWidget(separator)
                
                # File operations
                self.load_button = self.create_modern_button(self.get_text("load_config"), "primary")
                self.save_button = self.create_modern_button(self.get_text("save_config"), "success")
                self.reset_button = self.create_modern_button(self.get_text("reset_default"), "danger")
                
                self.load_button.clicked.connect(self.load_config_file)
                self.save_button.clicked.connect(self.save_config_file)
                self.reset_button.clicked.connect(self.reset_config)
                
                file_layout = QHBoxLayout()
                file_layout.setSpacing(8)
                file_layout.addWidget(self.load_button)
                file_layout.addWidget(self.save_button)
                file_layout.addWidget(self.reset_button)
                
                toolbar_layout.addLayout(file_layout)
                
                layout.addWidget(self.toolbar_widget)
                
            def create_modern_button(self, text, style_type="default"):
                """Create a modern styled button."""
                button = QPushButton(text)
                button.setObjectName(style_type)
                
                if style_type == "primary":
                    button.setStyleSheet("""
                        QPushButton#primary {
                            background-color: #5865f2;
                            color: #ffffff;
                            border: none;
                            border-radius: 6px;
                            padding: 8px 16px;
                            font-weight: 600;
                            font-size: 9pt;
                        }
                        QPushButton#primary:hover {
                            background-color: #4752c4;
                        }
                    """)
                elif style_type == "success":
                    button.setStyleSheet("""
                        QPushButton#success {
                            background-color: #3ba55d;
                            color: #ffffff;
                            border: none;
                            border-radius: 6px;
                            padding: 8px 16px;
                            font-weight: 600;
                            font-size: 9pt;
                        }
                        QPushButton#success:hover {
                            background-color: #2d7d32;
                        }
                    """)
                elif style_type == "danger":
                    button.setStyleSheet("""
                        QPushButton#danger {
                            background-color: #ed4245;
                            color: #ffffff;
                            border: none;
                            border-radius: 6px;
                            padding: 8px 16px;
                            font-weight: 600;
                            font-size: 9pt;
                        }
                        QPushButton#danger:hover {
                            background-color: #c62828;
                        }
                    """)
                
                button.setCursor(Qt.CursorShape.PointingHandCursor)
                return button
                
            def create_modern_separator(self):
                """Create a modern separator line."""
                separator = QFrame()
                separator.setFrameShape(QFrame.Shape.HLine)
                separator.setFrameShadow(QFrame.Shadow.Sunken)
                separator.setStyleSheet("""
                    QFrame {
                        color: #4f545c;
                        background-color: #4f545c;
                        border: none;
                        max-height: 1px;
                        margin: 0 12px;
                    }
                """)
                return separator
                
            def create_modern_tabs(self, parent):
                """Create modern tabbed interface."""
                self.tab_widget = QTabWidget()
                parent.addWidget(self.tab_widget)
                
                # Create tabs
                self.tabs = [
                    ("script_settings", self.create_script_tab),
                    ("key_bindings", self.create_keys_tab),
                    ("player_stats", self.create_stats_tab),
                    ("fishing_profiles", self.create_profiles_tab),
                    ("friction_brake", self.create_friction_tab),
                    ("keepnet", self.create_keepnet_tab),
                    ("notifications", self.create_notifications_tab),
                ]
                
                for title_key, create_func in self.tabs:
                    tab_widget = create_func()
                    self.tab_widget.addTab(tab_widget, self.get_text(title_key))
            
            def create_script_tab(self):
                """Create script settings tab."""
                widget = QWidget()
                layout = QVBoxLayout(widget)
                
                # General Settings Group
                self.general_group = QGroupBox(self.get_text("general_settings"))
                general_layout = QGridLayout(self.general_group)
                
                # Script Language
                general_layout.addWidget(QLabel(self.get_text("script_language")), 0, 0)
                self.script_language_combo = QComboBox()
                self.script_language_combo.addItems(["en", "ru", "zh-TW", "zh-CN"])
                general_layout.addWidget(self.script_language_combo, 0, 1)
                
                # Launch Options
                general_layout.addWidget(QLabel(self.get_text("default_launch_options")), 1, 0)
                self.launch_options_edit = QLineEdit()
                self.launch_options_edit.setPlaceholderText("e.g., -r -c -H")
                general_layout.addWidget(self.launch_options_edit, 1, 1)
                
                # Detection Settings Group
                self.detection_group = QGroupBox(self.get_text("detection_settings"))
                detection_layout = QGridLayout(self.detection_group)
                
                self.smtp_verification_cb = QCheckBox(self.get_text("smtp_verification"))
                self.image_verification_cb = QCheckBox(self.get_text("image_verification"))
                self.snag_detection_cb = QCheckBox(self.get_text("snag_detection"))
                self.spooling_detection_cb = QCheckBox(self.get_text("spooling_detection"))
                self.random_rod_selection_cb = QCheckBox(self.get_text("random_rod_selection"))
                
                detection_layout.addWidget(self.smtp_verification_cb, 0, 0)
                detection_layout.addWidget(self.image_verification_cb, 0, 1)
                detection_layout.addWidget(self.snag_detection_cb, 1, 0)
                detection_layout.addWidget(self.spooling_detection_cb, 1, 1)
                detection_layout.addWidget(self.random_rod_selection_cb, 2, 0)
                
                # Spool Confidence
                detection_layout.addWidget(QLabel(self.get_text("spool_confidence")), 3, 0)
                self.spool_confidence_spin = QDoubleSpinBox()
                self.spool_confidence_spin.setRange(0.0, 1.0)
                self.spool_confidence_spin.setSingleStep(0.01)
                self.spool_confidence_spin.setValue(0.98)
                detection_layout.addWidget(self.spool_confidence_spin, 3, 1)
                
                # Advanced Settings Group
                self.advanced_group = QGroupBox(self.get_text("advanced_settings"))
                advanced_layout = QGridLayout(self.advanced_group)
                
                # Spod Recast Delay
                advanced_layout.addWidget(QLabel(self.get_text("spod_recast_delay")), 0, 0)
                self.spod_recast_delay_spin = QSpinBox()
                self.spod_recast_delay_spin.setRange(60, 7200)
                self.spod_recast_delay_spin.setValue(1800)
                advanced_layout.addWidget(self.spod_recast_delay_spin, 0, 1)
                
                # Lure Change Delay
                advanced_layout.addWidget(QLabel(self.get_text("lure_change_delay")), 1, 0)
                self.lure_change_delay_spin = QSpinBox()
                self.lure_change_delay_spin.setRange(60, 7200)
                self.lure_change_delay_spin.setValue(1800)
                advanced_layout.addWidget(self.lure_change_delay_spin, 1, 1)
                
                # Random Cast Probability
                advanced_layout.addWidget(QLabel(self.get_text("random_cast_probability")), 2, 0)
                self.random_cast_prob_spin = QDoubleSpinBox()
                self.random_cast_prob_spin.setRange(0.0, 1.0)
                self.random_cast_prob_spin.setSingleStep(0.01)
                self.random_cast_prob_spin.setValue(0.25)
                advanced_layout.addWidget(self.random_cast_prob_spin, 2, 1)
                
                layout.addWidget(self.general_group)
                layout.addWidget(self.detection_group)
                layout.addWidget(self.advanced_group)
                layout.addStretch()
                
                return widget
            
            def create_keys_tab(self):
                """Create key bindings tab."""
                widget = QWidget()
                layout = QVBoxLayout(widget)
                
                # Info label
                self.key_info_label = QLabel(self.get_text("key_info"))
                self.key_info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                layout.addWidget(self.key_info_label)
                
                scroll = QScrollArea()
                scroll_widget = QWidget()
                scroll_layout = QGridLayout(scroll_widget)
                
                # Key bindings
                self.key_widgets = {}
                key_settings = [
                    ("tea_key", "TEA"),
                    ("carrot_key", "CARROT"),
                    ("coffee_key", "COFFEE"),
                    ("digging_tool_key", "DIGGING_TOOL"),
                    ("alcohol_key", "ALCOHOL"),
                    ("main_rod_key", "MAIN_ROD"),
                    ("spod_rod_key", "SPOD_ROD"),
                ]
                
                row = 0
                for label_key, config_key in key_settings:
                    label_widget = QLabel(f"{self.get_text(label_key)}:")
                    label_widget.setMinimumWidth(150)
                    scroll_layout.addWidget(label_widget, row, 0)
                    
                    key_edit = QLineEdit()
                    key_edit.setPlaceholderText("-1")
                    key_edit.setMaximumWidth(100)
                    self.key_widgets[config_key] = key_edit
                    scroll_layout.addWidget(key_edit, row, 1)
                    
                    row += 1
                    
                # Bottom rods
                scroll_layout.addWidget(QLabel(f"{self.get_text('bottom_rods')}"), row, 0)
                self.bottom_rods_edit = QLineEdit()
                self.bottom_rods_edit.setPlaceholderText("1,2,3")
                self.bottom_rods_edit.setMaximumWidth(100)
                scroll_layout.addWidget(self.bottom_rods_edit, row, 1)
                
                # Quit key
                row += 1
                scroll_layout.addWidget(QLabel(f"{self.get_text('quit_key')}"), row, 0)
                self.quit_key_edit = QLineEdit()
                self.quit_key_edit.setPlaceholderText("CTRL-C")
                self.quit_key_edit.setMaximumWidth(100)
                scroll_layout.addWidget(self.quit_key_edit, row, 1)
                
                scroll_layout.setColumnStretch(2, 1)
                scroll.setWidget(scroll_widget)
                layout.addWidget(scroll)
                
                return widget
            
            def create_stats_tab(self):
                """Create player stats tab."""
                widget = QWidget()
                layout = QVBoxLayout(widget)
                
                # Info label
                self.stat_info_label = QLabel(self.get_text("stat_info"))
                self.stat_info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                layout.addWidget(self.stat_info_label)
                
                # Thresholds Group
                self.thresholds_group = QGroupBox(self.get_text("stat_thresholds"))
                thresholds_layout = QGridLayout(self.thresholds_group)
                
                # Energy Threshold
                thresholds_layout.addWidget(QLabel(self.get_text("energy_threshold")), 0, 0)
                self.energy_threshold_spin = QDoubleSpinBox()
                self.energy_threshold_spin.setRange(0.0, 1.0)
                self.energy_threshold_spin.setSingleStep(0.01)
                self.energy_threshold_spin.setValue(0.74)
                thresholds_layout.addWidget(self.energy_threshold_spin, 0, 1)
                
                # Hunger Threshold
                thresholds_layout.addWidget(QLabel(self.get_text("hunger_threshold")), 1, 0)
                self.hunger_threshold_spin = QDoubleSpinBox()
                self.hunger_threshold_spin.setRange(0.0, 1.0)
                self.hunger_threshold_spin.setSingleStep(0.01)
                self.hunger_threshold_spin.setValue(0.5)
                thresholds_layout.addWidget(self.hunger_threshold_spin, 1, 1)
                
                # Comfort Threshold
                thresholds_layout.addWidget(QLabel(self.get_text("comfort_threshold")), 2, 0)
                self.comfort_threshold_spin = QDoubleSpinBox()
                self.comfort_threshold_spin.setRange(0.0, 1.0)
                self.comfort_threshold_spin.setSingleStep(0.01)
                self.comfort_threshold_spin.setValue(0.51)
                thresholds_layout.addWidget(self.comfort_threshold_spin, 2, 1)
                
                # Consumption Settings Group
                self.consumption_group = QGroupBox(self.get_text("consumption_settings"))
                consumption_layout = QGridLayout(self.consumption_group)
                
                # Tea Delay
                consumption_layout.addWidget(QLabel(self.get_text("tea_delay")), 0, 0)
                self.tea_delay_spin = QSpinBox()
                self.tea_delay_spin.setRange(0, 3600)
                self.tea_delay_spin.setValue(300)
                consumption_layout.addWidget(self.tea_delay_spin, 0, 1)
                
                # Coffee settings
                consumption_layout.addWidget(QLabel(self.get_text("coffee_limit")), 1, 0)
                self.coffee_limit_spin = QSpinBox()
                self.coffee_limit_spin.setRange(1, 50)
                self.coffee_limit_spin.setValue(10)
                consumption_layout.addWidget(self.coffee_limit_spin, 1, 1)
                
                consumption_layout.addWidget(QLabel(self.get_text("coffee_per_drink")), 2, 0)
                self.coffee_per_drink_spin = QSpinBox()
                self.coffee_per_drink_spin.setRange(1, 10)
                self.coffee_per_drink_spin.setValue(1)
                consumption_layout.addWidget(self.coffee_per_drink_spin, 2, 1)
                
                # Alcohol settings
                consumption_layout.addWidget(QLabel(self.get_text("alcohol_delay")), 3, 0)
                self.alcohol_delay_spin = QSpinBox()
                self.alcohol_delay_spin.setRange(0, 3600)
                self.alcohol_delay_spin.setValue(900)
                consumption_layout.addWidget(self.alcohol_delay_spin, 3, 1)
                
                consumption_layout.addWidget(QLabel(self.get_text("alcohol_per_drink")), 4, 0)
                self.alcohol_per_drink_spin = QSpinBox()
                self.alcohol_per_drink_spin.setRange(1, 10)
                self.alcohol_per_drink_spin.setValue(1)
                consumption_layout.addWidget(self.alcohol_per_drink_spin, 4, 1)
                
                layout.addWidget(self.thresholds_group)
                layout.addWidget(self.consumption_group)
                layout.addStretch()
                
                return widget
            
            def create_profiles_tab(self):
                """Create fishing profiles tab."""
                widget = QWidget()
                layout = QVBoxLayout(widget)
                
                # Profile Selection
                self.profile_selection_group = QGroupBox(self.get_text("profile_selection"))
                profile_layout = QHBoxLayout(self.profile_selection_group)
                
                profile_layout.addWidget(QLabel(self.get_text("current_profile")))
                
                self.profile_combo = QComboBox()
                self.profile_combo.addItems([
                    "SPIN", "SPIN_WITH_PAUSE", "SPIN_WITH_LIFT", "BOTTOM",
                    "PIRK", "PIRK_WITH_RETRIEVAL", "WAKEY_RIG",
                    "ELEVATOR", "ELEVATOR_WITH_DROP", "TELESCOPIC", "BOLOGNESE"
                ])
                profile_layout.addWidget(self.profile_combo)
                
                # Profile management buttons
                self.copy_profile_btn = QPushButton(self.get_text("copy_profile"))
                self.delete_profile_btn = QPushButton(self.get_text("delete_profile"))
                
                profile_layout.addStretch()
                profile_layout.addWidget(self.copy_profile_btn)
                profile_layout.addWidget(self.delete_profile_btn)
                
                layout.addWidget(self.profile_selection_group)
                
                # Placeholder for profile settings
                info_label = QLabel("üé£ Fishing profile configuration will be implemented here")
                info_label.setStyleSheet("color: #b9bbbe; font-size: 12pt; text-align: center; padding: 40px;")
                info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                layout.addWidget(info_label)
                
                return widget
            
            def create_friction_tab(self):
                """Create friction brake tab."""
                widget = QWidget()
                layout = QVBoxLayout(widget)
                
                # Info
                self.friction_info_label = QLabel(self.get_text("friction_info"))
                self.friction_info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                layout.addWidget(self.friction_info_label)
                
                self.friction_group = QGroupBox(self.get_text("friction_settings"))
                friction_layout = QGridLayout(self.friction_group)
                
                # Initial Value
                friction_layout.addWidget(QLabel(self.get_text("initial_value")), 0, 0)
                self.friction_initial_spin = QSpinBox()
                self.friction_initial_spin.setRange(0, 50)
                self.friction_initial_spin.setValue(29)
                friction_layout.addWidget(self.friction_initial_spin, 0, 1)
                
                # Max Value
                friction_layout.addWidget(QLabel(self.get_text("max_value")), 1, 0)
                self.friction_max_spin = QSpinBox()
                self.friction_max_spin.setRange(0, 50)
                self.friction_max_spin.setValue(30)
                friction_layout.addWidget(self.friction_max_spin, 1, 1)
                
                # Start Delay
                friction_layout.addWidget(QLabel(self.get_text("start_delay")), 2, 0)
                self.friction_start_delay_spin = QDoubleSpinBox()
                self.friction_start_delay_spin.setRange(0.0, 10.0)
                self.friction_start_delay_spin.setSingleStep(0.1)
                self.friction_start_delay_spin.setValue(2.0)
                friction_layout.addWidget(self.friction_start_delay_spin, 2, 1)
                
                # Increase Delay
                friction_layout.addWidget(QLabel(self.get_text("increase_delay")), 3, 0)
                self.friction_increase_delay_spin = QDoubleSpinBox()
                self.friction_increase_delay_spin.setRange(0.0, 10.0)
                self.friction_increase_delay_spin.setSingleStep(0.1)
                self.friction_increase_delay_spin.setValue(1.0)
                friction_layout.addWidget(self.friction_increase_delay_spin, 3, 1)
                
                # Sensitivity
                friction_layout.addWidget(QLabel(self.get_text("sensitivity")), 4, 0)
                self.friction_sensitivity_combo = QComboBox()
                self.friction_sensitivity_combo.addItems(["low", "medium", "high"])
                self.friction_sensitivity_combo.setCurrentText("medium")
                friction_layout.addWidget(self.friction_sensitivity_combo, 4, 1)
                
                layout.addWidget(self.friction_group)
                layout.addStretch()
                
                return widget
            
            def create_keepnet_tab(self):
                """Create keepnet tab."""
                widget = QWidget()
                layout = QVBoxLayout(widget)
                
                # Info
                self.keepnet_info_label = QLabel(self.get_text("keepnet_info"))
                self.keepnet_info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                layout.addWidget(self.keepnet_info_label)
                
                # Basic Settings
                self.basic_group = QGroupBox(self.get_text("basic_settings"))
                basic_layout = QGridLayout(self.basic_group)
                
                # Capacity
                basic_layout.addWidget(QLabel(self.get_text("capacity")), 0, 0)
                self.keepnet_capacity_spin = QSpinBox()
                self.keepnet_capacity_spin.setRange(1, 200)
                self.keepnet_capacity_spin.setValue(100)
                basic_layout.addWidget(self.keepnet_capacity_spin, 0, 1)
                
                # Full Action
                basic_layout.addWidget(QLabel(self.get_text("full_action")), 1, 0)
                self.keepnet_full_action_combo = QComboBox()
                self.keepnet_full_action_combo.addItems(["quit", "alarm"])
                basic_layout.addWidget(self.keepnet_full_action_combo, 1, 1)
                
                # Fish Delay
                basic_layout.addWidget(QLabel(self.get_text("fish_delay")), 2, 0)
                self.fish_delay_spin = QDoubleSpinBox()
                self.fish_delay_spin.setRange(0.0, 10.0)
                self.fish_delay_spin.setSingleStep(0.1)
                self.fish_delay_spin.setValue(0.0)
                basic_layout.addWidget(self.fish_delay_spin, 2, 1)
                
                # Gift Delay
                basic_layout.addWidget(QLabel(self.get_text("gift_delay")), 3, 0)
                self.gift_delay_spin = QDoubleSpinBox()
                self.gift_delay_spin.setRange(0.0, 10.0)
                self.gift_delay_spin.setSingleStep(0.1)
                self.gift_delay_spin.setValue(4.0)
                basic_layout.addWidget(self.gift_delay_spin, 3, 1)
                
                # Fish Management
                self.fish_group = QGroupBox(self.get_text("fish_management"))
                fish_layout = QGridLayout(self.fish_group)
                
                # Tags to keep
                fish_layout.addWidget(QLabel(self.get_text("keep_tags")), 0, 0)
                self.keepnet_tags_edit = QLineEdit()
                self.keepnet_tags_edit.setPlaceholderText("green,yellow,blue,purple,pink")
                fish_layout.addWidget(self.keepnet_tags_edit, 0, 1)
                
                # Whitelist
                fish_layout.addWidget(QLabel(self.get_text("whitelist")), 1, 0)
                self.keepnet_whitelist_edit = QLineEdit()
                self.keepnet_whitelist_edit.setPlaceholderText("mackerel,saithe,herring")
                fish_layout.addWidget(self.keepnet_whitelist_edit, 1, 1)
                
                # Blacklist
                fish_layout.addWidget(QLabel(self.get_text("blacklist")), 2, 0)
                self.keepnet_blacklist_edit = QLineEdit()
                fish_layout.addWidget(self.keepnet_blacklist_edit, 2, 1)
                
                layout.addWidget(self.basic_group)
                layout.addWidget(self.fish_group)
                layout.addStretch()
                
                return widget
            
            def create_notifications_tab(self):
                """Create notifications tab."""
                widget = QWidget()
                layout = QVBoxLayout(widget)
                
                # Info
                self.notification_info_label = QLabel(self.get_text("notification_info"))
                self.notification_info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                layout.addWidget(self.notification_info_label)
                
                # Email Group
                self.email_group = QGroupBox(self.get_text("email_notifications"))
                email_layout = QGridLayout(self.email_group)
                
                email_layout.addWidget(QLabel(self.get_text("email")), 0, 0)
                self.email_edit = QLineEdit()
                self.email_edit.setPlaceholderText("your-email@gmail.com")
                email_layout.addWidget(self.email_edit, 0, 1)
                
                email_layout.addWidget(QLabel(self.get_text("password")), 1, 0)
                self.password_edit = QLineEdit()
                self.password_edit.setEchoMode(QLineEdit.EchoMode.Password)
                email_layout.addWidget(self.password_edit, 1, 1)
                
                email_layout.addWidget(QLabel(self.get_text("smtp_server")), 2, 0)
                self.smtp_server_edit = QLineEdit()
                self.smtp_server_edit.setText("smtp.gmail.com")
                email_layout.addWidget(self.smtp_server_edit, 2, 1)
                
                # Discord Group
                self.discord_group = QGroupBox(self.get_text("discord_notifications"))
                discord_layout = QGridLayout(self.discord_group)
                
                discord_layout.addWidget(QLabel(self.get_text("webhook_url")), 0, 0)
                self.discord_webhook_edit = QLineEdit()
                self.discord_webhook_edit.setPlaceholderText("https://discord.com/api/webhooks/...")
                discord_layout.addWidget(self.discord_webhook_edit, 0, 1)
                
                # Miaotixing Group
                self.miao_group = QGroupBox(self.get_text("miaotixing_notifications"))
                miao_layout = QGridLayout(self.miao_group)
                
                miao_layout.addWidget(QLabel(self.get_text("miao_code")), 0, 0)
                self.miao_code_edit = QLineEdit()
                miao_layout.addWidget(self.miao_code_edit, 0, 1)
                
                layout.addWidget(self.email_group)
                layout.addWidget(self.discord_group)
                layout.addWidget(self.miao_group)
                layout.addStretch()
                
                return widget
                
            def create_modern_control_panel(self, parent):
                """Create modern control panel."""
                control_widget = QWidget()
                layout = QVBoxLayout(control_widget)
                layout.setContentsMargins(12, 12, 12, 12)
                layout.setSpacing(16)
                
                # Profile Quick Select
                self.create_profile_cards(layout)
                
                # Launch Options
                self.create_launch_options_panel(layout)
                
                # Script Control
                self.create_script_control_panel(layout)
                
                # Modern log viewer
                self.create_modern_log_viewer(layout)
                
                parent.addWidget(control_widget)
                
            def create_profile_cards(self, layout):
                """Create modern profile selection cards."""
                self.profile_group = QGroupBox(self.get_text("quick_profile_selection"))
                profile_layout = QGridLayout(self.profile_group)
                profile_layout.setSpacing(8)
                
                profiles = [
                    ("SPIN", "üé£", "spin_fishing", "#5865f2"),
                    ("BOTTOM", "‚öì", "bottom_fishing", "#3ba55d"),
                    ("PIRK", "üêü", "pirk_fishing", "#faa61a"),
                    ("TELESCOPIC", "üéØ", "telescopic", "#ed4245")
                ]
                
                for i, (profile, icon, name_key, color) in enumerate(profiles):
                    card = self.create_profile_card(icon, self.get_text(name_key), profile, color)
                    profile_layout.addWidget(card, i // 2, i % 2)
                    
                layout.addWidget(self.profile_group)
                
            def create_profile_card(self, icon, name, profile, color):
                """Create an individual profile card."""
                card = QPushButton()
                card.setText(f"{icon}\n{name}")
                card.setStyleSheet(f"""
                    QPushButton {{
                        background-color: #2f3136;
                        border: 2px solid #4f545c;
                        border-radius: 12px;
                        color: #ffffff;
                        font-weight: 600;
                        font-size: 10pt;
                        padding: 16px;
                        text-align: center;
                        min-height: 60px;
                    }}
                    QPushButton:hover {{
                        background-color: {color};
                        border-color: {color};
                    }}
                """)
                
                card.clicked.connect(lambda: self.select_profile(profile))
                card.setCursor(Qt.CursorShape.PointingHandCursor)
                
                return card
                
            def create_launch_options_panel(self, layout):
                """Create modern launch options panel."""
                self.launch_group = QGroupBox(self.get_text("launch_options"))
                launch_layout = QVBoxLayout(self.launch_group)
                launch_layout.setSpacing(12)
                
                # Options input
                self.current_launch_options = QLineEdit()
                self.current_launch_options.setPlaceholderText("Enter launch options here...")
                self.current_launch_options.setStyleSheet("padding: 12px; font-size: 10pt;")
                launch_layout.addWidget(self.current_launch_options)
                
                # Modern checkboxes grid
                options_grid = QGridLayout()
                options_grid.setSpacing(8)
                
                self.option_checkboxes = {}
                common_options = [
                    ("-r", "refill_stats", "refill_tooltip"),
                    ("-c", "drink_coffee", "coffee_tooltip"),
                    ("-H", "harvest_baits", "harvest_tooltip"),
                    ("-t", "keep_tagged_only", "tagged_tooltip"),
                    ("-s", "save_screenshots", "screenshots_tooltip"),
                    ("-d", "save_data_logs", "data_tooltip"),
                    ("-FB", "friction_brake", "friction_tooltip"),
                    ("-l", "lift_tackle", "lift_tooltip"),
                ]
                
                for i, (option, text_key, tooltip_key) in enumerate(common_options):
                    cb = QCheckBox(self.get_text(text_key))
                    cb.setToolTip(self.get_text(tooltip_key))
                    cb.stateChanged.connect(self.update_launch_options)
                    cb.setStyleSheet("padding: 4px; font-size: 9pt;")
                    self.option_checkboxes[option] = cb
                    options_grid.addWidget(cb, i // 2, i % 2)
                    
                launch_layout.addLayout(options_grid)
                layout.addWidget(self.launch_group)
                
            def create_script_control_panel(self, layout):
                """Create modern script control panel."""
                self.control_group = QGroupBox(self.get_text("script_control"))
                control_layout = QVBoxLayout(self.control_group)
                control_layout.setSpacing(12)
                
                # Control buttons
                button_layout = QHBoxLayout()
                button_layout.setSpacing(12)
                
                self.start_button = QPushButton(self.get_text("start_script"))
                self.stop_button = QPushButton(self.get_text("stop_script"))
                self.stop_button.setEnabled(False)
                
                # Modern button styling
                self.start_button.setStyleSheet("""
                    QPushButton {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 #4CAF50, stop:1 #45a049);
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-weight: 600;
                        font-size: 11pt;
                        min-height: 20px;
                    }
                    QPushButton:hover {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 #45a049, stop:1 #3d8b40);
                    }
                    QPushButton:disabled {
                        background-color: #2f3136;
                        color: #72767d;
                    }
                """)
                
                self.stop_button.setStyleSheet("""
                    QPushButton {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 #f44336, stop:1 #da190b);
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-weight: 600;
                        font-size: 11pt;
                        min-height: 20px;
                    }
                    QPushButton:hover {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 #da190b, stop:1 #c62828);
                    }
                    QPushButton:disabled {
                        background-color: #2f3136;
                        color: #72767d;
                    }
                """)
                
                self.start_button.clicked.connect(self.start_script)
                self.stop_button.clicked.connect(self.stop_script)
                
                button_layout.addWidget(self.start_button)
                button_layout.addWidget(self.stop_button)
                control_layout.addLayout(button_layout)
                
                # Modern progress bar
                self.progress_bar = QProgressBar()
                self.progress_bar.setVisible(False)
                self.progress_bar.setStyleSheet("""
                    QProgressBar {
                        border: none;
                        border-radius: 8px;
                        background-color: #2f3136;
                        height: 8px;
                        text-align: center;
                        color: transparent;
                    }
                    QProgressBar::chunk {
                        background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                                                stop:0 #5865f2, stop:1 #7289da);
                        border-radius: 8px;
                    }
                """)
                control_layout.addWidget(self.progress_bar)
                
                # Fish count with modern styling
                fish_layout = QHBoxLayout()
                fish_layout.setSpacing(8)
                
                self.fish_label = QLabel(self.get_text("fishes_in_keepnet"))
                self.fish_label.setStyleSheet("color: #dcddde; font-weight: 500;")
                
                self.fish_count_spin = QSpinBox()
                self.fish_count_spin.setRange(0, 200)
                self.fish_count_spin.setValue(0)
                self.fish_count_spin.setStyleSheet("padding: 8px; font-size: 10pt;")
                
                fish_layout.addWidget(self.fish_label)
                fish_layout.addWidget(self.fish_count_spin)
                fish_layout.addStretch()
                
                control_layout.addLayout(fish_layout)
                layout.addWidget(self.control_group)
                
            def create_modern_log_viewer(self, layout):
                """Create modern log viewer with terminal styling."""
                self.log_group = QGroupBox(self.get_text("script_output"))
                log_layout = QVBoxLayout(self.log_group)
                log_layout.setSpacing(8)
                
                # Log viewer with terminal styling
                self.log_viewer = QTextEdit()
                self.log_viewer.setObjectName("log_viewer")
                self.log_viewer.setReadOnly(True)
                self.log_viewer.setFont(QFont("JetBrains Mono", 9))
                
                # Add welcome message
                if self.current_language == "ru":
                    welcome_msg = """
        üé£ Russian Fishing 4 Script - –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å!
        ‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å —Ä—ã–±–∞–ª–∫–∏
        ‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –æ–ø—Ü–∏–∏ –∑–∞–ø—É—Å–∫–∞  
        ‚Ä¢ –ù–∞–∂–º–∏—Ç–µ "–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–∫—Ä–∏–ø—Ç" –¥–ª—è –Ω–∞—á–∞–ª–∞
        
        –ì–æ—Ç–æ–≤ –∫ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Ä—ã–±–∞–ª–∫–∏! üöÄ
                    """.strip()
                else:
                    welcome_msg = """
        üé£ Russian Fishing 4 Script - Modern UI
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        Welcome to the modern interface!
        ‚Ä¢ Select a fishing profile
        ‚Ä¢ Configure your launch options  
        ‚Ä¢ Click "Start Script" to begin
        
        Ready for fishing automation! üöÄ
                    """.strip()
                
                self.log_viewer.setText(welcome_msg)
                log_layout.addWidget(self.log_viewer)
                
                # Log controls with modern styling
                controls_layout = QHBoxLayout()
                controls_layout.setSpacing(8)
                
                self.clear_log_button = self.create_modern_button(self.get_text("clear"), "danger")
                self.save_log_button = self.create_modern_button(self.get_text("save_log"), "primary")
                
                self.auto_scroll_cb = QCheckBox(self.get_text("auto_scroll"))
                self.auto_scroll_cb.setChecked(True)
                self.auto_scroll_cb.setStyleSheet("color: #dcddde; font-weight: 500;")
                
                self.clear_log_button.clicked.connect(self.clear_log)
                self.save_log_button.clicked.connect(self.save_log)
                
                controls_layout.addWidget(self.clear_log_button)
                controls_layout.addWidget(self.save_log_button)
                controls_layout.addWidget(self.auto_scroll_cb)
                controls_layout.addStretch()
                
                log_layout.addLayout(controls_layout)
                layout.addWidget(self.log_group)
                
            def create_modern_status_bar(self):
                """Create modern status bar."""
                self.status_bar = self.statusBar()
                
                # Status label
                self.status_label = QLabel(self.get_text("ready"))
                self.status_bar.addWidget(self.status_label)
                
                # Config indicator
                self.config_indicator = QLabel(self.get_text("no_config"))
                self.config_indicator.setStyleSheet("color: #faa61a; font-weight: 500;")
                self.status_bar.addPermanentWidget(self.config_indicator)
                
                # Script status
                self.script_status = QLabel(self.get_text("script_status_stopped"))
                self.script_status.setStyleSheet("color: #ed4245; font-weight: 500;")
                self.status_bar.addPermanentWidget(self.script_status)
                
            def update_interface_language(self):
                """Update all interface elements with new language."""
                # Update window title
                self.setWindowTitle(self.get_text("window_title"))
                
                # Update toolbar
                if hasattr(self, 'lang_label'):
                    self.lang_label.setText(self.get_text("language"))
                if hasattr(self, 'load_button'):
                    self.load_button.setText(self.get_text("load_config"))
                if hasattr(self, 'save_button'):
                    self.save_button.setText(self.get_text("save_config"))
                if hasattr(self, 'reset_button'):
                    self.reset_button.setText(self.get_text("reset_default"))
                
                # Update tabs
                if hasattr(self, 'tab_widget') and hasattr(self, 'tabs'):
                    for i, (title_key, _) in enumerate(self.tabs):
                        self.tab_widget.setTabText(i, self.get_text(title_key))
                
                # Update script settings tab
                if hasattr(self, 'general_group'):
                    self.general_group.setTitle(self.get_text("general_settings"))
                if hasattr(self, 'detection_group'):
                    self.detection_group.setTitle(self.get_text("detection_settings"))
                if hasattr(self, 'advanced_group'):
                    self.advanced_group.setTitle(self.get_text("advanced_settings"))
                
                # Update key bindings tab
                if hasattr(self, 'key_info_label'):
                    self.key_info_label.setText(self.get_text("key_info"))
                
                # Update stats tab
                if hasattr(self, 'stat_info_label'):
                    self.stat_info_label.setText(self.get_text("stat_info"))
                if hasattr(self, 'thresholds_group'):
                    self.thresholds_group.setTitle(self.get_text("stat_thresholds"))
                if hasattr(self, 'consumption_group'):
                    self.consumption_group.setTitle(self.get_text("consumption_settings"))
                
                # Update profiles tab
                if hasattr(self, 'profile_selection_group'):
                    self.profile_selection_group.setTitle(self.get_text("profile_selection"))
                if hasattr(self, 'copy_profile_btn'):
                    self.copy_profile_btn.setText(self.get_text("copy_profile"))
                if hasattr(self, 'delete_profile_btn'):
                    self.delete_profile_btn.setText(self.get_text("delete_profile"))
                
                # Update friction brake tab
                if hasattr(self, 'friction_info_label'):
                    self.friction_info_label.setText(self.get_text("friction_info"))
                if hasattr(self, 'friction_group'):
                    self.friction_group.setTitle(self.get_text("friction_settings"))
                
                # Update keepnet tab
                if hasattr(self, 'keepnet_info_label'):
                    self.keepnet_info_label.setText(self.get_text("keepnet_info"))
                if hasattr(self, 'basic_group'):
                    self.basic_group.setTitle(self.get_text("basic_settings"))
                if hasattr(self, 'fish_group'):
                    self.fish_group.setTitle(self.get_text("fish_management"))
                
                # Update notifications tab
                if hasattr(self, 'notification_info_label'):
                    self.notification_info_label.setText(self.get_text("notification_info"))
                if hasattr(self, 'email_group'):
                    self.email_group.setTitle(self.get_text("email_notifications"))
                if hasattr(self, 'discord_group'):
                    self.discord_group.setTitle(self.get_text("discord_notifications"))
                if hasattr(self, 'miao_group'):
                    self.miao_group.setTitle(self.get_text("miaotixing_notifications"))
                
                # Update control panel
                if hasattr(self, 'profile_group'):
                    self.profile_group.setTitle(self.get_text("quick_profile_selection"))
                if hasattr(self, 'launch_group'):
                    self.launch_group.setTitle(self.get_text("launch_options"))
                if hasattr(self, 'control_group'):
                    self.control_group.setTitle(self.get_text("script_control"))
                if hasattr(self, 'log_group'):
                    self.log_group.setTitle(self.get_text("script_output"))
                
                # Update buttons
                if hasattr(self, 'start_button'):
                    self.start_button.setText(self.get_text("start_script"))
                if hasattr(self, 'stop_button'):
                    self.stop_button.setText(self.get_text("stop_script"))
                if hasattr(self, 'clear_log_button'):
                    self.clear_log_button.setText(self.get_text("clear"))
                if hasattr(self, 'save_log_button'):
                    self.save_log_button.setText(self.get_text("save_log"))
                
                # Update checkboxes
                for option, checkbox in getattr(self, 'option_checkboxes', {}).items():
                    option_map = {
                        "-r": "refill_stats",
                        "-c": "drink_coffee", 
                        "-H": "harvest_baits",
                        "-t": "keep_tagged_only",
                        "-s": "save_screenshots",
                        "-d": "save_data_logs",
                        "-FB": "friction_brake",
                        "-l": "lift_tackle"
                    }
                    if option in option_map:
                        checkbox.setText(self.get_text(option_map[option]))
                
                # Update other labels
                if hasattr(self, 'auto_scroll_cb'):
                    self.auto_scroll_cb.setText(self.get_text("auto_scroll"))
                if hasattr(self, 'fish_label'):
                    self.fish_label.setText(self.get_text("fishes_in_keepnet"))
                
                # Update status bar
                if hasattr(self, 'status_label'):
                    self.status_label.setText(self.get_text("ready"))
                if hasattr(self, 'config_indicator'):
                    self.config_indicator.setText(self.get_text("no_config"))
                if hasattr(self, 'script_status'):
                    self.script_status.setText(self.get_text("script_status_stopped"))
                
                # Update log viewer welcome message
                if hasattr(self, 'log_viewer'):
                    if self.current_language == "ru":
                        welcome_msg = """
        üé£ Russian Fishing 4 Script - –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å!
        ‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å —Ä—ã–±–∞–ª–∫–∏
        ‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –æ–ø—Ü–∏–∏ –∑–∞–ø—É—Å–∫–∞  
        ‚Ä¢ –ù–∞–∂–º–∏—Ç–µ "–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–∫—Ä–∏–ø—Ç" –¥–ª—è –Ω–∞—á–∞–ª–∞
        
        –ì–æ—Ç–æ–≤ –∫ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Ä—ã–±–∞–ª–∫–∏! üöÄ
                        """.strip()
                    else:
                        welcome_msg = """
        üé£ Russian Fishing 4 Script - Modern UI
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        Welcome to the modern interface!
        ‚Ä¢ Select a fishing profile
        ‚Ä¢ Configure your launch options  
        ‚Ä¢ Click "Start Script" to begin
        
        Ready for fishing automation! üöÄ
                        """.strip()
                    
                    self.log_viewer.clear()
                    self.log_viewer.setText(welcome_msg)
            
            # Event handlers
            def change_language(self, language):
                """Change interface language."""
                self.current_language = "ru" if "–†—É—Å—Å–∫–∏–π" in language else "en"
                self.update_interface_language()
                self.update_status(f"{self.get_text('language_changed')} {language}")
                
            def select_profile(self, profile_name):
                """Select fishing profile."""
                if hasattr(self, 'profile_combo'):
                    self.profile_combo.setCurrentText(profile_name)
                self.update_status(f"{self.get_text('profile_selected')}: {profile_name}")
                self.append_log(f"üéØ {self.get_text('profile_selected')}: {profile_name}")
                
            def update_launch_options(self):
                """Update launch options from checkboxes."""
                options = []
                for option, checkbox in self.option_checkboxes.items():
                    if checkbox.isChecked():
                        options.append(option)
                        
                current_text = self.current_launch_options.text()
                existing_options = current_text.split()
                manual_options = [opt for opt in existing_options if opt not in self.option_checkboxes.keys()]
                
                all_options = manual_options + options
                self.current_launch_options.setText(' '.join(all_options))
                
            def start_script(self):
                """Start the fishing script."""
                if self.is_script_running:
                    return
                    
                launch_options = self.current_launch_options.text().strip()
                profile = getattr(self, 'profile_combo', None)
                profile_name = profile.currentText() if profile else "SPIN"
                fish_count = self.fish_count_spin.value()
                
                # Check if only friction brake is selected
                only_friction_brake = ("-FB" in launch_options and 
                                    len([opt for opt in self.option_checkboxes.values() if opt.isChecked()]) == 1 and
                                    self.option_checkboxes["-FB"].isChecked())
                
                self.is_script_running = True
                self.start_button.setEnabled(False)
                self.stop_button.setEnabled(True)
                self.progress_bar.setVisible(True)
                self.progress_bar.setRange(0, 0)
                
                self.script_status.setText(self.get_text("script_status_running"))
                self.script_status.setStyleSheet("color: #3ba55d; font-weight: 500;")
                
                if only_friction_brake:
                    self.append_log(f"üîß –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ç–æ—Ä–º–æ–∑–∞...")
                    self.script_runner.start_friction_brake_only()
                else:
                    self.append_log(f"üé£ –ó–∞–ø—É—Å–∫ —Ä—ã–±–æ–ª–æ–≤–Ω–æ–≥–æ –±–æ—Ç–∞...")
                    self.append_log(f"üìã –ü—Ä–æ—Ñ–∏–ª—å: {profile_name}")
                    if launch_options:
                        self.append_log(f"‚öôÔ∏è –û–ø—Ü–∏–∏: {launch_options}")
                    if fish_count > 0:
                        self.append_log(f"üêü –†—ã–± –≤ —Å–∞–¥–∫–µ: {fish_count}")
                        
                    self.script_runner.start_script(launch_options, profile_name)
            
                self.update_status(self.get_text("script_running"))
            def stop_script(self):
                """Stop the running script."""
                if not self.is_script_running:
                    return
                    
                self.append_log(f"üõë {self.get_text('script_stopped')}")
                self.script_finished(0)
                
            def script_finished(self, exit_code):
                """Handle script completion."""
                self.is_script_running = False
                self.start_button.setEnabled(True)
                self.stop_button.setEnabled(False)
                self.progress_bar.setVisible(False)
                
                if exit_code == 0:
                    self.script_status.setText(self.get_text("script_status_completed"))
                    self.script_status.setStyleSheet("color: #3ba55d; font-weight: 500;")
                    self.append_log(f"‚úÖ {self.get_text('script_completed')}")
                    self.update_status(self.get_text("script_completed"))
                else:
                    self.script_status.setText(self.get_text("script_status_error"))
                    self.script_status.setStyleSheet("color: #ed4245; font-weight: 500;")
                    self.append_log(f"‚ùå –°–∫—Ä–∏–ø—Ç –∑–∞–≤–µ—Ä—à—ë–Ω —Å –æ—à–∏–±–∫–æ–π: {exit_code}")
                    
            def append_log(self, text):
                """Append text to log viewer."""
                timestamp = datetime.now().strftime('%H:%M:%S')
                formatted_text = f"[{timestamp}] {text}"
                
                self.log_viewer.append(formatted_text)
                
                if self.auto_scroll_cb.isChecked():
                    scrollbar = self.log_viewer.verticalScrollBar()
                    scrollbar.setValue(scrollbar.maximum())
                    
            def clear_log(self):
                """Clear the log viewer."""
                self.log_viewer.clear()
                self.append_log(f"üóëÔ∏è {self.get_text('log_cleared')}")
                
            def save_log(self):
                """Save log to file."""
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                default_filename = f"rf4s_log_{timestamp}.txt"
                
                file_path, _ = QFileDialog.getSaveFileName(
                    self, self.get_text("save_log"), default_filename, "Text files (*.txt);;All files (*.*)"
                )
                if file_path:
                    try:
                        with open(file_path, 'w', encoding='utf-8') as f:
                            f.write(f"Russian Fishing 4 Script GUI Log\n")
                            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                            f.write("=" * 50 + "\n\n")
                            f.write(self.log_viewer.toPlainText())
                        self.append_log(f"üíæ {self.get_text('log_saved')} {file_path}")
                        self.update_status(f"{self.get_text('log_saved')} {file_path}")
                    except Exception as e:
                        self.append_log(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–æ–≥–∞: {e}")
                        
            def update_status(self, message):
                """Update status bar message."""
                timestamp = datetime.now().strftime('%H:%M:%S')
                self.status_label.setText(f"üïê [{timestamp}] {message}")
                
            # Placeholder methods for missing functionality
            def load_config(self): 
                """Load configuration from file."""
                pass
                
            def connect_signals(self): 
                """Connect signals and slots."""
                pass
                
            def load_window_state(self): 
                """Load window geometry and state."""
                try:
                    geometry = self.settings.value("geometry")
                    if geometry:
                        self.restoreGeometry(geometry)
                        
                    # Load last selected language
                    last_language = self.settings.value("lastLanguage", "ru")
                    self.current_language = last_language
                    
                    # Update language combo
                    if last_language == "ru":
                        self.language_combo.setCurrentText("üá∑üá∫ –†—É—Å—Å–∫–∏–π")
                    else:
                        self.language_combo.setCurrentText("üá∫üá∏ English")
                        
                except Exception as e:
                    print(f"Error loading window state: {e}")
                
            def save_window_state(self):
                """Save window geometry and state."""
                try:
                    self.settings.setValue("geometry", self.saveGeometry())
                    self.settings.setValue("lastLanguage", self.current_language)
                except Exception as e:
                    print(f"Error saving window state: {e}")
                
            def load_config_file(self): 
                """Load configuration from selected file."""
                file_path, _ = QFileDialog.getOpenFileName(
                    self, "–ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é" if self.current_language == "ru" else "Load Configuration", 
                    "", "YAML files (*.yaml *.yml);;All files (*.*)"
                )
                if file_path:
                    try:
                        self.config_manager.load_config(file_path)
                        self.config_indicator.setText(os.path.basename(file_path))
                        self.config_indicator.setStyleSheet("color: #3ba55d; font-weight: 500;")
                        self.update_status(f"{self.get_text('config_loaded')}: {file_path}")
                        self.append_log(f"üìÅ {self.get_text('config_loaded')}: {file_path}")
                    except Exception as e:
                        QMessageBox.critical(self, "–û—à–∏–±–∫–∞" if self.current_language == "ru" else "Error", 
                                           f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é: {str(e)}" if self.current_language == "ru" else f"Failed to load configuration: {str(e)}")
                
            def save_config_file(self): 
                """Save configuration to file."""
                try:
                    self.config_manager.save_config("config.yaml")
                    self.config_indicator.setText("config.yaml")
                    self.config_indicator.setStyleSheet("color: #3ba55d; font-weight: 500;")
                    self.update_status(self.get_text("config_saved"))
                    self.append_log(f"üíæ {self.get_text('config_saved')}")
                    
                    if self.current_language == "ru":
                        QMessageBox.information(self, "–£—Å–ø–µ—Ö", "–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!")
                    else:
                        QMessageBox.information(self, "Success", "Configuration saved successfully!")
                except Exception as e:
                    error_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é: {str(e)}" if self.current_language == "ru" else f"Failed to save configuration: {str(e)}"
                    QMessageBox.critical(self, "–û—à–∏–±–∫–∞" if self.current_language == "ru" else "Error", error_msg)
                
            def reset_config(self): 
                """Reset configuration to defaults."""
                title = "–°–±—Ä–æ—Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏" if self.current_language == "ru" else "Reset Configuration"
                message = ("–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é?\n\n"
                          "–≠—Ç–æ –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ—Ç –≤—Å–µ —Ç–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.") if self.current_language == "ru" else (
                          "Are you sure you want to reset all settings to default values?\n\n"
                          "This will overwrite all current settings.")
                
                reply = QMessageBox.question(
                    self, title, message,
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )
                
                if reply == QMessageBox.StandardButton.Yes:
                    self.config_manager.reset_to_defaults()
                    self.config_indicator.setText("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é" if self.current_language == "ru" else "Defaults")
                    self.config_indicator.setStyleSheet("color: #5865f2; font-weight: 500;")
                    
                    reset_msg = "–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–±—Ä–æ—à–µ–Ω–∞ –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é" if self.current_language == "ru" else "Configuration reset to defaults"
                    self.update_status(reset_msg)
                    self.append_log(f"üîÑ {reset_msg}")
            
            def closeEvent(self, event):
                """Handle window close event."""
                # Save window state
                self.save_window_state()
                
                # Stop script if running
                if self.is_script_running:
                    title = "–°–∫—Ä–∏–ø—Ç –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è" if self.current_language == "ru" else "Script Running"
                    message = ("–°–∫—Ä–∏–ø—Ç –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è. –•–æ—Ç–∏—Ç–µ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –µ–≥–æ –∏ –≤—ã–π—Ç–∏?") if self.current_language == "ru" else (
                              "The script is currently running. Do you want to stop it and exit?")
                    
                    reply = QMessageBox.question(
                        self, title, message,
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                        QMessageBox.StandardButton.No
                    )
                    
                    if reply == QMessageBox.StandardButton.Yes:
                        self.stop_script()
                        QTimer.singleShot(1000, self.close)
                        event.ignore()
                        return
                    else:
                        event.ignore()
                        return
                
                # Accept the close event
                event.accept()
        
        
        def main():
            """Main application entry point."""
            app = QApplication(sys.argv)
            app.setApplicationName("RF4S Modern GUI")
            app.setApplicationVersion("1.0")
            app.setOrganizationName("RF4S")
            
            # Set modern app icon
            try:
                app.setWindowIcon(QIcon("gui/assets/icon.png"))
            except:
                pass
            
            # Create and show window
            window = ModernWindow()
            window.show()
            
            sys.exit(app.exec())
        
        
        if __name__ == "__main__":
            main()
    üìÑ requirements.txt
        pathlib2>=2.3.0; python_version < "3.4"
        pyautogui==0.9.54
        keyboard==0.13.5
        pywin32==306
        pynput==1.7.6
        opencv-python==4.8.0.76
        Pillow==10.1.0
        PyScreeze==0.1.29
        python-dotenv==1.0.1
        matplotlib==3.8.0
        playsound==1.2.2 # downgrade to avoid bug
        pyyaml==6.0.2
        yacs==0.1.8
        rich==13.9.4
        bump-my-version==0.32.1
        discord-webhook==1.4.1
        PyQt6>=6.4.0
        PyYAML>=6.0
        pyyaml>=6.0
        PyQt6>=6.4.0
        PyYAML>=6.0
        python-dotenv>=1.0.0
        psutil>=5.8.0
        opencv-python>=4.7.0
        numpy>=1.21.0
        requests>=2.28.0
        # reference: https://stackoverflow.com/questions/68704443/python-playsound-error-261-for-command-the-driver-cannot-recognize-the-specifie
    üìÑ script_runner.py
        """
        Script runner for Russian Fishing 4 Script GUI
        –ó–∞–ø—É—Å–∫–∞—Ç–µ–ª—å —Å–∫—Ä–∏–ø—Ç–∞ –¥–ª—è GUI Russian Fishing 4
        """
        
        import sys
        import os
        import subprocess
        import threading
        import time
        import signal
        from pathlib import Path
        from PyQt6.QtCore import QObject, pyqtSignal, QThread, QProcess
        
        class ScriptRunner(QObject):
            """Manages script execution with real process control."""
            
            # Signals for GUI communication
            output_received = pyqtSignal(str)
            error_received = pyqtSignal(str)
            finished = pyqtSignal(int)
            
            def __init__(self):
                super().__init__()
                self.process = None
                self.script_thread = None
                self.is_running = False
                
            def validate_script_environment(self):
                """Validate script environment and return issues."""
                issues = []
                
                # Check if main script exists
                script_path = self._find_script_path()
                if not script_path:
                    issues.append("–û—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω (main.py –∏–ª–∏ tools/main.py)")
                    
                # Check if RF4S modules exist
                rf4s_path = Path("rf4s")
                if not rf4s_path.exists():
                    issues.append("–ú–æ–¥—É–ª–∏ RF4S –Ω–µ –Ω–∞–π–¥–µ–Ω—ã (–ø–∞–ø–∫–∞ rf4s)")
                    
                # Check for auto_friction_brake if FB option used
                auto_fb_path = Path("auto_friction_brake.py")
                if not auto_fb_path.exists() and not Path("tools/auto_friction_brake.py").exists():
                    issues.append("auto_friction_brake.py –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    
                # Check Python modules
                required_modules = ['pynput', 'rich', 'yacs']
                for module in required_modules:
                    try:
                        __import__(module)
                    except ImportError:
                        issues.append(f"–ú–æ–¥—É–ª—å Python '{module}' –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                        
                return issues
                
            def get_script_info(self):
                """Get diagnostic information about script environment."""
                info = []
                
                # Python info
                info.append(f"Python: {sys.version}")
                info.append(f"–†–∞–±–æ—á–∞—è –ø–∞–ø–∫–∞: {os.getcwd()}")
                
                # Script paths
                script_path = self._find_script_path()
                if script_path:
                    info.append(f"–û—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç: {script_path}")
                else:
                    info.append("–û—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç: –ù–ï –ù–ê–ô–î–ï–ù")
                    
                # RF4S modules
                rf4s_path = Path("rf4s")
                if rf4s_path.exists():
                    info.append(f"–ú–æ–¥—É–ª–∏ RF4S: –Ω–∞–π–¥–µ–Ω—ã –≤ {rf4s_path}")
                    # Check key modules
                    key_modules = ['app', 'config', 'controller', 'player.py']
                    for module in key_modules:
                        module_path = rf4s_path / module
                        if module_path.exists():
                            info.append(f"  ‚úì {module}")
                        else:
                            info.append(f"  ‚úó {module} - –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
                else:
                    info.append("–ú–æ–¥—É–ª–∏ RF4S: –ù–ï –ù–ê–ô–î–ï–ù–´")
                    
                # Check individual script files
                script_files = [
                    'auto_friction_brake.py',
                    'craft.py', 
                    'harvest.py',
                    'move.py',
                    'calculate.py'
                ]
                
                for script_file in script_files:
                    if Path(script_file).exists():
                        info.append(f"‚úì {script_file}")
                    else:
                        info.append(f"‚úó {script_file} - –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
                    
                return info
                
            def _find_script_path(self):
                """Find the main script to execute."""
                # Possible script locations
                possible_paths = [
                    Path("main.py"),              # Main script in root
                    Path("tools/main.py"),        # Main script in tools
                ]
                
                for path in possible_paths:
                    if path.exists():
                        return path
                        
                return None
                
            def start_script(self, launch_options="", profile="SPIN"):
                """Start the fishing script with given options."""
                if self.is_running:
                    self.error_received.emit("–°–∫—Ä–∏–ø—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω!")
                    return
                    
                # Find script to run
                script_path = self._find_script_path()
                if not script_path:
                    self.error_received.emit("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ main.py –¥–ª—è –∑–∞–ø—É—Å–∫–∞!")
                    return
                    
                # Prepare command for fishing bot (feature 0)
                cmd = self._prepare_fishing_command(script_path, launch_options, profile)
                
                self.output_received.emit(f"üöÄ –ó–∞–ø—É—Å–∫ —Ä—ã–±–æ–ª–æ–≤–Ω–æ–≥–æ –±–æ—Ç–∞...")
                self.output_received.emit(f"üìã –ö–æ–º–∞–Ω–¥–∞: {' '.join(cmd)}")
                self.output_received.emit(f"üìÇ –†–∞–±–æ—á–∞—è –ø–∞–ø–∫–∞: {os.getcwd()}")
                
                # Start script in thread
                self.script_thread = ScriptThread(cmd, self, auto_select_fishing=True)
                self.script_thread.output_signal.connect(self.output_received.emit)
                self.script_thread.error_signal.connect(self.error_received.emit)
                self.script_thread.finished_signal.connect(self._on_script_finished)
                
                self.script_thread.start()
                self.is_running = True
                
            def start_friction_brake_only(self):
                """Start only friction brake automation (feature 4)."""
                if self.is_running:
                    self.error_received.emit("–°–∫—Ä–∏–ø—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω!")
                    return
                    
                script_path = self._find_script_path()
                if not script_path:
                    self.error_received.emit("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ main.py –¥–ª—è –∑–∞–ø—É—Å–∫–∞!")
                    return
                    
                cmd = [sys.executable, str(script_path)]
                
                self.output_received.emit(f"üîß –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ç–æ—Ä–º–æ–∑–∞...")
                self.output_received.emit(f"üìã –ö–æ–º–∞–Ω–¥–∞: {' '.join(cmd)}")
                
                # Start with auto-select friction brake (feature 4)
                self.script_thread = ScriptThread(cmd, self, auto_select_feature=4)
                self.script_thread.output_signal.connect(self.output_received.emit)
                self.script_thread.error_signal.connect(self.error_received.emit)
                self.script_thread.finished_signal.connect(self._on_script_finished)
                
                self.script_thread.start()
                self.is_running = True
                
            def _prepare_fishing_command(self, script_path, launch_options, profile):
                """Prepare command line for fishing script execution."""
                cmd = [sys.executable, str(script_path)]
                
                # We'll auto-select fishing bot (feature 0) and then provide the profile/options
                # through stdin after the script starts
                
                return cmd
                
            def stop_script(self):
                """Stop the running script."""
                if not self.is_running:
                    return
                    
                self.output_received.emit("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∫—Ä–∏–ø—Ç–∞...")
                
                if self.script_thread and self.script_thread.isRunning():
                    try:
                        # Send quit command to script
                        if self.script_thread.process:
                            try:
                                # Try to send 'q' to quit gracefully
                                self.script_thread.process.stdin.write('q\n')
                                self.script_thread.process.stdin.flush()
                                time.sleep(1)
                            except:
                                pass
                                
                            # If still running, terminate
                            if self.script_thread.process.poll() is None:
                                self.script_thread.process.terminate()
                                
                            # Wait for graceful shutdown
                            if not self.script_thread.wait(3000):  # 3 seconds
                                # Force kill if needed
                                if self.script_thread.process and self.script_thread.process.poll() is None:
                                    self.script_thread.process.kill()
                                    
                        self.output_received.emit("‚úÖ –°–∫—Ä–∏–ø—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                    except Exception as e:
                        self.error_received.emit(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞: {e}")
                        
                self.is_running = False
                
            def _on_script_finished(self, exit_code):
                """Handle script completion."""
                self.is_running = False
                self.finished.emit(exit_code)
                
                if exit_code == 0:
                    self.output_received.emit("‚úÖ –°–∫—Ä–∏–ø—Ç –∑–∞–≤–µ—Ä—à—ë–Ω —É—Å–ø–µ—à–Ω–æ")
                else:
                    self.output_received.emit(f"‚ùå –°–∫—Ä–∏–ø—Ç –∑–∞–≤–µ—Ä—à—ë–Ω —Å –∫–æ–¥–æ–º –æ—à–∏–±–∫–∏: {exit_code}")
        
        
        class ScriptThread(QThread):
            """Thread for running script process with automated input."""
            
            output_signal = pyqtSignal(str)
            error_signal = pyqtSignal(str)
            finished_signal = pyqtSignal(int)
            
            def __init__(self, command, parent=None, auto_select_fishing=False, auto_select_feature=None):
                super().__init__(parent)
                self.command = command
                self.process = None
                self.auto_select_fishing = auto_select_fishing
                self.auto_select_feature = auto_select_feature
                self.parent_runner = parent
                
            def run(self):
                """Run the script process with automated feature selection."""
                try:
                    # Create process
                    self.process = subprocess.Popen(
                        self.command,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        stdin=subprocess.PIPE,
                        text=True,
                        bufsize=0,  # Unbuffered for real-time interaction
                        universal_newlines=True,
                        cwd=os.getcwd()
                    )
                    
                    # Monitor output and provide input in separate threads
                    output_thread = threading.Thread(
                        target=self._read_and_interact, 
                        daemon=True
                    )
                    error_thread = threading.Thread(
                        target=self._read_error, 
                        args=(self.process.stderr,),
                        daemon=True
                    )
                    
                    output_thread.start()
                    error_thread.start()
                    
                    # Wait for process completion
                    exit_code = self.process.wait()
                    
                    # Wait for output threads to finish
                    output_thread.join(timeout=2)
                    error_thread.join(timeout=2)
                    
                    self.finished_signal.emit(exit_code)
                    
                except Exception as e:
                    self.error_signal.emit(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞: {e}")
                    self.finished_signal.emit(-1)
                    
            def _read_and_interact(self):
                """Read output and automatically provide input when needed."""
                try:
                    feature_selected = False
                    profile_selected = False
                    fishing_started = False
                    
                    while True:
                        line = self.process.stdout.readline()
                        if not line:
                            break
                            
                        line = line.rstrip()
                        if line:
                            self.output_signal.emit(line)
                            
                        # Auto-select fishing bot when asked for feature
                        if "Enter feature id to use, q to quit:" in line and not feature_selected:
                            feature_id = self.auto_select_feature if self.auto_select_feature is not None else 0
                            self.output_signal.emit(f"ü§ñ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–±–æ—Ä —Ñ—É–Ω–∫—Ü–∏–∏: {feature_id}")
                            
                            try:
                                self.process.stdin.write(f"{feature_id}\n")
                                self.process.stdin.flush()
                                feature_selected = True
                            except Exception as e:
                                self.error_signal.emit(f"–û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞ —Ñ—É–Ω–∫—Ü–∏–∏: {e}")
                                break
                                
                        # Auto-select profile when asked (only for fishing bot)
                        elif "Enter profile id to use, h to see help message, q to quit:" in line and not profile_selected and self.auto_select_fishing:
                            # Default to profile 0 (usually SPIN)
                            profile_id = 0
                            self.output_signal.emit(f"üé£ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–±–æ—Ä –ø—Ä–æ—Ñ–∏–ª—è: {profile_id} (SPIN)")
                            
                            try:
                                self.process.stdin.write(f"{profile_id}\n")
                                self.process.stdin.flush()
                                profile_selected = True
                                fishing_started = True
                            except Exception as e:
                                self.error_signal.emit(f"–û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞ –ø—Ä–æ—Ñ–∏–ª—è: {e}")
                                break
                                
                        # Monitor for script start confirmation
                        elif "Press" in line and "to quit" in line and fishing_started:
                            self.output_signal.emit("‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ä—ã–±–∞–ª–∫–∏ –∑–∞–ø—É—â–µ–Ω–∞!")
                            self.output_signal.emit("‚ÑπÔ∏è –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–∫—Ä–∏–ø—Ç' –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è")
                            
                except Exception as e:
                    self.error_signal.emit(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞: {e}")
                finally:
                    try:
                        self.process.stdout.close()
                    except:
                        pass
                        
            def _read_error(self, pipe):
                """Read error output from pipe."""
                try:
                    for line in iter(pipe.readline, ''):
                        if line:
                            self.error_signal.emit(line.rstrip())
                except Exception as e:
                    self.error_signal.emit(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –æ—à–∏–±–æ–∫: {e}")
                finally:
                    try:
                        pipe.close()
                    except:
                        pass
                        
            def terminate(self):
                """Terminate the running process."""
                if self.process:
                    try:
                        # Try graceful termination first
                        if self.process.poll() is None:
                            self.process.terminate()
                            time.sleep(1)
                            
                        # Force kill if still running
                        if self.process.poll() is None:
                            self.process.kill()
                    except:
                        pass
                super().terminate()
    üìÑ setup_gui.py
        #!/usr/bin/env python3
        """
        Setup script for Russian Fishing 4 Script GUI
        –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è GUI
        """
        
        import subprocess
        import sys
        import os
        from pathlib import Path
        
        def check_python_version():
            """–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ Python."""
            if sys.version_info < (3, 8):
                print("‚ùå –¢—Ä–µ–±—É–µ—Ç—Å—è Python 3.8 –∏–ª–∏ –≤—ã—à–µ")
                print(f"   –¢–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è: {sys.version}")
                return False
            print(f"‚úÖ Python –≤–µ—Ä—Å–∏—è: {sys.version}")
            return True
        
        def install_requirements():
            """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π."""
            requirements_file = "gui/requirements_gui.txt"
            
            if not os.path.exists(requirements_file):
                requirements_file = "requirements_gui.txt"
            
            if not os.path.exists(requirements_file):
                print("‚ùå –§–∞–π–ª requirements_gui.txt –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return False
            
            try:
                print("üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π...")
                subprocess.check_call([
                    sys.executable, "-m", "pip", "install", 
                    "--upgrade", "pip"
                ])
                
                subprocess.check_call([
                    sys.executable, "-m", "pip", "install", 
                    "-r", requirements_file
                ])
                
                print("‚úÖ –í—Å–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
                return True
            except subprocess.CalledProcessError as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: {e}")
                return False
        
        def check_main_script():
            """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞."""
            possible_paths = [
                "tools/main.py",
                "main.py", 
                "rf4s/main.py"
            ]
            
            for path in possible_paths:
                if os.path.exists(path):
                    print(f"‚úÖ –û—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç –Ω–∞–π–¥–µ–Ω: {path}")
                    return True
            
            print("‚ö†Ô∏è  –û—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
            print("   –û–∂–∏–¥–∞–µ–º—ã–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è:")
            for path in possible_paths:
                print(f"   - {path}")
            return False
        
        def create_directories():
            """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π."""
            dirs = ["screenshots", "logs", "gui/assets"]
            
            for dir_path in dirs:
                try:
                    os.makedirs(dir_path, exist_ok=True)
                    print(f"‚úÖ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å–æ–∑–¥–∞–Ω–∞: {dir_path}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å {dir_path}: {e}")
        
        def test_imports():
            """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–ø–æ—Ä—Ç–æ–≤."""
            imports_to_test = [
                ("PyQt6.QtWidgets", "PyQt6"),
                ("yaml", "PyYAML"),
                ("psutil", "psutil"),
            ]
            
            print("üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–ø–æ—Ä—Ç–æ–≤...")
            
            for module, package in imports_to_test:
                try:
                    __import__(module)
                    print(f"‚úÖ {package} –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ")
                except ImportError as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ {package}: {e}")
                    return False
            
            return True
        
        def main():
            """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏."""
            print("üöÄ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Russian Fishing 4 Script GUI")
            print("=" * 50)
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ Python
            if not check_python_version():
                sys.exit(1)
            
            # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
            if not install_requirements():
                print("\n‚ùå –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏–∑-–∑–∞ –æ—à–∏–±–æ–∫")
                sys.exit(1)
            
            # –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–ø–æ—Ä—Ç–æ–≤
            if not test_imports():
                print("\n‚ùå –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –º–æ–¥—É–ª–∏ –Ω–µ –∏–º–ø–æ—Ä—Ç–∏—Ä—É—é—Ç—Å—è")
                sys.exit(1)
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
            create_directories()
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞
            check_main_script()
            
            print("\n" + "=" * 50)
            print("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!")
            print("\nüìã –î–ª—è –∑–∞–ø—É—Å–∫–∞ GUI –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:")
            print("   python gui/run_gui.py")
            print("   –∏–ª–∏")
            print("   python run_gui.py  (–µ—Å–ª–∏ —Ñ–∞–π–ª—ã –≤ –∫–æ—Ä–Ω–µ)")
            
            print("\nüìö –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:")
            print("   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ tools/main.py")
            print("   - –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ config.yaml")
            print("   - –õ–æ–≥–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –ø–∞–ø–∫—É logs/")
            print("   - –°–∫—Ä–∏–Ω—à–æ—Ç—ã —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –ø–∞–ø–∫—É screenshots/")
        
        if __name__ == "__main__":
            main()
    üìÑ startup_validator.py
        """
        –ú–æ–¥—É–ª—å –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º —Å–∫—Ä–∏–ø—Ç–∞
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –≤—ã–≤–æ–¥–∏—Ç –ø–æ–Ω—è—Ç–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö
        """
        
        import os
        import sys
        from typing import List, Dict, Any
        from config_manager import ConfigManager
        
        
        class StartupValidator:
            """–í–∞–ª–∏–¥–∞—Ç–æ—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∫ –∑–∞–ø—É—Å–∫—É."""
            
            def __init__(self, config_manager: ConfigManager):
                self.config_manager = config_manager
                self.config = config_manager.config
                
            def validate_all(self) -> Dict[str, Any]:
                """
                –ü–æ–ª–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.
                
                Returns:
                    Dict —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏:
                    {
                        'is_valid': bool,
                        'errors': List[str],
                        'warnings': List[str],
                        'recommendations': List[str]
                    }
                """
                result = {
                    'is_valid': True,
                    'errors': [],
                    'warnings': [],
                    'recommendations': []
                }
                
                # –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
                critical_errors = self._check_critical_settings()
                result['errors'].extend(critical_errors)
                
                # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
                warnings = self._check_warnings()
                result['warnings'].extend(warnings)
                
                # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
                recommendations = self._check_recommendations()
                result['recommendations'].extend(recommendations)
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
                env_warnings = self._check_environment_variables()
                result['warnings'].extend(env_warnings)
                
                result['is_valid'] = len(result['errors']) == 0
                
                return result
            
            def _check_critical_settings(self) -> List[str]:
                """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫, –±–µ–∑ –∫–æ—Ç–æ—Ä—ã—Ö —Å–∫—Ä–∏–ø—Ç –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å."""
                errors = []
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —É–¥–∏–ª–∏—â–∞
                keys = self.config.get('KEY', {})
                main_rod = keys.get('MAIN_ROD', -1)
                if main_rod == -1:
                    errors.append(
                        "MAIN_ROD –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω (–∑–Ω–∞—á–µ–Ω–∏–µ -1). "
                        "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –Ω–æ–º–µ—Ä –∫–ª–∞–≤–∏—à–∏ –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —É–¥–∏–ª–∏—â–∞ (–æ–±—ã—á–Ω–æ 1-9)."
                    )
                elif not isinstance(main_rod, int) or main_rod < 1 or main_rod > 9:
                    errors.append(
                        f"MAIN_ROD –∏–º–µ–µ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {main_rod}. "
                        "–î–æ–ª–∂–Ω–æ –±—ã—Ç—å —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 9."
                    )
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Ñ–∏–ª–µ–π
                profiles = self.config.get('PROFILE', {})
                if not profiles:
                    errors.append("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è —Ä—ã–±–∞–ª–∫–∏.")
                else:
                    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ñ–∏–ª–µ–π
                    for profile_name, profile_config in profiles.items():
                        if not isinstance(profile_config, dict):
                            errors.append(f"–ü—Ä–æ—Ñ–∏–ª—å '{profile_name}' –∏–º–µ–µ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.")
                            continue
                            
                        mode = profile_config.get('MODE')
                        if not mode:
                            errors.append(f"–ü—Ä–æ—Ñ–∏–ª—å '{profile_name}': –Ω–µ —É–∫–∞–∑–∞–Ω MODE.")
                        elif mode not in ['spin', 'bottom', 'pirk', 'elevator', 'telescopic', 'bolognese']:
                            errors.append(f"–ü—Ä–æ—Ñ–∏–ª—å '{profile_name}': –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π MODE '{mode}'.")
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                version = self.config.get('VERSION')
                if not version:
                    errors.append("–í–µ—Ä—Å–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–∞.")
                
                return errors
            
            def _check_warnings(self) -> List[str]:
                """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –≤—ã–∑–≤–∞—Ç—å –ø—Ä–æ–±–ª–µ–º—ã."""
                warnings = []
                
                keys = self.config.get('KEY', {})
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–ª—é—á–µ–π
                if keys.get('SPOD_ROD', -1) != -1 and keys.get('SPOD_ROD') == keys.get('MAIN_ROD'):
                    warnings.append("SPOD_ROD –∏ MAIN_ROD –∏—Å–ø–æ–ª—å–∑—É—é—Ç –æ–¥–Ω—É –∏ —Ç—É –∂–µ –∫–ª–∞–≤–∏—à—É.")
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–¥–∏–ª–∏—â –¥–ª—è –¥–æ–Ω–Ω–æ–π –ª–æ–≤–ª–∏
                bottom_rods = keys.get('BOTTOM_RODS', [])
                main_rod = keys.get('MAIN_ROD', -1)
                if main_rod != -1 and main_rod not in bottom_rods:
                    warnings.append(
                        f"MAIN_ROD ({main_rod}) –Ω–µ –≤—Ö–æ–¥–∏—Ç –≤ —Å–ø–∏—Å–æ–∫ BOTTOM_RODS {bottom_rods}. "
                        "–≠—Ç–æ –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å –ø—Ä–æ–±–ª–µ–º—ã –ø—Ä–∏ –¥–æ–Ω–Ω–æ–π –ª–æ–≤–ª–µ."
                    )
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Å–∫—Ä–∏–ø—Ç–∞
                script = self.config.get('SCRIPT', {})
                spool_confidence = script.get('SPOOL_CONFIDENCE', 0.98)
                if spool_confidence < 0.9:
                    warnings.append(
                        f"SPOOL_CONFIDENCE —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {spool_confidence}, —á—Ç–æ –¥–æ–≤–æ–ª—å–Ω–æ –Ω–∏–∑–∫–æ. "
                        "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ 0.95-0.98."
                    )
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—Ä–º–æ–∑–∞ —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–∞
                friction = self.config.get('FRICTION_BRAKE', {})
                initial = friction.get('INITIAL', 29)
                max_brake = friction.get('MAX', 30)
                if initial >= max_brake:
                    warnings.append(
                        f"FRICTION_BRAKE INITIAL ({initial}) >= MAX ({max_brake}). "
                        "–≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç–µ —Ç–æ—Ä–º–æ–∑–∞."
                    )
                
                return warnings
            
            def _check_recommendations(self) -> List[str]:
                """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã."""
                recommendations = []
                
                keys = self.config.get('KEY', {})
                
                # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º –∫–ª—é—á–∞–º
                if keys.get('TEA', -1) == -1:
                    recommendations.append(
                        "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –∫–ª–∞–≤–∏—à—É TEA –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏."
                    )
                
                if keys.get('COFFEE', -1) == -1:
                    recommendations.append(
                        "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –∫–ª–∞–≤–∏—à—É COFFEE –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏."
                    )
                
                # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º
                notification = self.config.get('NOTIFICATION', {})
                if not notification.get('DISCORD_WEBHOOK_URL') and not notification.get('EMAIL'):
                    recommendations.append(
                        "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (Discord –∏–ª–∏ Email) "
                        "–¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ä–∞–±–æ—Ç–µ —Å–∫—Ä–∏–ø—Ç–∞."
                    )
                
                # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º —Å–∫—Ä–∏–ø—Ç–∞
                script = self.config.get('SCRIPT', {})
                if not script.get('SNAG_DETECTION'):
                    recommendations.append(
                        "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤–∫–ª—é—á–∏—Ç—å SNAG_DETECTION –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∑–∞—Ü–µ–ø–æ–≤."
                    )
                
                if not script.get('SPOOLING_DETECTION'):
                    recommendations.append(
                        "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤–∫–ª—é—á–∏—Ç—å SPOOLING_DETECTION –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —Å–º–∞—Ç—ã–≤–∞–Ω–∏—è –ª–µ—Å–∫–∏."
                    )
                
                return recommendations
            
            def _check_environment_variables(self) -> List[str]:
                """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è."""
                warnings = []
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ .env —Ñ–∞–π–ª–∞
                if not os.path.exists('.env'):
                    warnings.append(
                        "–§–∞–π–ª .env –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–æ–∑–¥–∞–π—Ç–µ –µ–≥–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ .env.example "
                        "–¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö."
                    )
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
                env_vars = ['DISCORD_WEBHOOK_URL', 'EMAIL', 'EMAIL_PASSWORD']
                missing_vars = []
                
                for var in env_vars:
                    if not os.getenv(var):
                        missing_vars.append(var)
                
                if missing_vars:
                    warnings.append(
                        f"–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}. "
                        "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –º–æ–≥—É—Ç –Ω–µ —Ä–∞–±–æ—Ç–∞—Ç—å."
                    )
                
                return warnings
            
            def print_validation_report(self, result: Dict[str, Any]) -> None:
                """–í—ã–≤–æ–¥ –æ—Ç—á–µ—Ç–∞ –æ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –≤ –∫–æ–Ω—Å–æ–ª—å."""
                print("=" * 60)
                print("üîç –û–¢–ß–ï–¢ –û –í–ê–õ–ò–î–ê–¶–ò–ò –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò")
                print("=" * 60)
                
                if result['is_valid']:
                    print("‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≥–æ—Ç–æ–≤–∞ –∫ –∑–∞–ø—É—Å–∫—É!")
                else:
                    print("‚ùå –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏!")
                
                print()
                
                # –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏
                if result['errors']:
                    print("üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –û–®–ò–ë–ö–ò:")
                    for i, error in enumerate(result['errors'], 1):
                        print(f"   {i}. {error}")
                    print()
                
                # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
                if result['warnings']:
                    print("‚ö†Ô∏è  –ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–Ø:")
                    for i, warning in enumerate(result['warnings'], 1):
                        print(f"   {i}. {warning}")
                    print()
                
                # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
                if result['recommendations']:
                    print("üí° –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:")
                    for i, rec in enumerate(result['recommendations'], 1):
                        print(f"   {i}. {rec}")
                    print()
                
                print("=" * 60)
                
                if not result['is_valid']:
                    print("–ò—Å–ø—Ä–∞–≤—å—Ç–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º —Å–∫—Ä–∏–ø—Ç–∞.")
                    return False
                
                return True
        
        
        def main():
            """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞."""
            if len(sys.argv) < 2:
                config_path = "config.yaml"
            else:
                config_path = sys.argv[1]
            
            try:
                # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                config_manager = ConfigManager()
                config_manager.load_config(config_path)
                
                # –í–∞–ª–∏–¥–∞—Ü–∏—è
                validator = StartupValidator(config_manager)
                result = validator.validate_all()
                
                # –í—ã–≤–æ–¥ –æ—Ç—á–µ—Ç–∞
                is_valid = validator.print_validation_report(result)
                
                # –í–æ–∑–≤—Ä–∞—Ç –∫–æ–¥–∞ –æ—à–∏–±–∫–∏
                sys.exit(0 if is_valid else 1)
                
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {e}")
                sys.exit(1)
        
        
        if __name__ == "__main__":
            main()
    üìÑ tree_with_content_beautiful.py
        import os
        import mimetypes
        
        # –†–∞—Å—à–∏—Ä–µ–Ω–∏—è –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ –∑–≤—É–∫–æ–≤
        IMAGE_EXTS = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.webp'}
        AUDIO_EXTS = {'.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a'}
        
        def is_image(filename):
            ext = os.path.splitext(filename)[1].lower()
            if ext in IMAGE_EXTS:
                return True
            mime, _ = mimetypes.guess_type(filename)
            return mime and mime.startswith('image')
        
        def is_audio(filename):
            ext = os.path.splitext(filename)[1].lower()
            if ext in AUDIO_EXTS:
                return True
            mime, _ = mimetypes.guess_type(filename)
            return mime and mime.startswith('audio')
        
        def get_file_content(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                return content
            except Exception:
                return "[ERROR: Unable to decode as UTF-8 or read file]"
        
        def tree_with_contents(start_path='.'):
            result = []
        
            for root, dirs, files in os.walk(start_path):
                level = root.replace(start_path, '').count(os.sep)
                indent = '    ' * level
                folder_name = os.path.basename(root) or os.path.abspath(root)
                result.append(f"{indent}üìÅ {folder_name}/")
                subindent = '    ' * (level + 1)
                for fname in files:
                    fpath = os.path.join(root, fname)
                    f_disp = f"{subindent}üìÑ {fname}"
                    if is_image(fname):
                        result.append(f"{f_disp} [IMAGE FILE]")
                    elif is_audio(fname):
                        result.append(f"{f_disp} [AUDIO FILE]")
                    else:
                        result.append(f"{f_disp}")
                        content = get_file_content(fpath)
                        # –ö—Ä–∞—Å–∏–≤–æ –≤—ã–≤–æ–¥–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
                        content_lines = content.splitlines()
                        for line in content_lines:
                            result.append(f"{subindent}    {line}")
                        if not content_lines:
                            result.append(f"{subindent}    [EMPTY FILE]")
            return '\n'.join(result)
        
        if __name__ == "__main__":
            output_file = "tree_with_contents.txt"
            folder = '.'
            tree_str = tree_with_contents(folder)
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(tree_str)
            print(f"–î–µ—Ä–µ–≤–æ —Ñ–∞–π–ª–æ–≤ –∏ –∏—Ö —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ {output_file}")
    üìÑ ui_theme.py
        """
        Modern UI themes for Russian Fishing 4 Script GUI
        –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–µ–º—ã –¥–ª—è GUI —Å–∫—Ä–∏–ø—Ç–∞ Russian Fishing 4
        """
        
        def get_discord_theme():
            """Get Discord-inspired dark theme with modern Windows 11 styling."""
            return """
            /* ===== MAIN WINDOW ===== */
            QMainWindow {
                background-color: #36393f;
                color: #dcddde;
                font-family: 'Segoe UI', Tahoma, Arial, sans-serif;
                font-size: 9pt;
            }
            
            /* ===== CENTRAL WIDGET ===== */
            QWidget {
                background-color: #36393f;
                color: #dcddde;
                selection-background-color: #5865f2;
                selection-color: #ffffff;
            }
            
            /* ===== TOOLBAR ===== */
            QWidget#toolbar_widget {
                background-color: #2f3136;
                border-bottom: 1px solid #202225;
                padding: 8px;
                border-radius: 0px;
            }
            
            /* ===== TABS ===== */
            QTabWidget::pane {
                border: 1px solid #202225;
                background-color: #36393f;
                border-radius: 8px;
                margin-top: 8px;
            }
            
            QTabWidget::tab-bar {
                alignment: left;
            }
            
            QTabBar::tab {
                background-color: #2f3136;
                color: #b9bbbe;
                padding: 12px 20px;
                margin-right: 2px;
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
                border: 1px solid #202225;
                border-bottom: none;
                min-width: 120px;
                font-weight: 500;
            }
            
            QTabBar::tab:selected {
                background-color: #36393f;
                color: #ffffff;
                border-color: #5865f2;
                border-bottom: 2px solid #5865f2;
            }
            
            QTabBar::tab:hover:!selected {
                background-color: #34373c;
                color: #dcddde;
            }
            
            /* ===== BUTTONS ===== */
            QPushButton {
                background-color: #4f545c;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 10px 16px;
                font-weight: 500;
                font-size: 9pt;
                min-height: 18px;
            }
            
            QPushButton:hover {
                background-color: #5865f2;
                transform: translateY(-1px);
            }
            
            QPushButton:pressed {
                background-color: #4752c4;
                transform: translateY(0px);
            }
            
            QPushButton:disabled {
                background-color: #2f3136;
                color: #72767d;
            }
            
            /* Primary Buttons */
            QPushButton#primary {
                background-color: #5865f2;
                color: #ffffff;
                font-weight: 600;
            }
            
            QPushButton#primary:hover {
                background-color: #4752c4;
            }
            
            /* Success Buttons */
            QPushButton#success {
                background-color: #3ba55d;
                color: #ffffff;
            }
            
            QPushButton#success:hover {
                background-color: #2d7d32;
            }
            
            /* Danger Buttons */
            QPushButton#danger {
                background-color: #ed4245;
                color: #ffffff;
            }
            
            QPushButton#danger:hover {
                background-color: #c62828;
            }
            
            /* ===== GROUP BOXES ===== */
            QGroupBox {
                background-color: #2f3136;
                border: 1px solid #202225;
                border-radius: 8px;
                margin-top: 12px;
                padding-top: 8px;
                font-weight: 600;
                font-size: 10pt;
            }
            
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 12px;
                padding: 0 8px 0 8px;
                color: #ffffff;
                background-color: #2f3136;
                border-radius: 4px;
            }
            
            /* ===== INPUT FIELDS ===== */
            QLineEdit, QTextEdit, QPlainTextEdit {
                background-color: #40444b;
                border: 1px solid #202225;
                border-radius: 6px;
                padding: 8px 12px;
                color: #dcddde;
                selection-background-color: #5865f2;
                font-size: 9pt;
            }
            
            QLineEdit:focus, QTextEdit:focus, QPlainTextEdit:focus {
                border-color: #5865f2;
                background-color: #36393f;
            }
            
            QLineEdit:hover, QTextEdit:hover, QPlainTextEdit:hover {
                border-color: #4f545c;
            }
            
            QLineEdit::placeholder, QTextEdit::placeholder {
                color: #72767d;
            }
            
            /* ===== COMBO BOXES ===== */
            QComboBox {
                background-color: #40444b;
                border: 1px solid #202225;
                border-radius: 6px;
                padding: 8px 12px;
                color: #dcddde;
                min-width: 100px;
            }
            
            QComboBox:hover {
                border-color: #4f545c;
                background-color: #36393f;
            }
            
            QComboBox:focus {
                border-color: #5865f2;
            }
            
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            
            QComboBox::down-arrow {
                image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iOCIgdmlld0JveD0iMCAwIDEyIDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0xIDFMNiA2TDExIDEiIHN0cm9rZT0iIzk5OUFBMiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+);
                width: 12px;
                height: 8px;
                margin-right: 8px;
            }
            
            QComboBox QAbstractItemView {
                background-color: #2f3136;
                border: 1px solid #202225;
                border-radius: 6px;
                color: #dcddde;
                selection-background-color: #5865f2;
                outline: none;
                padding: 4px;
            }
            
            QComboBox QAbstractItemView::item {
                padding: 8px 12px;
                border-radius: 4px;
                margin: 1px;
            }
            
            QComboBox QAbstractItemView::item:hover {
                background-color: #4f545c;
            }
            
            QComboBox QAbstractItemView::item:selected {
                background-color: #5865f2;
            }
            
            /* ===== SPIN BOXES ===== */
            QSpinBox, QDoubleSpinBox {
                background-color: #40444b;
                border: 1px solid #202225;
                border-radius: 6px;
                padding: 8px 12px;
                color: #dcddde;
            }
            
            QSpinBox:hover, QDoubleSpinBox:hover {
                border-color: #4f545c;
                background-color: #36393f;
            }
            
            QSpinBox:focus, QDoubleSpinBox:focus {
                border-color: #5865f2;
            }
            
            QSpinBox::up-button, QDoubleSpinBox::up-button {
                border: none;
                background-color: transparent;
                width: 16px;
            }
            
            QSpinBox::down-button, QDoubleSpinBox::down-button {
                border: none;
                background-color: transparent;
                width: 16px;
            }
            
            /* ===== CHECKBOXES ===== */
            QCheckBox {
                color: #dcddde;
                spacing: 8px;
                font-size: 9pt;
            }
            
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border-radius: 4px;
                border: 2px solid #4f545c;
                background-color: #40444b;
            }
            
            QCheckBox::indicator:hover {
                border-color: #5865f2;
                background-color: #36393f;
            }
            
            QCheckBox::indicator:checked {
                background-color: #5865f2;
                border-color: #5865f2;
                image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iOCIgdmlld0JveD0iMCAwIDEwIDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik04LjUgMUwzLjUgNkwxLjUgNCIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+);
            }
            
            /* ===== LABELS ===== */
            QLabel {
                color: #dcddde;
                font-size: 9pt;
            }
            
            QLabel#title {
                font-size: 12pt;
                font-weight: 600;
                color: #ffffff;
            }
            
            QLabel#subtitle {
                color: #b9bbbe;
                font-size: 8pt;
            }
            
            /* ===== PROGRESS BAR ===== */
            QProgressBar {
                background-color: #2f3136;
                border: 1px solid #202225;
                border-radius: 8px;
                height: 16px;
                text-align: center;
                color: #ffffff;
                font-weight: 500;
            }
            
            QProgressBar::chunk {
                background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0, 
                    stop:0 #5865f2, stop:1 #7289da);
                border-radius: 7px;
                margin: 1px;
            }
            
            /* ===== SCROLL AREAS ===== */
            QScrollArea {
                background-color: #36393f;
                border: 1px solid #202225;
                border-radius: 8px;
            }
            
            QScrollBar:vertical {
                background-color: #2f3136;
                width: 12px;
                border-radius: 6px;
                margin: 0;
            }
            
            QScrollBar::handle:vertical {
                background-color: #4f545c;
                border-radius: 6px;
                min-height: 20px;
                margin: 2px;
            }
            
            QScrollBar::handle:vertical:hover {
                background-color: #5865f2;
            }
            
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                border: none;
                background: none;
                height: 0;
            }
            
            /* ===== SPLITTER ===== */
            QSplitter::handle {
                background-color: #202225;
                width: 2px;
                height: 2px;
            }
            
            QSplitter::handle:hover {
                background-color: #5865f2;
            }
            
            /* ===== STATUS BAR ===== */
            QStatusBar {
                background-color: #2f3136;
                border-top: 1px solid #202225;
                color: #b9bbbe;
                padding: 4px;
            }
            
            QStatusBar QLabel {
                color: #b9bbbe;
                font-size: 8pt;
                padding: 2px 8px;
            }
            
            /* ===== SEPARATORS ===== */
            QFrame[frameShape="4"] {
                color: #202225;
                background-color: #202225;
                max-height: 1px;
            }
            
            QFrame[frameShape="5"] {
                color: #202225;
                background-color: #202225;
                max-width: 1px;
            }
            
            /* ===== TEXT AREAS (LOG VIEWER) ===== */
            QTextEdit#log_viewer {
                background-color: #202225;
                border: 1px solid #0d1117;
                border-radius: 8px;
                color: #dcddde;
                font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
                font-size: 9pt;
                padding: 12px;
                line-height: 1.4;
            }
            
            /* ===== MENU BAR ===== */
            QMenuBar {
                background-color: #2f3136;
                color: #dcddde;
                border-bottom: 1px solid #202225;
                padding: 4px;
            }
            
            QMenuBar::item {
                background-color: transparent;
                padding: 8px 12px;
                border-radius: 4px;
            }
            
            QMenuBar::item:selected {
                background-color: #4f545c;
            }
            
            QMenu {
                background-color: #2f3136;
                border: 1px solid #202225;
                border-radius: 8px;
                padding: 4px;
                color: #dcddde;
            }
            
            QMenu::item {
                padding: 8px 16px;
                border-radius: 4px;
                margin: 1px;
            }
            
            QMenu::item:selected {
                background-color: #5865f2;
            }
            
            QMenu::separator {
                height: 1px;
                background-color: #202225;
                margin: 4px 8px;
            }
            
            /* ===== TOOLTIPS ===== */
            QToolTip {
                background-color: #0d1117;
                color: #ffffff;
                border: 1px solid #30363d;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 8pt;
            }
            
            /* ===== CUSTOM ANIMATIONS ===== */
            QPushButton {
                transition: all 0.2s ease;
            }
            
            QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox {
                transition: border-color 0.2s ease, background-color 0.2s ease;
            }
            """
        
        def get_light_theme():
            """Get modern light theme inspired by Windows 11."""
            return """
            /* ===== MAIN WINDOW ===== */
            QMainWindow {
                background-color: #f8f9fa;
                color: #1f2328;
                font-family: 'Segoe UI', Tahoma, Arial, sans-serif;
                font-size: 9pt;
            }
            
            QWidget {
                background-color: #f8f9fa;
                color: #1f2328;
                selection-background-color: #0969da;
                selection-color: #ffffff;
            }
            
            /* ===== TOOLBAR ===== */
            QWidget#toolbar_widget {
                background-color: #ffffff;
                border-bottom: 1px solid #d0d7de;
                padding: 8px;
                border-radius: 0px;
            }
            
            /* ===== TABS ===== */
            QTabWidget::pane {
                border: 1px solid #d0d7de;
                background-color: #ffffff;
                border-radius: 8px;
                margin-top: 8px;
            }
            
            QTabBar::tab {
                background-color: #f6f8fa;
                color: #656d76;
                padding: 12px 20px;
                margin-right: 2px;
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
                border: 1px solid #d0d7de;
                border-bottom: none;
                min-width: 120px;
                font-weight: 500;
            }
            
            QTabBar::tab:selected {
                background-color: #ffffff;
                color: #1f2328;
                border-color: #0969da;
                border-bottom: 2px solid #0969da;
            }
            
            QTabBar::tab:hover:!selected {
                background-color: #f3f4f6;
                color: #1f2328;
            }
            
            /* ===== BUTTONS ===== */
            QPushButton {
                background-color: #f6f8fa;
                color: #24292f;
                border: 1px solid #d0d7de;
                border-radius: 6px;
                padding: 10px 16px;
                font-weight: 500;
                font-size: 9pt;
                min-height: 18px;
            }
            
            QPushButton:hover {
                background-color: #0969da;
                color: #ffffff;
                border-color: #0969da;
            }
            
            QPushButton:pressed {
                background-color: #0860ca;
                border-color: #0860ca;
            }
            
            QPushButton:disabled {
                background-color: #f6f8fa;
                color: #8c959f;
                border-color: #d0d7de;
            }
            
            /* ===== GROUP BOXES ===== */
            QGroupBox {
                background-color: #ffffff;
                border: 1px solid #d0d7de;
                border-radius: 8px;
                margin-top: 12px;
                padding-top: 8px;
                font-weight: 600;
                font-size: 10pt;
            }
            
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 12px;
                padding: 0 8px 0 8px;
                color: #1f2328;
                background-color: #ffffff;
                border-radius: 4px;
            }
            
            /* ===== INPUT FIELDS ===== */
            QLineEdit, QTextEdit, QPlainTextEdit {
                background-color: #ffffff;
                border: 1px solid #d0d7de;
                border-radius: 6px;
                padding: 8px 12px;
                color: #1f2328;
                selection-background-color: #0969da;
                font-size: 9pt;
            }
            
            QLineEdit:focus, QTextEdit:focus, QPlainTextEdit:focus {
                border-color: #0969da;
                box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.12);
            }
            
            QLineEdit:hover, QTextEdit:hover, QPlainTextEdit:hover {
                border-color: #8c959f;
            }
            
            /* ===== COMBO BOXES ===== */
            QComboBox {
                background-color: #ffffff;
                border: 1px solid #d0d7de;
                border-radius: 6px;
                padding: 8px 12px;
                color: #1f2328;
                min-width: 100px;
            }
            
            QComboBox:hover {
                border-color: #8c959f;
            }
            
            QComboBox:focus {
                border-color: #0969da;
            }
            
            QComboBox QAbstractItemView {
                background-color: #ffffff;
                border: 1px solid #d0d7de;
                border-radius: 6px;
                color: #1f2328;
                selection-background-color: #0969da;
                outline: none;
                padding: 4px;
            }
            
            /* ===== CHECKBOXES ===== */
            QCheckBox {
                color: #1f2328;
                spacing: 8px;
                font-size: 9pt;
            }
            
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border-radius: 4px;
                border: 1px solid #d0d7de;
                background-color: #ffffff;
            }
            
            QCheckBox::indicator:hover {
                border-color: #0969da;
            }
            
            QCheckBox::indicator:checked {
                background-color: #0969da;
                border-color: #0969da;
            }
            
            /* ===== STATUS BAR ===== */
            QStatusBar {
                background-color: #f6f8fa;
                border-top: 1px solid #d0d7de;
                color: #656d76;
                padding: 4px;
            }
            
            /* ===== LOG VIEWER ===== */
            QTextEdit#log_viewer {
                background-color: #0d1117;
                border: 1px solid #30363d;
                border-radius: 8px;
                color: #e6edf3;
                font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
                font-size: 9pt;
                padding: 12px;
            }
            """
        
        def get_dark_theme():
            """Get dark theme - same as Discord theme."""
            return get_discord_theme()
    üìÅ gui/
        üìÅ assets/
    üìÅ logs/
    üìÅ rf4s/
        üìÑ exceptions.py
            """
            RF4S Exception classes
            –ö–ª–∞—Å—Å—ã –∏—Å–∫–ª—é—á–µ–Ω–∏–π RF4S
            """
            
            class FishHookedError(Exception):
                """A fish is hooked during a wrong routine."""
                pass
            
            class FishCapturedError(Exception):
                """A fish is captured during a wrong routine."""
                pass
            
            class LineAtEndError(Exception):
                """Fishing line is at the end during retrieval."""
                pass
            
            class LineSnaggedError(Exception):
                """Fishing line is snagged."""
                pass
            
            class ItemNotFoundError(Exception):
                """Failed to find an available item for replacement."""
                pass
            
            class LureBrokenError(Exception):
                """Lure is broken."""
                pass
            
            class TackleBrokenError(Exception):
                """Tackle is broken."""
                pass
            
            class DisconnectedError(Exception):
                """Disconnected from the game."""
                pass
            
            class TicketExpiredError(Exception):
                """Ticket expired."""
                pass
            
            class ValidationError(Exception):
                """Environment validation failed."""
                pass
            
            class ConfigurationError(Exception):
                """Configuration file error."""
                pass
            
            class GameWindowError(Exception):
                """Game window not found or invalid."""
                pass
            
            # –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞
            __all__ = [
                'FishHookedError',
                'FishCapturedError', 
                'LineAtEndError',
                'LineSnaggedError',
                'ItemNotFoundError',
                'LureBrokenError',
                'TackleBrokenError',
                'DisconnectedError',
                'TicketExpiredError',
                'ValidationError',
                'ConfigurationError',
                'GameWindowError'
            ]
        üìÑ player.py
            """
            RF4S Player management
            –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–º RF4S
            """
            
            import time
            import logging
            
            logger = logging.getLogger("rich")
            
            class Player:
                """Player state and statistics management."""
                
                def __init__(self, config=None):
                    """Initialize player with configuration."""
                    self.config = config
                    self.reset_stats()
                    
                def reset_stats(self):
                    """Reset all player statistics."""
                    self.energy = 1.0
                    self.hunger = 1.0  
                    self.comfort = 1.0
                    self.experience = 0
                    self.level = 1
                    self.money = 0
                    
                    # Consumables tracking
                    self.tea_consumed = 0
                    self.carrot_consumed = 0
                    self.coffee_consumed = 0
                    self.alcohol_consumed = 0
                    
                    # Fishing statistics
                    self.fish_caught = 0
                    self.casts_made = 0
                    self.bait_used = 0
                    
                    # Time tracking
                    self.session_start_time = time.time()
                    self.last_activity_time = time.time()
                    
                def get_energy_level(self) -> float:
                    """Get current energy level (0.0 - 1.0)."""
                    return self.energy
                    
                def get_hunger_level(self) -> float:
                    """Get current hunger level (0.0 - 1.0)."""
                    return self.hunger
                    
                def get_comfort_level(self) -> float:
                    """Get current comfort level (0.0 - 1.0)."""
                    return self.comfort
                    
                def is_energy_low(self, threshold=0.74) -> bool:
                    """Check if energy is below threshold."""
                    if self.config and hasattr(self.config, 'STAT') and hasattr(self.config.STAT, 'ENERGY_THRESHOLD'):
                        threshold = self.config.STAT.ENERGY_THRESHOLD
                    return self.energy < threshold
                    
                def is_hunger_low(self, threshold=0.5) -> bool:
                    """Check if hunger is below threshold."""
                    if self.config and hasattr(self.config, 'STAT') and hasattr(self.config.STAT, 'HUNGER_THRESHOLD'):
                        threshold = self.config.STAT.HUNGER_THRESHOLD
                    return self.hunger < threshold
                    
                def is_comfort_low(self, threshold=0.51) -> bool:
                    """Check if comfort is below threshold."""
                    if self.config and hasattr(self.config, 'STAT') and hasattr(self.config.STAT, 'COMFORT_THRESHOLD'):
                        threshold = self.config.STAT.COMFORT_THRESHOLD
                    return self.comfort < threshold
                    
                def consume_tea(self):
                    """Consume tea to restore comfort."""
                    self.tea_consumed += 1
                    self.comfort = min(1.0, self.comfort + 0.3)
                    self.last_activity_time = time.time()
                    logger.info(f"Tea consumed. Comfort: {self.comfort:.2f}")
                    
                def consume_carrot(self):
                    """Consume carrot to restore hunger."""
                    self.carrot_consumed += 1
                    self.hunger = min(1.0, self.hunger + 0.25)
                    self.last_activity_time = time.time()
                    logger.info(f"Carrot consumed. Hunger: {self.hunger:.2f}")
                    
                def consume_coffee(self):
                    """Consume coffee to restore energy."""
                    self.coffee_consumed += 1
                    self.energy = min(1.0, self.energy + 0.4)
                    self.last_activity_time = time.time()
                    logger.info(f"Coffee consumed. Energy: {self.energy:.2f}")
                    
                def consume_alcohol(self):
                    """Consume alcohol to restore comfort and energy."""
                    self.alcohol_consumed += 1
                    self.comfort = min(1.0, self.comfort + 0.4)
                    self.energy = min(1.0, self.energy + 0.2)
                    self.last_activity_time = time.time()
                    logger.info(f"Alcohol consumed. Comfort: {self.comfort:.2f}, Energy: {self.energy:.2f}")
                    
                def catch_fish(self, experience_gain=10):
                    """Record a fish catch."""
                    self.fish_caught += 1
                    self.experience += experience_gain
                    self.last_activity_time = time.time()
                    
                    # Decrease stats slightly
                    self.energy = max(0.0, self.energy - 0.02)
                    self.hunger = max(0.0, self.hunger - 0.01)
                    self.comfort = max(0.0, self.comfort - 0.01)
                    
                    logger.info(f"Fish caught! Total: {self.fish_caught}")
                    
                def make_cast(self):
                    """Record a cast."""
                    self.casts_made += 1
                    self.last_activity_time = time.time()
                    
                    # Decrease stats slightly
                    self.energy = max(0.0, self.energy - 0.005)
                    self.hunger = max(0.0, self.hunger - 0.003)
                    
                def use_bait(self):
                    """Record bait usage."""
                    self.bait_used += 1
                    
                def get_session_duration(self) -> float:
                    """Get session duration in seconds."""
                    return time.time() - self.session_start_time
                    
                def get_time_since_activity(self) -> float:
                    """Get time since last activity in seconds."""
                    return time.time() - self.last_activity_time
                    
                def get_statistics(self) -> dict:
                    """Get player statistics."""
                    session_duration = self.get_session_duration()
                    
                    return {
                        'level': self.level,
                        'experience': self.experience,
                        'money': self.money,
                        'energy': f"{self.energy:.2f}",
                        'hunger': f"{self.hunger:.2f}",
                        'comfort': f"{self.comfort:.2f}",
                        'fish_caught': self.fish_caught,
                        'casts_made': self.casts_made,
                        'bait_used': self.bait_used,
                        'tea_consumed': self.tea_consumed,
                        'carrot_consumed': self.carrot_consumed,
                        'coffee_consumed': self.coffee_consumed,
                        'alcohol_consumed': self.alcohol_consumed,
                        'session_duration': f"{session_duration:.1f}s",
                        'fish_per_hour': int(self.fish_caught / max(0.01, session_duration / 3600))
                    }
                    
                def update_from_detection(self, energy=None, hunger=None, comfort=None):
                    """Update player stats from game detection."""
                    if energy is not None:
                        self.energy = energy
                    if hunger is not None:
                        self.hunger = hunger
                    if comfort is not None:
                        self.comfort = comfort
                        
                    self.last_activity_time = time.time()
                    
                def simulate_time_passage(self, minutes=1):
                    """Simulate time passage (for testing)."""
                    # Decrease stats over time
                    time_factor = minutes / 60  # Convert to hours
                    
                    self.energy = max(0.0, self.energy - (0.1 * time_factor))
                    self.hunger = max(0.0, self.hunger - (0.08 * time_factor))
                    self.comfort = max(0.0, self.comfort - (0.05 * time_factor))
                    
                def needs_attention(self) -> list:
                    """Get list of stats that need attention."""
                    needs = []
                    
                    if self.is_energy_low():
                        needs.append('energy')
                    if self.is_hunger_low():
                        needs.append('hunger')
                    if self.is_comfort_low():
                        needs.append('comfort')
                        
                    return needs
                    
                def get_recommended_action(self) -> str:
                    """Get recommended action based on current stats."""
                    needs = self.needs_attention()
                    
                    if 'energy' in needs:
                        return 'consume_coffee'
                    elif 'hunger' in needs:
                        return 'consume_carrot'
                    elif 'comfort' in needs:
                        return 'consume_tea'
                    else:
                        return 'continue_fishing'
                        
                def __str__(self) -> str:
                    """String representation of player."""
                    return (f"Player(energy={self.energy:.2f}, hunger={self.hunger:.2f}, "
                            f"comfort={self.comfort:.2f}, fish={self.fish_caught})")
                            
                def __repr__(self) -> str:
                    """Detailed representation of player."""
                    return (f"Player(level={self.level}, energy={self.energy:.2f}, "
                            f"hunger={self.hunger:.2f}, comfort={self.comfort:.2f}, "
                            f"fish_caught={self.fish_caught}, casts={self.casts_made})")
            
            # –≠–∫—Å–ø–æ—Ä—Ç –∫–ª–∞—Å—Å–∞
            __all__ = ['Player']
        üìÑ utils.py
            """Helper functions for automation scripts.
            
            This module provides utility functions for common tasks such as mouse control,
            keyboard input, and result display. It also includes decorators for managing
            key and mouse states during automation.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import ctypes
            import logging
            import msvcrt
            import shlex
            import sys
            from time import sleep
            
            import pyautogui as pag
            from pyscreeze import Box
            from rich.console import Console
            from rich.logging import RichHandler
            from rich.text import Text
            
            # BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
            BASE_DELAY = 1.2
            LOOP_DELAY = 1
            
            ANIMATION_DELAY = 1
            
            logger = logging.getLogger("rich")
            
            # ---------------------------------------------------------------------------- #
            #                            common functionalities                            #
            # ---------------------------------------------------------------------------- #
            
            
            def hold_mouse_button(duration: float = 1, button: str = "left") -> None:
                """Hold left or right mouse button.
            
                :param duration: Hold time, defaults to 1.
                :type duration: float, optional
                :param button: Button to click, defaults to "left".
                :type button: str, optional
                """
                if duration == 0:
                    return
            
                pag.mouseDown(button=button)
                sleep(duration)
                pag.mouseUp(button=button)
                if button == "left" and duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
                    pag.click()
            
            
            def hold_mouse_buttons(duration: float = 1) -> None:
                """Hold left and right mouse buttons simultaneously.
            
                :param duration: Hold time, defaults to 1.
                :type duration: float, optional
                """
                pag.mouseDown()
                pag.mouseDown(button="right")
                sleep(duration)
                pag.mouseUp()
                pag.mouseUp(button="right")
                if duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
                    pag.click()
            
            
            def sleep_and_decrease(num: int, delay: int) -> int:
                """Self-decrement with a delay.
            
                :param num: The variable to decrease.
                :type num: int
                :param delay: Sleep time.
                :type delay: int
                :return: Decreased num.
                :rtype: int
                """
                sleep(delay)
                return num - delay
            
            
            def ask_for_confirmation(msg: str = "Ready to start") -> None:
                """Ask for confirmation of user settings if it's enabled.
            
                :param msg: Confirmation message, defaults to "Ready to start".
                :type msg: str
                """
                while True:
                    ans = input(f"{msg}? [Y/n] ").strip().lower()
                    if ans in ("y", ""):
                        break
                    if ans == "n":
                        sys.exit()
            
            
            def get_box_center(box: Box) -> tuple[int, int]:
                """Get the center coordinate (x, y) of the given box.
            
                # (x, y, w, h) -> (x, y), np.int64 -> int
            
                :param box: Box coordinates (x, y, w, h).
                :type box: Box
                :return: x and y coordinates of the center point.
                :rtype: tuple[int, int]
                """
                return int(box.left + box.width // 2), int(box.top + box.height // 2)
            
            
            def create_rich_logger() -> RichHandler:
                """Create a default RichHandler for logging.
            
                :return: Logging handler from rich.
                :rtype: RichHandler
                """
                # Ignore %(name)s because it's too verbose
                # https://rich.readthedocs.io/en/latest/logging.html
                logging.basicConfig(
                    level=logging.INFO,
                    format="%(message)s",
                    datefmt="%Y-%m-%d %H:%M:%S",
                    handlers=[RichHandler(rich_tracebacks=True)],
                )
                return logging.getLogger("rich")
            
            
            # ---------------------------------------------------------------------------- #
            #                                  decorators                                  #
            # ---------------------------------------------------------------------------- #
            
            
            # def toggle_clicklock(func):
            #     """Toggle clicklock before and after calling the function."""
            
            #     def wrapper(self, *args, **kwargs):
            #         # ELECTRO must be enabled, always use electric mode if GEAR_RATIO is disabled
            #         # otherwise, only use electric mode when it's the first time
            #         if self.cfg.ARGS.ELECTRO and (
            #             not self.cfg.ARGS.GEAR_RATIO or (not args or args[0])
            #         ):
            #             pag.click(clicks=2, interval=0.1)
            #         else:
            #             pag.mouseDown()
            #         sleep(BASE_DELAY + LOOP_DELAY)
            #         try:
            #             func(self, *args, **kwargs)
            #         finally:
            #             if self.cfg.ARGS.ELECTRO:
            #                 pag.click(clicks=2, interval=0.1)
            #             else:
            #                 pag.click()
            
            #     return wrapper
            
            
            def toggle_right_mouse_button(func):
                """Toggle right mouse button before and after calling the function."""
            
                def wrapper(*args, **kwargs):
                    pag.mouseDown(button="right")
                    try:
                        func(*args, **kwargs)
                    finally:
                        pag.mouseUp(button="right")
            
                return wrapper
            
            
            def press_before_and_after(key):
                def func_wrapper(func):
                    def args_wrapper(*args, **kwargs):
                        pag.press(key)
                        sleep(ANIMATION_DELAY)
                        try:
                            func(*args, **kwargs)
                        finally:
                            pag.press(key)
                            sleep(ANIMATION_DELAY)
            
                    return args_wrapper
            
                return func_wrapper
            
            
            def release_keys_after(arrow_keys: bool = False):
                """Release keys that might have been holding down
            
                :param arrow_keys: whether to toggle arrow keys, defaults to False
                :type arrow_keys: bool, optional
                """
            
                def release_keys(arrow_keys):
                    pag.keyUp("ctrl")
                    pag.keyUp("shift")
                    if arrow_keys:
                        pag.keyUp("w")
                        pag.keyUp("a")
                        pag.keyUp("d")
            
                def func_wrapper(func):  # Capture arrow_keys as default arg
                    def args_wrapper(*args, **kwargs):
                        try:
                            return func(*args, **kwargs)
                        finally:
                            release_keys(arrow_keys)  # Uses the captured value
            
                    return args_wrapper
            
                return func_wrapper
            
            
            def print_error(msg):
                text = Text(msg)
                text.stylize("red")
                Console().print(text)
            
            
            # There's lots of early return in player._resetting_stage(),
            # so use a decorator here to simplify the code
            def reset_friction_brake_after(func):
                """Reset friction brake after calling the function."""
            
                def wrapper(self, *args, **kwargs):
                    func(self, *args, **kwargs)
                    if not self.cfg.ARGS.FRICTION_BRAKE:
                        return
            
                    with self.friction_brake_lock:
                        self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)
            
                return wrapper
            
            
            def is_compiled():
                return "__compiled__" in globals()  # Nuitka style
            
            
            def is_run_by_clicking():
                # Load kernel32.dll
                kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
                # Create an array to store the processes in.  This doesn't actually need to
                # be large enough to store the whole process list since GetConsoleProcessList()
                # just returns the number of processes if the array is too small.
                process_array = (ctypes.c_uint * 1)()
                num_processes = kernel32.GetConsoleProcessList(process_array, 1)
                # num_processes may be 1 if your compiled program doesn't have a launcher/wrapper.
                # If run from Python interpreter, num_processes would also be 2
                # We also need to check if it's an executable to make it work
                return is_compiled() and num_processes == 2
            
            
            def update_argv():
                if is_run_by_clicking():
                    logger.info("No launch options used")
                    sys.argv = ["foo"] + shlex.split(
                        input("Enter launch options (press Enter to skip): ")
                    )
            
            
            def safe_exit():
                if is_run_by_clicking():
                    print("Press any key to quit.")
                    # KeyboardInterrupt will mess with stdin, input will crash silently
                    # Use msvcrt.getch() because it doesn't depends on stdin
                    msvcrt.getch()
                sys.exit()
        üìÑ __init__.py
            """RF4S - Russian Fishing 4 Script Package"""
            __version__ = "0.5.2"
            __author__ = "RF4S Team"
            
            import sys
            import os
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –≤ –ø—É—Ç—å –¥–ª—è –∏–º–ø–æ—Ä—Ç–æ–≤
            current_dir = os.path.dirname(os.path.abspath(__file__))
            if current_dir not in sys.path:
                sys.path.insert(0, current_dir)
            
            # –û—Å–Ω–æ–≤–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            try:
                from .exceptions import *
                from .app.app import ToolApp, App, MainApp
                from .utils import safe_exit, create_rich_logger
            except ImportError as e:
                print(f"Warning: Some RF4S modules not available: {e}")
        üìÅ app/
            üìÑ app.py
                """RF4S Application classes - Full implementation"""
                import sys
                import os
                import time
                import argparse
                import logging
                from abc import ABC, abstractmethod
                from multiprocessing import Lock
                
                # –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç–∏ –¥–ª—è –∏–º–ø–æ—Ä—Ç–æ–≤
                current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
                sys.path.insert(0, current_dir)
                
                logger = logging.getLogger("rich")
                
                # Fallback –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
                class FallbackConfig:
                    def __init__(self):
                        self.FRICTION_BRAKE = type('obj', (object,), {
                            'INITIAL': 29,
                            'MAX': 30,
                            'START_DELAY': 2.0,
                            'INCREASE_DELAY': 1.0,
                            'SENSITIVITY': 'medium'
                        })()
                        
                        self.ARGS = type('obj', (object,), {
                            'QUIT_KEY': "'h'",
                            'RESET_KEY': "'g'"
                        })()
                        
                        self.KEY = type('obj', (object,), {
                            'QUIT': 'CTRL-C'
                        })()
                        
                        self.SCRIPT = type('obj', (object,), {
                            'LANGUAGE': 'en'
                        })()
                    
                    def freeze(self): pass
                    def defrost(self): pass
                    def merge_from_file(self, path): 
                        if os.path.exists(path):
                            try:
                                import yaml
                                with open(path, 'r', encoding='utf-8') as f:
                                    data = yaml.safe_load(f)
                                print(f"‚úÖ Config loaded: {path}")
                                return data
                            except Exception as e:
                                print(f"‚ö†Ô∏è Config load error: {e}")
                        return None
                    def merge_from_other_cfg(self, other): pass
                    def merge_from_list(self, opts): pass
                
                # Fallback –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
                class FallbackDetection:
                    def __init__(self, cfg, window):
                        self.cfg = cfg
                        self.window = window
                
                class FallbackWindow:
                    def __init__(self): pass
                    def is_title_bar_exist(self): return False
                    def is_size_supported(self): return True
                    def get_resolution_str(self): return "1920x1080"
                    def activate_game_window(self): print("üéÆ –ê–∫—Ç–∏–≤–∞—Ü–∏—è –æ–∫–Ω–∞ –∏–≥—Ä—ã...")
                    def activate_script_window(self): print("üíª –ê–∫—Ç–∏–≤–∞—Ü–∏—è –æ–∫–Ω–∞ —Å–∫—Ä–∏–ø—Ç–∞...")
                
                class FallbackResult:
                    def __init__(self): self.data = {}
                    def as_dict(self): return self.data
                
                class App(ABC):
                    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
                    
                    def __init__(self):
                        self.cfg = FallbackConfig()
                        
                        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
                        config_path = "config.yaml"
                        self.cfg.merge_from_file(config_path)
                        
                        self.window = FallbackWindow()
                
                    def _on_release(self, key):
                        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –∫–ª–∞–≤–∏—à"""
                        try:
                            if hasattr(key, 'char') and key.char:
                                char = key.char.lower()
                            else:
                                char = str(key).lower().replace("'", "")
                            
                            quit_key = self.cfg.ARGS.QUIT_KEY.replace("'", "").lower()
                            reset_key = self.cfg.ARGS.RESET_KEY.replace("'", "").lower()
                            
                            if char == quit_key:
                                print(f"üõë –ù–∞–∂–∞—Ç–∞ –∫–ª–∞–≤–∏—à–∞ –≤—ã—Ö–æ–¥–∞: {quit_key}")
                                if hasattr(self, 'friction_brake') and self.friction_brake:
                                    try:
                                        self.friction_brake.monitor_process.terminate()
                                    except:
                                        pass
                                sys.exit()
                                
                            if char == reset_key and hasattr(self, 'friction_brake'):
                                try:
                                    self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)
                                except:
                                    print(f"üîÑ –°–±—Ä–æ—Å —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ç–æ—Ä–º–æ–∑–∞")
                                    
                        except Exception as e:
                            logger.debug(f"Key handling error: {e}")
                
                    @abstractmethod  
                    def _start(self): pass
                    
                    @abstractmethod
                    def start(self): pass
                    
                    @abstractmethod
                    def create_parser(self): pass
                    
                    @abstractmethod
                    def display_result(self): pass
                
                class ToolApp(App):
                    """–ö–ª–∞—Å—Å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
                    
                    def __init__(self):
                        super().__init__()
                        
                        # –ü–∞—Ä—Å–∏–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã
                        args = self.create_parser().parse_args()
                        
                        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
                        for key, value in vars(args).items():
                            if key == 'reset_key' and value:
                                self.cfg.ARGS.RESET_KEY = f"'{value}'"
                            elif key == 'quit_key' and value:
                                self.cfg.ARGS.QUIT_KEY = f"'{value}'"
                        
                        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º opts
                        if hasattr(args, 'opts') and args.opts:
                            self.cfg.merge_from_list(args.opts)
                        
                        # –°–æ–∑–¥–∞–µ–º dummy SELECTED –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                        if not hasattr(self.cfg, 'SELECTED'):
                            self.cfg.SELECTED = type('obj', (object,), {'MODE': 'spin'})()
                        
                        # –ó–∞–º–æ—Ä–∞–∂–∏–≤–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
                        self.cfg.freeze()
                        
                        # –°–æ–∑–¥–∞–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
                        self.detection = FallbackDetection(self.cfg, self.window)
                        self.result = FallbackResult()
                        
                        # –°–æ–∑–¥–∞–µ–º —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–Ω—ã–π —Ç–æ—Ä–º–æ–∑
                        try:
                            from rf4s.component.friction_brake import FrictionBrake
                            self.friction_brake = FrictionBrake(self.cfg, Lock(), self.detection)
                        except ImportError:
                            self.friction_brake = None
                
                    def create_parser(self):
                        """–°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä—Å–µ—Ä–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤"""
                        parser = argparse.ArgumentParser(description="Automate friction brake.")
                        parser.add_argument("opts", nargs="*", help="overwrite configuration")
                        parser.add_argument("-r", "--reset-key", default="g", type=str,
                                          help="key to reset friction brake, g by default")
                        parser.add_argument("-q", "--quit-key", default="h", type=str,
                                          help="key to quit the script, h by default")
                        return parser
                
                    def is_game_window_valid(self):
                        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ –æ–∫–Ω–∞ –∏–≥—Ä—ã"""
                        if self.window.is_title_bar_exist():
                            logger.info("Window mode detected. Please don't move the game window")
                        if not self.window.is_size_supported():
                            logger.critical('Window mode must be "Borderless windowed" or "Window mode"')
                            logger.critical("Unsupported window size '%s', use '2560x1440', '1920x1080' or '1600x900'",
                                          self.window.get_resolution_str())
                            return False
                        return True
                
                    def display_result(self):
                        """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
                        result_dict = self.result.as_dict()
                        if result_dict:
                            print("\n=== –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞–±–æ—Ç—ã ===")
                            for name, value in result_dict.items():
                                print(f"{name}: {value}")
                
                    def start(self):
                        """–ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
                        listener = None
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–∫–Ω–æ –∏–≥—Ä—ã
                        if not self.is_game_window_valid():
                            print("‚ùå –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫–Ω–∞ –∏–≥—Ä—ã –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞")
                            from rf4s.utils import safe_exit
                            safe_exit()
                            
                        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Å–ª—É—à–∞—Ç–µ–ª—å –∫–ª–∞–≤–∏—à
                        try:
                            from pynput import keyboard
                            listener = keyboard.Listener(on_release=self._on_release)
                            listener.start()
                            print(f"üéπ Listening for keys:")
                            print(f"   Press {self.cfg.ARGS.RESET_KEY.replace(chr(39), '')} to reset friction brake")
                            print(f"   Press {self.cfg.ARGS.QUIT_KEY.replace(chr(39), '')} to quit")
                        except ImportError:
                            print("‚ö†Ô∏è pynput unavailable - keyboard shortcuts disabled")
                        except Exception as e:
                            logger.debug(f"Keyboard listener error: {e}")
                
                        self.window.activate_game_window()
                        
                        try:
                            self._start()
                        except KeyboardInterrupt:
                            print("\nüõë Script interrupted by user")
                        except Exception as e:
                            print(f"‚ùå Script error: {e}")
                            logger.exception("Script execution error")
                        finally:
                            if listener:
                                try:
                                    listener.stop()
                                except:
                                    pass
                            self.display_result()
                            self.window.activate_script_window()
                
                    def _start(self):
                        """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–µ—Ç–æ–¥ –∑–∞–ø—É—Å–∫–∞ - –¥–ª—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤ –ø–æ–¥–∫–ª–∞—Å—Å–∞—Ö"""
                        print("üöÄ ToolApp started successfully")
                        print("‚öôÔ∏è Running friction brake automation...")
                        
                        if self.friction_brake:
                            try:
                                print("üîß Starting friction brake monitoring...")
                                self.friction_brake.monitor_process.start()
                                
                                # –û–∂–∏–¥–∞–µ–º —Ä–∞–±–æ—Ç—ã —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –∫–ª–∞–≤–∏—à
                                try:
                                    from pynput import keyboard
                                    with keyboard.Listener(on_release=self._on_release) as listener:
                                        listener.join()
                                except ImportError:
                                    # –ë–µ–∑ pynput –ø—Ä–æ—Å—Ç–æ –∂–¥–µ–º
                                    print("\n‚å®Ô∏è Press Ctrl+C to exit...")
                                    while True:
                                        time.sleep(1)
                                        
                            except Exception as e:
                                print(f"‚ùå Friction brake error: {e}")
                        else:
                            # –°–∏–º—É–ª—è—Ü–∏—è –±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ñ—Ä–∏–∫—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ç–æ—Ä–º–æ–∑–∞
                            print("‚öôÔ∏è Simulating friction brake operation...")
                            for i in range(10):
                                print(f"‚öôÔ∏è Monitoring... {i+1}/10")
                                time.sleep(2)
                            print("‚úÖ Simulation completed")
                
                # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                MainApp = ToolApp
            üìÑ __init__.py
                """RF4S App module"""
                try:
                    from .app import ToolApp, App, MainApp
                    __all__ = ['ToolApp', 'App', 'MainApp']
                except ImportError:
                    __all__ = []
            üìÅ __pycache__/
                üìÑ app.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ component/
            üìÑ friction_brake.py
                """RF4S Friction Brake component"""
                import threading
                import time
                from multiprocessing import Process
                
                try:
                    from rich import print
                    RICH_AVAILABLE = True
                except ImportError:
                    RICH_AVAILABLE = False
                    def print(*args, **kwargs):
                        import builtins
                        builtins.print(*args)
                
                class FrictionBrake:
                    """Automatic friction brake management"""
                    
                    def __init__(self, config, lock, detection):
                        self.config = config
                        self.lock = lock
                        self.detection = detection
                        self.current_value = getattr(config.FRICTION_BRAKE, 'INITIAL', 29)
                        self.monitor_process = Process(target=self._monitor_loop, daemon=True)
                        
                    def change(self, increase=True):
                        """Change friction brake setting"""
                        direction = "increase" if increase else "decrease"
                        
                        if increase:
                            max_val = getattr(self.config.FRICTION_BRAKE, 'MAX', 30)
                            if self.current_value < max_val:
                                self.current_value += 1
                        else:
                            min_val = getattr(self.config.FRICTION_BRAKE, 'INITIAL', 29)
                            if self.current_value > min_val:
                                self.current_value -= 1
                        
                        if RICH_AVAILABLE:
                            print(f"[cyan]Friction brake {direction}: {self.current_value}[/cyan]")
                        else:
                            print(f"Friction brake {direction}: {self.current_value}")
                        
                        # Simulate key press
                        self._simulate_key_press(increase)
                        
                    def reset(self, value=None):
                        """Reset friction brake to specified value"""
                        if value is None:
                            value = getattr(self.config.FRICTION_BRAKE, 'INITIAL', 29)
                        
                        self.current_value = value
                        if RICH_AVAILABLE:
                            print(f"[green]Friction brake reset to: {value}[/green]")
                        else:
                            print(f"Friction brake reset to: {value}")
                        
                    def _simulate_key_press(self, increase=True):
                        """Simulate friction brake key press"""
                        try:
                            import pyautogui
                            key = '=' if increase else '-'
                            pyautogui.press(key)
                        except ImportError:
                            direction = "‚Üë" if increase else "‚Üì"
                            if RICH_AVAILABLE:
                                print(f"[dim]Simulating friction brake {direction}[/dim]")
                            else:
                                print(f"Simulating friction brake {direction}")
                            
                    def _monitor_loop(self):
                        """Main monitoring loop"""
                        if RICH_AVAILABLE:
                            print("[green]Friction brake monitoring started[/green]")
                        else:
                            print("Friction brake monitoring started")
                        
                        try:
                            iteration = 0
                            while True:
                                iteration += 1
                                
                                # Simulate fish fighting detection
                                if self._is_fish_fighting():
                                    if RICH_AVAILABLE:
                                        print(f"[yellow]Fish fighting detected! (iteration {iteration})[/yellow]")
                                    else:
                                        print(f"Fish fighting detected! (iteration {iteration})")
                                    self._auto_adjust()
                                
                                time.sleep(0.5)
                                
                                # Demo: stop after some iterations
                                if iteration > 20:
                                    if RICH_AVAILABLE:
                                        print("[blue]Demo monitoring completed[/blue]")
                                    else:
                                        print("Demo monitoring completed")
                                    break
                                
                        except KeyboardInterrupt:
                            if RICH_AVAILABLE:
                                print("[yellow]Friction brake monitoring stopped[/yellow]")
                            else:
                                print("Friction brake monitoring stopped")
                        except Exception as e:
                            if RICH_AVAILABLE:
                                print(f"[red]Friction brake monitor error: {e}[/red]")
                            else:
                                print(f"Friction brake monitor error: {e}")
                            
                    def _is_fish_fighting(self):
                        """Check if fish is fighting (simulation)"""
                        import random
                        return random.random() < 0.1  # 10% chance
                        
                    def _auto_adjust(self):
                        """Auto adjust friction brake"""
                        try:
                            import random
                            if random.random() > 0.5:
                                self.change(increase=True)
                            else:
                                self.change(increase=False)
                        except Exception as e:
                            print(f"Auto-adjust error: {e}")
            üìÑ tackle.py
                """Module for Tackle class and some decorators.
                
                This module provides functionality for managing tackle-related actions in Russian Fishing 4,
                such as casting, retrieving, and pulling fish. It also includes decorators for handling
                common tasks like clicklock and key releases.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                import random
                from time import sleep
                from typing import Literal
                
                import pyautogui as pag
                import win32api
                import win32con
                from pyscreeze import Box
                
                from rf4s import exceptions, utils
                from rf4s.controller.detection import Detection
                from rf4s.controller.timer import Timer
                
                logger = logging.getLogger("rich")
                
                RESET_TIMEOUT = 16
                CAST_SCALE = 0.4  # 25% / 0.4s
                
                # BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
                BASE_DELAY = 1.2
                LOOP_DELAY = 1
                
                ANIMATION_DELAY = 1
                
                RETRIEVAL_TIMEOUT = 32
                PULL_TIMEOUT = 16
                RETRIEVAL_WITH_PAUSE_TIMEOUT = 128
                LIFT_DURATION = 3
                TELESCOPIC_PULL_TIMEOUT = 8
                LANDING_NET_DURATION = 6
                LANDING_NET_DELAY = 0.5
                SINK_DELAY = 2
                
                
                OFFSET = 100
                NUM_OF_MOVEMENT = 4
                
                
                class Tackle:
                    """Class for all tackle-dependent methods.
                
                    This class handles actions related to the fishing tackle, such as casting,
                    retrieving, and pulling fish. It also manages tackle resetting and gear ratio switching.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for tackle settings.
                        timer (Timer): Timer instance for timing actions.
                        detection (Detection): Detection instance for in-game state checks.
                        landing_net_out (bool): Whether the landing net is deployed.
                        available (bool): Whether the tackle is available for use.
                    """
                
                    def __init__(self, cfg, timer: Timer, detection: Detection):
                        """Initialize the Tackle class with configuration, timer, and detection.
                
                        :param cfg: Configuration node for tackle settings.
                        :type cfg: CfgNode
                        :param timer: Timer instance for timing actions.
                        :type timer: Timer
                        :param detection: Detection instance for in-game state checks.
                        :type detection: Detection
                        """
                        self.cfg = cfg
                        self.timer = timer
                        self.detection = detection
                        self.landing_net_out = False  # For telescopic pull
                        self.available = True
                
                    @staticmethod
                    def _check_status(func):
                        def wrapper(self, *args, **kwargs):
                            if not self.available:
                                return
                            try:
                                func(self, *args)
                            except Exception as e:
                                raise e
                
                        return wrapper
                
                    def is_disconnected_or_ticketed_expired(self) -> None:
                        """Check if the game disconnected or the boat ticket expired."""
                        if self.detection.is_disconnected():
                            raise exceptions.DisconnectedError
                        if self.detection.is_ticket_expired():
                            raise exceptions.TicketExpiredError
                
                    @_check_status
                    def reset(self) -> None:
                        """Reset the tackle until ready and detect unexpected events.
                
                        :raises exceptions.FishHookedError: A fish is hooked.
                        :raises exceptions.FishCapturedError: A fish is captured.
                        :raises exceptions.LineAtEndError: The line is at its end.
                        :raises exceptions.LineSnaggedError: The line is snagged.
                        :raises TimeoutError: The loop timed out.
                        """
                        logger.info("Resetting tackle")
                        i = RESET_TIMEOUT
                        while i > 0:
                            if self.detection.is_tackle_ready():
                                return
                            if self.detection.is_fish_hooked():
                                raise exceptions.FishHookedError
                            if self.detection.is_fish_captured():
                                raise exceptions.FishCapturedError
                            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                                raise exceptions.LineAtEndError
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                            if self.detection.is_lure_broken():
                                raise exceptions.LureBrokenError
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @_check_status
                    def cast(self, lock: bool) -> None:
                        """Cast the rod, then wait for the lure/bait to fly and sink.
                
                        :param lock: Whether to lock the reel after casting.
                        :type lock: bool
                        """
                        logger.info("Casting rod")
                        if self.cfg.ARGS.MOUSE:
                            self.move_mouse_randomly()
                        match self.cfg.SELECTED.CAST_POWER_LEVEL:
                            case 1:  # 0%
                                pag.click()
                            case 5:  # power cast
                                with pag.hold("shift"):
                                    utils.hold_mouse_button(1)
                            case _:
                                # -1 for backward compatibility
                                duration = CAST_SCALE * (self.cfg.SELECTED.CAST_POWER_LEVEL - 1)
                                utils.hold_mouse_button(duration)
                
                        sleep(self.cfg.SELECTED.CAST_DELAY)
                        if lock:
                            pag.click()
                
                    def sink(self) -> None:
                        """Sink the lure until an event happens, designed for marine and wakey rig."""
                        logger.info("Sinking lure")
                        i = self.cfg.SELECTED.SINK_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_moving_in_bottom_layer():
                                logger.info("Lure has reached bottom layer")
                                sleep(SINK_DELAY)
                                break
                
                            if self.detection.is_fish_hooked_twice():
                                pag.click()  # Lock reel
                                return
                
                        utils.hold_mouse_button(self.cfg.SELECTED.TIGHTEN_DURATION)
                
                    @_check_status
                    @utils.release_keys_after()
                    def retrieve(self, first: bool = True) -> None:
                        """Retrieve the line until the end is reached and detect unexpected events.
                
                        :param first: Whether it's invoked for the first time, defaults to True.
                        :type first: bool, optional
                
                        :raises exceptions.FishCapturedError: A fish is captured.
                        :raises exceptions.LineAtEndError: The line is at its end.
                        :raises exceptions.LineSnaggedError: The line is snagged.
                        :raises TimeoutError: The loop timed out.
                        """
                        logger.info("Retrieving fishing line")
                
                        i = RETRIEVAL_TIMEOUT
                        while i > 0:
                            if self.detection.is_fish_hooked():
                                if self.cfg.SELECTED.POST_ACCELERATION == "on":
                                    pag.keyDown("shift")
                                elif self.cfg.SELECTED.POST_ACCELERATION == "auto" and first:
                                    pag.keyDown("shift")
                
                                if self.cfg.ARGS.LIFT:
                                    utils.hold_mouse_button(LIFT_DURATION, button="right")
                
                            if self.detection.is_retrieval_finished():
                                sleep(0 if self.cfg.ARGS.RAINBOW else 2)
                                return
                
                            if self.detection.is_fish_captured():
                                raise exceptions.FishCapturedError
                            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                                raise exceptions.LineAtEndError
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @utils.release_keys_after()
                    def _special_retrieve(self, button: str) -> None:
                        """Retrieve the line with special conditions (pause or lift).
                
                        :param button: The mouse button to use for retrieval.
                        :type button: str
                        """
                        if self.cfg.SELECTED.PRE_ACCELERATION:
                            pag.keyDown("shift")
                        i = RETRIEVAL_WITH_PAUSE_TIMEOUT
                        while i > 0:
                            utils.hold_mouse_button(self.cfg.SELECTED.RETRIEVAL_DURATION, button)
                            i -= self.cfg.SELECTED.RETRIEVAL_DURATION
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.RETRIEVAL_DELAY)
                            if (
                                self.detection.is_fish_hooked()
                                or self.detection.is_retrieval_finished()
                            ):
                                return
                
                    @utils.release_keys_after()
                    def pirk(self) -> None:
                        """Start pirking until a fish is hooked.
                
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        logger.info("Pirking")
                
                        i = self.cfg.SELECTED.PIRK_TIMEOUT
                        while i > 0:
                            if self.detection.is_tackle_ready():
                                return
                
                            if self.detection.is_fish_hooked_twice():
                                pag.click()
                                return
                
                            if self.cfg.SELECTED.PIRK_DURATION > 0:
                                if self.cfg.SELECTED.CTRL:
                                    pag.keyDown("ctrl")
                                if self.cfg.SELECTED.SHIFT:
                                    pag.keyDown("shift")
                                utils.hold_mouse_button(self.cfg.SELECTED.PIRK_DURATION, button="right")
                                i -= self.cfg.SELECTED.PIRK_DURATION
                                i = utils.sleep_and_decrease(i, self.cfg.SELECTED.PIRK_DELAY)
                            else:
                                i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def elevate(self, dropped: bool) -> None:
                        """Perform elevator tactic (drop/rise) until a fish is hooked.
                
                        :param dropped: Whether the lure is dropped.
                        :type dropped: bool
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        locked = True  # Reel is locked after tackle.sink()
                        i = self.cfg.SELECTED.ELEVATE_TIMEOUT
                        while i > 0:
                            if self.detection.is_fish_hooked_twice():
                                pag.click()
                                return
                
                            if self.cfg.SELECTED.DROP and not dropped:
                                pag.press("enter")
                                if locked:
                                    delay = self.cfg.SELECTED.ELEVATE_DELAY
                                else:
                                    delay = self.cfg.SELECTED.ELEVATE_DURATION
                                i = utils.sleep_and_decrease(i, delay)
                            else:
                                if locked:
                                    i = utils.sleep_and_decrease(i, self.cfg.SELECTED.ELEVATE_DELAY)
                                else:
                                    utils.hold_mouse_button(self.cfg.SELECTED.ELEVATE_DURATION)
                                    i -= self.cfg.SELECTED.ELEVATE_DURATION
                            locked = not locked
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @_check_status
                    def pull(self) -> None:
                        """Pull the fish until it's captured."""
                        logger.info("Pulling fish")
                        if self.cfg.SELECTED.MODE == "telescopic":
                            self._telescopic_pull()
                        else:
                            self._pull()
                
                    @utils.toggle_right_mouse_button
                    def _pull(self) -> None:
                        """Pull the fish until it's captured."""
                        i = PULL_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_fish_captured():
                                return
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                
                        if not self.detection.is_fish_hooked():
                            return
                        if self.detection.is_retrieval_finished():
                            pag.press("space")
                            sleep(LANDING_NET_DURATION)
                            if self.detection.is_fish_captured():
                                return
                            pag.press("space")
                            sleep(LANDING_NET_DELAY)
                        if self.detection.is_tackle_broken():
                            raise exceptions.TackleBrokenError
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def _telescopic_pull(self) -> None:
                        """Pull the fish until it's captured, designed for telescopic rod.
                
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        # Check false postive first because it happens often
                        if not self.detection.is_fish_hooked():
                            return
                
                        # Toggle landing net when pull() is called for the first time
                        if not self.landing_net_out:
                            pag.press("space")
                            self.landing_net_out = True
                        i = TELESCOPIC_PULL_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_fish_captured():
                                self.landing_net_out = False
                                return
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def switch_gear_ratio(self) -> None:
                        """Switch the gear ratio of a conventional reel."""
                        logger.info("Switching gear ratio")
                        with pag.hold("ctrl"):
                            pag.press("space")
                
                    def move_mouse_randomly(self) -> None:
                        """Randomly move the mouse for four times."""
                        logger.info("Moving mouse randomly")
                        coords = []
                        for _ in range(NUM_OF_MOVEMENT - 1):
                            x, y = random.randint(-OFFSET, OFFSET), random.randint(-OFFSET, OFFSET)
                            coords.append((x, y))
                        coords.append((-sum(x for x, _ in coords), -sum(y for _, y in coords)))
                        for x, y in coords:
                            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, x, y, 0, 0)
                            sleep(ANIMATION_DELAY)
                
                    def equip_item(self, item) -> None:
                        """Equip an item from the menu or inventory.
                
                        :param item: The item to equip (e.g., lure, pva, dry_mix, groundbait).
                        :type item: str
                        """
                        if item == "lure":
                            self._equip_item_from_menu(item)
                        self._equip_item_from_inventory(item)  # groundbait, dry_mix, pva
                
                    def _equip_item_from_menu(self, item: str) -> None:
                        """Equip an item from the menu.
                
                        :param item: The item to equip (e.g., lure).
                        :type item: str
                        """
                        logger.info("Equiping new %s from menu", item)
                        with pag.hold("b"):
                            self._equip_favorite_item(item)
                        sleep(ANIMATION_DELAY)
                
                    @utils.press_before_and_after("v")
                    def _equip_item_from_inventory(
                        self, item: Literal["dry_mix", "groundbait"]
                    ) -> None:
                        """Equip an item from the inventory.
                
                        :param item: The item to equip (e.g., dry_mix, groundbait).
                        :type item: Literal["dry_mix", "groundbait"]
                        """
                        logger.info("Equiping new %s from inventory", item)
                        scrollbar_position = self.detection.get_scrollbar_position()
                        if scrollbar_position is None:
                            pag.click(utils.get_box_center(self.get_item_position(item)))
                            self._equip_favorite_item(item)
                            return
                
                        pag.moveTo(scrollbar_position)
                        for _ in range(5):
                            sleep(ANIMATION_DELAY)
                            pag.drag(xOffset=0, yOffset=125, duration=0.5, button="left")
                            position = self.get_item_position(item)
                            if position is not None:
                                pag.click(utils.get_box_center(position))
                                self._equip_favorite_item(item)
                                break
                
                    def get_item_position(self, item: str) -> Box | None:
                        """Get the position of an item.
                        :param item: The item to get the position for (e.g., pva, dry_mix, groundbait)
                        :type item: str
                        :return: position of the item
                        :rtype: Box | None
                        """
                        if item == "groundbait":
                            return self.detection.get_groundbait_position()
                        elif item == "dry_mix":
                            return self.detection.get_dry_mix_position()
                        else:  # pva
                            return self.detection.get_pva_position()
                
                    def _equip_favorite_item(self, item: bool):
                        """Select a favorite item for replacement and replace the broken one.
                
                        :param item: The item to equip (e.g., lure, pva, dry_mix, groundbait).
                        :type item: str
                        :raises exceptions.ItemNotFoundError: The item was not found.
                        """
                        sleep(ANIMATION_DELAY)
                        logger.info("Looking for favorite items")
                        favorite_item_positions = list(self.detection.get_favorite_item_positions())
                        if item == "lure":
                            random.shuffle(favorite_item_positions)
                
                        for favorite_item_position in favorite_item_positions:
                            x, y = utils.get_box_center(favorite_item_position)
                            if item == "lure" and pag.pixel(x - 70, y + 190) == (178, 59, 30):
                                continue
                            pag.click(x - 70, y + 190, clicks=2, interval=0.1)
                            logger.info("New %s equiped successfully", item)
                            return
                
                        # Close selection window when equiping from inventory
                        if item in ("dry_mix", "groundbait"):
                            pag.press("esc")
                        raise exceptions.ItemNotFoundError
                
                    def _monitor_float_state(self) -> None:
                        """Monitor the state of the float."""
                        logger.info("Monitoring float state")
                        reference_img = pag.screenshot(region=self.detection.float_camera_rect)
                        i = self.cfg.SELECTED.DRIFT_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.CHECK_DELAY)
                            if self.detection.is_float_state_changed(reference_img):
                                logger.info("Float status changed")
                                return
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def _monitor_clip_state(self) -> None:
                        """Monitor the state of the bolognese clip."""
                        i = self.cfg.SELECTED.DRIFT_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.CHECK_DELAY)
                            if self.detection.is_clip_open():
                                logger.info("Clip status changed")
                                return
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
            üìÑ __init__.py
                """RF4S Component module"""
                try:
                    from .friction_brake import FrictionBrake
                    __all__ = ['FrictionBrake']
                except ImportError:
                    __all__ = []
            üìÅ __pycache__/
                üìÑ friction_brake.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ tackle.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ config/
            üìÑ config.py
                """
                –û—Å–Ω–æ–≤–Ω–æ–π –º–æ–¥—É–ª—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
                """
                
                import yaml
                import os
                import copy
                from pathlib import Path
                from typing import Dict, Any, List, Optional
                from .env_config import EnvironmentConfig
                from .defaults import get_default_config
                
                
                class ConfigManager:
                    """–ú–µ–Ω–µ–¥–∂–µ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è."""
                    
                    def __init__(self):
                        self.env_config = EnvironmentConfig()
                        self.config = {}
                        self.config_file_path = None
                        self._default_config = None
                    
                    @property
                    def default_config(self) -> Dict[str, Any]:
                        """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è."""
                        if self._default_config is None:
                            self._default_config = get_default_config()
                            
                            # –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
                            env_email = self.env_config.get_email_config()
                            self._default_config['NOTIFICATION'] = {
                                'EMAIL': env_email['email'],
                                'PASSWORD': env_email['password'],
                                'SMTP_SERVER': env_email['smtp_server'],
                                'MIAO_CODE': self.env_config.get_miao_code() or '',
                                'DISCORD_WEBHOOK_URL': self.env_config.get_discord_webhook_url() or ''
                            }
                        
                        return self._default_config
                    
                    def load_config(self, file_path: str) -> None:
                        """–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ YAML —Ñ–∞–π–ª–∞."""
                        try:
                            self.config_file_path = file_path
                            
                            if not os.path.exists(file_path):
                                print(f"‚ö†Ô∏è  –§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω: {file_path}")
                                print("–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
                                self.config = copy.deepcopy(self.default_config)
                                return
                                
                            with open(file_path, 'r', encoding='utf-8') as f:
                                loaded_config = yaml.safe_load(f) or {}
                            
                            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å –¥–µ—Ñ–æ–ª—Ç–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π
                            self.config = self._merge_configs(self.default_config, loaded_config)
                            
                            # –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
                            env_validation = self.env_config.validate_environment()
                            if env_validation['warnings']:
                                print("‚ö†Ô∏è  –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –ø–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º –æ–∫—Ä—É–∂–µ–Ω–∏—è:")
                                for warning in env_validation['warnings']:
                                    print(f"   - {warning}")
                            
                        except yaml.YAMLError as e:
                            raise Exception(f"–û—à–∏–±–∫–∞ –≤ YAML —Ñ–∞–π–ª–µ {file_path}: {str(e)}")
                        except Exception as e:
                            raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ {file_path}: {str(e)}")
                    
                    def save_config(self, file_path: Optional[str] = None) -> None:
                        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –≤ YAML —Ñ–∞–π–ª."""
                        if file_path is None:
                            file_path = self.config_file_path
                        
                        if file_path is None:
                            raise ValueError("–ù–µ —É–∫–∞–∑–∞–Ω –ø—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
                        
                        try:
                            # –°–æ–∑–¥–∞–µ–º –±—ç–∫–∞–ø –µ—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                            if os.path.exists(file_path):
                                backup_path = f"{file_path}.backup"
                                import shutil
                                shutil.copy2(file_path, backup_path)
                            
                            # –û—á–∏—â–∞–µ–º —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
                            config_to_save = self._sanitize_for_save(self.config)
                            
                            # –°–æ—Ö—Ä–∞–Ω—è–µ–º
                            os.makedirs(os.path.dirname(file_path) or ".", exist_ok=True)
                            
                            with open(file_path, 'w', encoding='utf-8') as f:
                                yaml.dump(
                                    config_to_save,
                                    f,
                                    default_flow_style=False,
                                    allow_unicode=True,
                                    sort_keys=False,
                                    indent=2,
                                    width=120
                                )
                            
                            self.config_file_path = file_path
                            print(f"‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {file_path}")
                            
                        except Exception as e:
                            raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≤ {file_path}: {str(e)}")
                    
                    def _merge_configs(self, default: dict, loaded: dict) -> dict:
                        """–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–π."""
                        result = default.copy()
                        
                        for key, value in loaded.items():
                            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                                result[key] = self._merge_configs(result[key], value)
                            else:
                                result[key] = value
                        
                        return result
                    
                    def _sanitize_for_save(self, config: dict) -> dict:
                        """–£–¥–∞–ª–µ–Ω–∏–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º."""
                        sanitized = copy.deepcopy(config)
                        
                        # –û—á–∏—â–∞–µ–º —Å–µ–∫—Ü–∏—é NOTIFICATION
                        if 'NOTIFICATION' in sanitized:
                            notification = sanitized['NOTIFICATION']
                            notification['EMAIL'] = ''
                            notification['PASSWORD'] = ''
                            notification['DISCORD_WEBHOOK_URL'] = ''
                            notification['MIAO_CODE'] = ''
                        
                        return sanitized
                    
                    def validate_startup(self) -> List[str]:
                        """–í–∞–ª–∏–¥–∞—Ü–∏—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º."""
                        errors = []
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ —É–¥–∏–ª–∏—â–µ
                        keys = self.config.get('KEY', {})
                        main_rod = keys.get('MAIN_ROD', -1)
                        
                        if main_rod == -1:
                            errors.append("MAIN_ROD –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω (–∑–Ω–∞—á–µ–Ω–∏–µ -1)")
                        elif not isinstance(main_rod, int) or main_rod < 1 or main_rod > 9:
                            errors.append(f"MAIN_ROD –∏–º–µ–µ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {main_rod}")
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ—Ñ–∏–ª–∏
                        profiles = self.config.get('PROFILE', {})
                        if not profiles:
                            errors.append("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è")
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä—Å–∏—é
                        if not self.config.get('VERSION'):
                            errors.append("–í–µ—Ä—Å–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–∞")
                        
                        return errors
                    
                    def get_profile_config(self, profile_name: str) -> dict:
                        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø—Ä–æ—Ñ–∏–ª—è."""
                        profiles = self.config.get('PROFILE', {})
                        return profiles.get(profile_name, {}).copy()
                    
                    def get_profile_list(self) -> List[str]:
                        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–æ—Ñ–∏–ª–µ–π."""
                        return list(self.config.get('PROFILE', {}).keys())
                    
                    def get_notification_config(self) -> dict:
                        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è."""
                        config_notification = self.config.get('NOTIFICATION', {})
                        env_email = self.env_config.get_email_config()
                        
                        return {
                            'EMAIL': env_email['email'] or config_notification.get('EMAIL', ''),
                            'PASSWORD': env_email['password'] or config_notification.get('PASSWORD', ''),
                            'SMTP_SERVER': env_email['smtp_server'] or config_notification.get('SMTP_SERVER', 'smtp.gmail.com'),
                            'MIAO_CODE': self.env_config.get_miao_code() or config_notification.get('MIAO_CODE', ''),
                            'DISCORD_WEBHOOK_URL': self.env_config.get_discord_webhook_url() or config_notification.get('DISCORD_WEBHOOK_URL', '')
                        }
            üìÑ config.yaml
                VERSION: "0.5.2"
                
                SCRIPT:
                  LANGUAGE: "en"
                  LAUNCH_OPTIONS: ""
                  SMTP_VERIFICATION: true
                  IMAGE_VERIFICATION: true
                  SNAG_DETECTION: true
                  SPOOLING_DETECTION: true
                  RANDOM_ROD_SELECTION: true
                  SPOOL_CONFIDENCE: 0.98
                  SPOD_ROD_RECAST_DELAY: 1800
                  LURE_CHANGE_DELAY: 1800
                  ALARM_SOUND: "./static/sound/guitar.wav"
                  RANDOM_CAST_PROBABILITY: 0.25
                  SCREENSHOT_TAGS:
                    - "green"
                    - "yellow"
                    - "blue"
                    - "purple"
                    - "pink"
                
                KEY:
                  TEA: -1
                  CARROT: -1
                  BOTTOM_RODS: [1, 2, 3]
                  COFFEE: 4
                  DIGGING_TOOL: 5
                  ALCOHOL: 6
                  MAIN_ROD: 1
                  SPOD_ROD: 7
                  QUIT: "CTRL-C"
                
                STAT:
                  ENERGY_THRESHOLD: 0.74
                  HUNGER_THRESHOLD: 0.5
                  COMFORT_THRESHOLD: 0.51
                  TEA_DELAY: 300
                  COFFEE_LIMIT: 10
                  COFFEE_PER_DRINK: 1
                  ALCOHOL_DELAY: 900
                  ALCOHOL_PER_DRINK: 1
                
                FRICTION_BRAKE:
                  INITIAL: 29
                  MAX: 30
                  START_DELAY: 2.0
                  INCREASE_DELAY: 1.0
                  SENSITIVITY: "medium"
                
                KEEPNET:
                  CAPACITY: 100
                  FISH_DELAY: 0.0
                  GIFT_DELAY: 4.0
                  FULL_ACTION: "quit"
                  WHITELIST:
                    - "mackerel"
                    - "saithe"
                    - "herring"
                    - "squid"
                    - "scallop"
                    - "mussel"
                  BLACKLIST: []
                  TAGS:
                    - "green"
                    - "yellow"
                    - "blue"
                    - "purple"
                    - "pink"
                
                NOTIFICATION:
                  EMAIL: "email@example.com"
                  PASSWORD: "password"
                  SMTP_SERVER: "smtp.gmail.com"
                  MIAO_CODE: "example"
                  DISCORD_WEBHOOK_URL: ""
                
                PAUSE:
                  DELAY: 1800
                  DURATION: 600
                
                PROFILE:
                  SPIN:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 0.0
                    RETRIEVAL_DURATION: 0.0
                    RETRIEVAL_DELAY: 0.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "normal"
                  SPIN_WITH_PAUSE:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 1.0
                    RETRIEVAL_DURATION: 1.0
                    RETRIEVAL_DELAY: 3.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "pause"
                  SPIN_WITH_LIFT:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 0.0
                    RETRIEVAL_DURATION: 1.0
                    RETRIEVAL_DELAY: 1.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "lift"
                  BOTTOM:
                    MODE: "bottom"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    POST_ACCELERATION: "off"
                    CHECK_DELAY: 32.0
                    CHECK_MISS_LIMIT: 16
                    PUT_DOWN_DELAY: 0.0
                  PIRK:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 4.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: false
                    SHIFT: false
                    PIRK_DURATION: 0.5
                    PIRK_DELAY: 2.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  PIRK_WITH_RETRIEVAL:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 0.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: false
                    SHIFT: false
                    PIRK_DURATION: 0.5
                    PIRK_DELAY: 2.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: true
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  WAKEY_RIG:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 45.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 4.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: true
                    SHIFT: false
                    PIRK_DURATION: 1.5
                    PIRK_DELAY: 4.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  ELEVATOR:
                    MODE: "elevator"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    ELEVATE_DURATION: 4.0
                    ELEVATE_DELAY: 4.0
                    ELEVATE_TIMEOUT: 40.0
                    DROP: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  ELEVATOR_WITH_DROP:
                    MODE: "elevator"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    ELEVATE_DURATION: 4.0
                    ELEVATE_DELAY: 4.0
                    ELEVATE_TIMEOUT: 40.0
                    DROP: true
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  TELESCOPIC:
                    MODE: "telescopic"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    FLOAT_SENSITIVITY: 0.68
                    CHECK_DELAY: 1.0
                    PULL_DELAY: 0.5
                    DRIFT_TIMEOUT: 16.0
                    CAMERA_SHAPE: "square"
                  BOLOGNESE:
                    MODE: "bolognese"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    FLOAT_SENSITIVITY: 0.68
                    CHECK_DELAY: 1.0
                    PULL_DELAY: 0.5
                    DRIFT_TIMEOUT: 32.0
                    CAMERA_SHAPE: "square"
                    POST_ACCELERATION: "off"
            üìÑ defaults.py
                """Default yacs config node."""
                
                from yacs.config import CfgNode as CN
                
                _C = CN()
                _C.VERSION = "0.5.2"
                
                # ---------------------------------------------------------------------------- #
                #                                    General                                   #
                # ---------------------------------------------------------------------------- #
                _C.SCRIPT = CN()
                _C.SCRIPT.LANGUAGE = "en"  # Language for the script. Options: en, ru, zh-TW, zh-CN
                _C.SCRIPT.LAUNCH_OPTIONS = ""  # Default launch options for the script, e.g., -r -c -H
                _C.SCRIPT.SMTP_VERIFICATION = True
                _C.SCRIPT.IMAGE_VERIFICATION = True
                _C.SCRIPT.SNAG_DETECTION = True
                _C.SCRIPT.SPOOLING_DETECTION = True
                _C.SCRIPT.RANDOM_ROD_SELECTION = True  # For bottom mode
                # Confidence threshold for spooling detection (lower = more sensitive)
                _C.SCRIPT.SPOOL_CONFIDENCE = 0.98
                # Delay before recasting spod rod (in seconds)
                # Use bottom mode and -o to enable it.
                _C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800
                # Delay before changing lure randomly (in seconds)
                # Use spin mode and -L to enable it.
                _C.SCRIPT.LURE_CHANGE_DELAY = 1800
                _C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # Path to alarm sound file
                # Probability to add a redundant rod cast (0.0 to 1.0)
                _C.SCRIPT.RANDOM_CAST_PROBABILITY = 0.25
                # When using -s flag, only take screenshot of the fishes with tags below
                # If left empty, the script will take screenshot of every fish you caught
                _C.SCRIPT.SCREENSHOT_TAGS = ("green", "yellow", "blue", "purple", "pink")
                
                # ---------------------------------------------------------------------------- #
                #                                  Key Binding                                 #
                # ---------------------------------------------------------------------------- #
                _C.KEY = CN()
                _C.KEY.TEA = -1  # Key binding for tea. Set to -1 to use quick selection menu
                _C.KEY.CARROT = -1  # Key binding for carrot. Set to -1 to use quick selection menu
                _C.KEY.BOTTOM_RODS = (1, 2, 3)  # Key bindings for bottom rods
                _C.KEY.COFFEE = 4  # Key binding for coffee. Set to -1 to use quick selection menu
                _C.KEY.DIGGING_TOOL = 5  # Key binding for digging tool
                _C.KEY.ALCOHOL = 6  # Key binding for alcohol
                # Key binding for the main rod (used when harvesting baits with one rod)
                _C.KEY.MAIN_ROD = 1
                _C.KEY.SPOD_ROD = 7  # Key binding for the spod rod (used in bottom mode)
                # Key binding to stop the script (default is Ctrl-C)
                # If you want to use a special quitting shortcut, please refer to pynput's docs:
                # https://pynput.readthedocs.io/en/latest/keyboard.html#pynput.keyboard.Key .
                _C.KEY.QUIT = "CTRL-C"
                
                # ---------------------------------------------------------------------------- #
                #                                 Player Stats                                 #
                # ---------------------------------------------------------------------------- #
                _C.STAT = CN()
                # Minimum energy level before drinking coffee/harvesting baits
                _C.STAT.ENERGY_THRESHOLD = 0.74
                _C.STAT.HUNGER_THRESHOLD = 0.5  # Minimum hunger level before consuming carrot
                _C.STAT.COMFORT_THRESHOLD = 0.51  # Minimum comfort level before consuming tea
                _C.STAT.TEA_DELAY = 300  # Delay between tea drinks (in seconds)
                _C.STAT.COFFEE_LIMIT = 10  # Maximum coffee drinks per fish fight.
                _C.STAT.COFFEE_PER_DRINK = 1  # Amount of coffee consumed per drink
                _C.STAT.ALCOHOL_DELAY = 900  # Delay between alcohol drinks (in seconds)
                _C.STAT.ALCOHOL_PER_DRINK = 1  # Amount of alcohol consumed per drink
                
                # ---------------------------------------------------------------------------- #
                #                   Friction Brake (Use -f flag to enable it)                  #
                # ---------------------------------------------------------------------------- #
                _C.FRICTION_BRAKE = CN()
                _C.FRICTION_BRAKE.INITIAL = 29  # Initial friction brake value
                _C.FRICTION_BRAKE.MAX = 30  # Maximum friction brake value
                # Delay before starting to adjust friction brake after a fish is hooked
                _C.FRICTION_BRAKE.START_DELAY = 2.0
                _C.FRICTION_BRAKE.INCREASE_DELAY = 1.0  # Delay before increasing friction brake
                _C.FRICTION_BRAKE.SENSITIVITY = "medium"  # Sensitivity of friction brake detection
                
                # ---------------------------------------------------------------------------- #
                #                                    Keepnet                                   #
                # ---------------------------------------------------------------------------- #
                _C.KEEPNET = CN()
                _C.KEEPNET.CAPACITY = 100
                _C.KEEPNET.FISH_DELAY = 0.0  # Delay before keeping the fish (for screenshots)
                _C.KEEPNET.GIFT_DELAY = 4.0  # Delay before keeping the gift (for screenshots)
                _C.KEEPNET.FULL_ACTION = "quit"  # Action when keepnet is full. Options: quit, alarm
                # Whitelist for untagged fish releasing when using -t flag
                # Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
                _C.KEEPNET.WHITELIST = (
                    "mackerel",
                    "saithe",
                    "herring",
                    "squid",
                    "scallop",
                    "mussel",
                )
                # Fish in the blacklist will always be released
                # Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
                _C.KEEPNET.BLACKLIST = ()
                # When using -t flag, only the fish with tags below would be kept
                _C.KEEPNET.TAGS = ("green", "yellow", "blue", "purple", "pink")
                
                
                # ---------------------------------------------------------------------------- #
                #                                 Notification                                 #
                # ---------------------------------------------------------------------------- #
                _C.NOTIFICATION = CN()
                _C.NOTIFICATION.EMAIL = "email@example.com"
                _C.NOTIFICATION.PASSWORD = "password"
                _C.NOTIFICATION.SMTP_SERVER = "smtp.gmail.com"
                _C.NOTIFICATION.MIAO_CODE = "example"
                _C.NOTIFICATION.DISCORD_WEBHOOK_URL = ""
                
                # ---------------------------------------------------------------------------- #
                #                       Pause ( use -X flag to enable it)                      #
                # ---------------------------------------------------------------------------- #
                _C.PAUSE = CN()
                _C.PAUSE.DELAY = 1800  # Delay between pauses (in seconds)
                _C.PAUSE.DURATION = 600  # Duration of pause (in seconds)
                
                _C.PROFILE = CN()
                # ---------------------------------------------------------------------------- #
                #                             Spin Fishing Profile                             #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.SPIN = CN()
                _C.PROFILE.SPIN.MODE = "spin"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.SPIN.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.SPIN.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.SPIN.CAST_DELAY = 6.0
                # Duration to tighten the fishing line after casting
                _C.PROFILE.SPIN.TIGHTEN_DURATION = 0.0
                # Duration of retrieving the line or lifting the rod (right mosue button)
                _C.PROFILE.SPIN.RETRIEVAL_DURATION = 0.0
                # Delay after retrieving the line or lifting the rod (right mosue button)
                _C.PROFILE.SPIN.RETRIEVAL_DELAY = 0.0
                # Timeout for retrieving with pause/lift, followed by the normal retrieval
                _C.PROFILE.SPIN.RETRIEVAL_TIMEOUT = 256.0
                # Hold down the Shift key when performing special spin fishing techniques
                _C.PROFILE.SPIN.PRE_ACCELERATION = False
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.SPIN.POST_ACCELERATION = "off"
                # Type of special spin fishing technique to perform. Options: normal, pause, lift
                _C.PROFILE.SPIN.TYPE = "normal"
                
                _C.PROFILE.SPIN_WITH_PAUSE = CN()
                _C.PROFILE.SPIN_WITH_PAUSE.MODE = "spin"
                _C.PROFILE.SPIN_WITH_PAUSE.LAUNCH_OPTIONS = ""
                _C.PROFILE.SPIN_WITH_PAUSE.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.SPIN_WITH_PAUSE.CAST_DELAY = 6.0
                _C.PROFILE.SPIN_WITH_PAUSE.TIGHTEN_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DELAY = 3.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_TIMEOUT = 256.0
                _C.PROFILE.SPIN_WITH_PAUSE.PRE_ACCELERATION = False
                _C.PROFILE.SPIN_WITH_PAUSE.POST_ACCELERATION = "off"
                _C.PROFILE.SPIN_WITH_PAUSE.TYPE = "pause"
                
                
                _C.PROFILE.SPIN_WITH_LIFT = CN()
                _C.PROFILE.SPIN_WITH_LIFT.MODE = "spin"
                _C.PROFILE.SPIN_WITH_LIFT.LAUNCH_OPTIONS = ""
                _C.PROFILE.SPIN_WITH_LIFT.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.SPIN_WITH_LIFT.CAST_DELAY = 6.0
                _C.PROFILE.SPIN_WITH_LIFT.TIGHTEN_DURATION = 0.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DELAY = 1.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_TIMEOUT = 256.0
                _C.PROFILE.SPIN_WITH_LIFT.PRE_ACCELERATION = False
                _C.PROFILE.SPIN_WITH_LIFT.POST_ACCELERATION = "off"
                _C.PROFILE.SPIN_WITH_LIFT.TYPE = "lift"
                
                
                # ---------------------------------------------------------------------------- #
                #                            Bottom Fishing Profile                            #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.BOTTOM = CN()
                _C.PROFILE.BOTTOM.MODE = "bottom"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.BOTTOM.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.BOTTOM.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.BOTTOM.CAST_DELAY = 4.0  # Delay after casting before lure sinks
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.BOTTOM.POST_ACCELERATION = "off"
                # Delay before checking fish bite on next rod
                _C.PROFILE.BOTTOM.CHECK_DELAY = 32.0
                # Maximum allowed misses before recasting the rod
                _C.PROFILE.BOTTOM.CHECK_MISS_LIMIT = 16
                # Delay before checking if a fish is hooked again and putting down the rod
                _C.PROFILE.BOTTOM.PUT_DOWN_DELAY = 0.0
                
                
                # ---------------------------------------------------------------------------- #
                #                      Marine / Wakey Rig Pirking Profile                      #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.PIRK = CN()
                _C.PROFILE.PIRK.MODE = "pirk"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.PIRK.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.PIRK.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.PIRK.CAST_DELAY = 4.0  # Delay after casting before lure sinks
                _C.PROFILE.PIRK.SINK_TIMEOUT = 60.0  # Maximum time allowed for sinking
                # Duration to tighten the line after sinking lure/adjusting lure depth
                _C.PROFILE.PIRK.TIGHTEN_DURATION = 1.0
                # Delay after opening reel to adjust lure depth, set this to 0 to recast the rod instead
                _C.PROFILE.PIRK.DEPTH_ADJUST_DELAY = 4.0
                # Durtion to tighten the line after opening reel for DEPTH_ADJUST_DELAY seconds
                _C.PROFILE.PIRK.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.PIRK.CTRL = False  # Hold Ctrl key during pirking
                _C.PROFILE.PIRK.SHIFT = False  # Hold Shift key during pirking
                # Duration of lifting the rod, set this to 0 if you want to wait instead of pirking
                _C.PROFILE.PIRK.PIRK_DURATION = 0.5
                _C.PROFILE.PIRK.PIRK_DELAY = 2.0  # Delay after lifting the rod
                # Timeout for pirking session
                _C.PROFILE.PIRK.PIRK_TIMEOUT = 32.0
                # Retrieve the fishing line during pirking
                _C.PROFILE.PIRK.PIRK_RETRIEVAL = False
                # When a fish is hooked, check if the fish is still hooked
                # after HOOK_DELAY seconds, continue pirking if not
                _C.PROFILE.PIRK.HOOK_DELAY = 0.5
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.PIRK.POST_ACCELERATION = "auto"
                
                _C.PROFILE.PIRK_WITH_RETRIEVAL = CN()
                _C.PROFILE.PIRK_WITH_RETRIEVAL.MODE = "pirk"
                _C.PROFILE.PIRK_WITH_RETRIEVAL.LAUNCH_OPTIONS = ""
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_DELAY = 4.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.SINK_TIMEOUT = 60.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.TIGHTEN_DURATION = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DELAY = 0.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CTRL = False
                _C.PROFILE.PIRK_WITH_RETRIEVAL.SHIFT = False
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DURATION = 0.5
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DELAY = 2.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_TIMEOUT = 32.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_RETRIEVAL = True
                _C.PROFILE.PIRK_WITH_RETRIEVAL.HOOK_DELAY = 0.5
                _C.PROFILE.PIRK_WITH_RETRIEVAL.POST_ACCELERATION = "auto"
                
                # Spin fishing with wakey rig at Ladoga Archipelago
                _C.PROFILE.WAKEY_RIG = CN()
                _C.PROFILE.WAKEY_RIG.MODE = "pirk"
                _C.PROFILE.WAKEY_RIG.LAUNCH_OPTIONS = ""
                _C.PROFILE.WAKEY_RIG.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.WAKEY_RIG.CAST_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.SINK_TIMEOUT = 45.0
                _C.PROFILE.WAKEY_RIG.TIGHTEN_DURATION = 1.0
                _C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.WAKEY_RIG.CTRL = True
                _C.PROFILE.WAKEY_RIG.CTRL = False
                _C.PROFILE.WAKEY_RIG.PIRK_DURATION = 1.5
                _C.PROFILE.WAKEY_RIG.PIRK_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.PIRK_TIMEOUT = 32.0
                _C.PROFILE.WAKEY_RIG.PIRK_RETRIEVAL = False
                _C.PROFILE.WAKEY_RIG.HOOK_DELAY = 0.5
                _C.PROFILE.WAKEY_RIG.POST_ACCELERATION = "auto"
                
                # ---------------------------------------------------------------------------- #
                #                            Marine Elevator Profile                           #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.ELEVATOR = CN()
                _C.PROFILE.ELEVATOR.MODE = "elevator"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.ELEVATOR.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.ELEVATOR.CAST_POWER_LEVEL = 1.0
                # Delay after casting before lure sinks
                _C.PROFILE.ELEVATOR.CAST_DELAY = 4.0
                # Maximum time allowed for sinking
                _C.PROFILE.ELEVATOR.SINK_TIMEOUT = 60.0
                # Duration to tighten the line after sinking lure
                _C.PROFILE.ELEVATOR.TIGHTEN_DURATION = 1.0
                # Duration of retrieving the fishing line/opening the reel
                _C.PROFILE.ELEVATOR.ELEVATE_DURATION = 4.0
                # Delay after retrieving the fishing line/opening the reel
                _C.PROFILE.ELEVATOR.ELEVATE_DELAY = 4.0
                # Timeout for pirking session
                _C.PROFILE.ELEVATOR.ELEVATE_TIMEOUT = 40.0
                # Lock / Unlocking the reel after elevating timed out to drop the lure level by level
                _C.PROFILE.ELEVATOR.DROP = False
                # When a fish is hooked, check if the fish is still hooked
                # after HOOK_DELAY seconds, continue elevating if not
                _C.PROFILE.ELEVATOR.HOOK_DELAY = 0.5
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.ELEVATOR.POST_ACCELERATION = "auto"
                
                _C.PROFILE.ELEVATOR_WITH_DROP = CN()
                _C.PROFILE.ELEVATOR_WITH_DROP.MODE = "elevator"
                _C.PROFILE.ELEVATOR_WITH_DROP.LAUNCH_OPTIONS = ""
                _C.PROFILE.ELEVATOR_WITH_DROP.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.ELEVATOR_WITH_DROP.CAST_DELAY = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.SINK_TIMEOUT = 60.0
                _C.PROFILE.ELEVATOR_WITH_DROP.TIGHTEN_DURATION = 1.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DURATION = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DELAY = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_TIMEOUT = 40.0
                _C.PROFILE.ELEVATOR_WITH_DROP.DROP = True
                _C.PROFILE.ELEVATOR_WITH_DROP.HOOK_DELAY = 0.5
                _C.PROFILE.ELEVATOR_WITH_DROP.POST_ACCELERATION = "auto"
                
                # ---------------------------------------------------------------------------- #
                #                          Telescopic fishing Profile                          #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.TELESCOPIC = CN()
                _C.PROFILE.TELESCOPIC.MODE = "telescopic"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.TELESCOPIC.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.TELESCOPIC.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.TELESCOPIC.CAST_DELAY = 4.0
                # Sensitivity of float detection
                _C.PROFILE.TELESCOPIC.FLOAT_SENSITIVITY = 0.68
                _C.PROFILE.TELESCOPIC.CHECK_DELAY = 1.0  # Delay between fish bite checks
                _C.PROFILE.TELESCOPIC.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
                # Recast rod after timed out, designed for flowing water maps
                _C.PROFILE.TELESCOPIC.DRIFT_TIMEOUT = 16.0
                # Shape of the float camera, the script tracks the whole camrea window by default
                # Options: square, wide, tall
                _C.PROFILE.TELESCOPIC.CAMERA_SHAPE = "square"
                
                
                # ---------------------------------------------------------------------------- #
                #                           Bolognese Fishing Profile                          #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.BOLOGNESE = CN()
                _C.PROFILE.BOLOGNESE.MODE = "bolognese"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.BOLOGNESE.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.BOLOGNESE.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.BOLOGNESE.CAST_DELAY = 4.0
                # Sensitivity of float detection
                _C.PROFILE.BOLOGNESE.FLOAT_SENSITIVITY = 0.68
                _C.PROFILE.BOLOGNESE.CHECK_DELAY = 1.0  # Delay between fish bite checks
                _C.PROFILE.BOLOGNESE.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
                # Recast rod after timed out, designed for flowing water maps
                _C.PROFILE.BOLOGNESE.DRIFT_TIMEOUT = 32.0
                # Shape of the float camera, the script tracks the whole camrea window by default
                # Options: square, wide, tall
                # (Fallback to float camera detection mode if the window size is not supported)
                _C.PROFILE.BOLOGNESE.CAMERA_SHAPE = "square"
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.BOLOGNESE.POST_ACCELERATION = "off"
                
                
                def get_cfg_defaults():
                    """Get a yacs CfgNode object with default values for my_project."""
                    # Return a clone so that the defaults will not be altered
                    # This is for the "local variable" use pattern
                    return _C.clone()
            üìÑ env_config.py
                """
                –ú–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è
                """
                
                import os
                from typing import Optional
                from dotenv import load_dotenv
                
                
                class EnvironmentConfig:
                    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏."""
                    
                    def __init__(self):
                        # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env —Ñ–∞–π–ª–∞
                        load_dotenv()
                    
                    def get_discord_webhook_url(self) -> Optional[str]:
                        """–ü–æ–ª—É—á–∏—Ç—å Discord webhook URL –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è."""
                        return os.getenv('DISCORD_WEBHOOK_URL')
                    
                    def get_email_config(self) -> dict:
                        """–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ email –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è."""
                        return {
                            'email': os.getenv('EMAIL', ''),
                            'password': os.getenv('EMAIL_PASSWORD', ''),
                            'smtp_server': os.getenv('SMTP_SERVER', 'smtp.gmail.com')
                        }
                    
                    def get_miao_code(self) -> Optional[str]:
                        """–ü–æ–ª—É—á–∏—Ç—å Miao –∫–æ–¥ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è."""
                        return os.getenv('MIAO_CODE')
                    
                    def is_env_file_exists(self) -> bool:
                        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ .env —Ñ–∞–π–ª–∞."""
                        return os.path.exists('.env')
                    
                    def validate_environment(self) -> dict:
                        """
                        –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.
                        
                        Returns:
                            Dict —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏
                        """
                        result = {
                            'env_file_exists': self.is_env_file_exists(),
                            'discord_configured': bool(self.get_discord_webhook_url()),
                            'email_configured': bool(self.get_email_config()['email']),
                            'miao_configured': bool(self.get_miao_code()),
                            'warnings': []
                        }
                        
                        if not result['env_file_exists']:
                            result['warnings'].append(
                                "–§–∞–π–ª .env –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–æ–∑–¥–∞–π—Ç–µ –µ–≥–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ .env.example"
                            )
                        
                        if not result['discord_configured'] and not result['email_configured']:
                            result['warnings'].append(
                                "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã. –î–æ–±–∞–≤—å—Ç–µ DISCORD_WEBHOOK_URL –∏–ª–∏ EMAIL –≤ .env"
                            )
                        
                        return result
            üìÑ __init__.py
                """RF4S Config module"""
                from . import config
                __all__ = ['config']
            üìÅ __pycache__/
                üìÑ config.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ defaults.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ env_config.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ controller/
            üìÑ detection.py
                """RF4S Detection controller"""
                class Detection:
                    """Game state detection controller"""
                    
                    def __init__(self, config, window):
                        self.config = config
                        self.window = window
                        
                    def is_fish_hooked(self):
                        """Check if fish is hooked"""
                        return False
                        
                    def is_retrieval_finished(self):
                        """Check if retrieval is finished"""
                        return True
                        
                    def is_tackle_ready(self):
                        """Check if tackle is ready"""
                        return True
                        
                    def is_lure_broken(self):
                        """Check if lure is broken"""
                        return False
                        
                    def is_bait_chosen(self):
                        """Check if bait is chosen"""
                        return True
                        
                    def is_energy_high(self):
                        """Check if energy is high"""
                        return True
                        
                    def is_comfort_low(self):
                        """Check if comfort is low"""  
                        return False
                        
                    def is_hunger_low(self):
                        """Check if hunger is low"""
                        return False
            üìÑ notification.py
                import json
                import logging
                import smtplib
                from datetime import datetime, timezone
                from email.mime.multipart import MIMEMultipart
                from email.mime.text import MIMEText
                from enum import Enum
                from urllib import parse, request
                
                from discord_webhook import DiscordEmbed, DiscordWebhook
                from rich import box
                from rich.console import Console
                from rich.table import Table
                
                logger = logging.getLogger("rich")
                
                ICON_URL = "https://i.ibb.co/RpLYcdkm/icon.png"
                
                # Name                             | Int value | Hex code
                # ---------------------------------|-----------|----------
                # `BLURPLE`                        | 5793266   | `#5865F2`
                # `GREEN`                          | 5763719   | `#57F287`
                # `YELLOW`                         | 16705372  | `#FEE75C`
                # `FUSCHIA`                        | 15418782  | `#EB459E`
                # `RED`                            | 15548997  | `#ED4245`
                # `WHITE`                          | 16777215  | `#FFFFFF`
                # `BLACK`                          | 2303786   | `#23272A`
                
                
                class DiscordColor(Enum):
                    BLURPLE = 5793266
                    GREEN = 5763719
                    YELLOW = 16705372
                    FUSCHIA = 15418782
                    RED = 15548997
                    WHITE = 16777215
                    BLACK = 2303786
                
                
                class DiscordNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def build_raw_table(self) -> str:
                        console = Console(width=100, force_terminal=True, color_system=None)
                        table = Table("Field", "Value", box=box.DOUBLE, show_header=False)
                
                        for key, value in self.result.items():
                            table.add_row(key, str(value))
                
                        with console.capture() as capture:
                            console.print(table)
                
                        return capture.get().strip()
                
                    def send(self, color: DiscordColor):
                        logger.info("Sending Discord notification")
                        raw_table = self.build_raw_table()
                        webhook = DiscordWebhook(
                            url=self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL,
                            username="RF4S",
                            avatar_url=ICON_URL,
                        )
                
                        embed = DiscordEmbed(
                            title="Running Result",
                            color=color,
                            timestamp=datetime.now(timezone.utc).isoformat(),
                            footer={"text": "RF4S: Russian Fishing 4 Script", "icon_url": ICON_URL},
                        )
                        embed.description = f"```\n{raw_table}\n```"  # Wrap in code block
                
                        webhook.add_embed(embed)
                        response = webhook.execute()
                
                        if response.status_code == 200:
                            logger.info("Result successfully sent to Discord")
                        else:
                            logger.error(f"Failed to send result to Discord: {response.text}")
                
                
                class EmailNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def send(self) -> None:
                        """Send a notification email to the user's email address."""
                        logger.info("Sending email notification")
                
                        msg = MIMEMultipart()
                        msg["Subject"] = "RF4S: Notice of Program Termination"
                        msg["From"] = self.cfg.NOTIFICATION.EMAIL
                        recipients = [self.cfg.NOTIFICATION.EMAIL]
                        msg["To"] = ", ".join(recipients)
                
                        text = ""
                        for k, v in self.result.items():
                            text += f"{k}: {v}\n"
                        msg.attach(MIMEText(text))
                
                        try:
                            with smtplib.SMTP_SSL(self.cfg.NOTIFICATION.SMTP_SERVER, 465) as server:
                                # smtp_server.ehlo()
                                server.login(
                                    self.cfg.NOTIFICATION.EMAIL, self.cfg.NOTIFICATION.PASSWORD
                                )
                                server.sendmail(
                                    self.cfg.NOTIFICATION.EMAIL, recipients, msg.as_string()
                                )
                            logger.info("Email sent successfully")
                        except Exception as e:
                            logger.error(f"Failed to send email: {e}")
                
                
                class MiaotixingNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def send(self) -> None:
                        """Send a notification to the user's miaotixing service.
                
                        :param result: running result
                        :type result: dict
                        """
                        logger.info("Sending miaotixing notification")
                
                        text = ""
                        for k, v in self.result.items():
                            text += f"{k}: {v}\n"
                
                        url = "http://miaotixing.com/trigger?" + parse.urlencode(
                            {"id": self.cfg.NOTIFICATION.MIAO_CODE, "text": text, "type": "json"}
                        )
                
                        with request.urlopen(url) as page:
                            result = page.read()
                            json_object = json.loads(result)
                            if json_object["code"] == 0:
                                logger.info("Miaotixing notification sent successfully")
                            else:
                                logger.error(
                                    "Miaotixing notification with error code: %s\nDescription: %s",
                                    str(json_object["code"]),
                                    json_object["msg"],
                                )
            üìÑ timer.py
                """
                RF4S Timer controller - Compatible with original structure
                –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Ç–∞–π–º–µ—Ä–∞ RF4S - —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
                """
                
                import datetime
                import logging
                import sys
                import time
                from pathlib import Path
                from typing import List, Tuple, Optional
                
                # Optional matplotlib import
                try:
                    from matplotlib import pyplot as plt
                    from matplotlib.ticker import MaxNLocator
                    MATPLOTLIB_AVAILABLE = True
                except ImportError:
                    MATPLOTLIB_AVAILABLE = False
                    plt = None
                    MaxNLocator = None
                
                try:
                    from rf4s.utils import is_compiled
                except ImportError:
                    def is_compiled():
                        return (
                            hasattr(sys, 'frozen') or
                            hasattr(sys, '_MEIPASS') or
                            '__compiled__' in globals()
                        )
                
                try:
                    from rich import print
                    RICH_AVAILABLE = True
                except ImportError:
                    RICH_AVAILABLE = False
                    def print(*args, **kwargs):
                        import builtins
                        builtins.print(*args)
                
                logger = logging.getLogger("rich")
                
                # Get root path
                if is_compiled():
                    ROOT = Path(sys.executable).parent  # Running as .exe (Nuitka/PyInstaller)
                else:
                    ROOT = Path(__file__).resolve().parents[2]
                
                
                class Timer:
                    """Class for calculating and generating timestamps for logs.
                
                    This class manages various timers and counters for tracking in-game events,
                    such as casting times, consumable cooldowns, and script pauses.
                
                    Attributes:
                        cfg: Configuration node for timer settings.
                        start_time (float): Timestamp when the timer was initialized.
                        start_datetime (str): Formatted start date and time.
                        cast_rhour (int | None): Real-time hour of the last cast.
                        cast_ghour (int | None): In-game hour of the last cast.
                        cast_rhour_list (list[int]): List of real-time hours for casts.
                        cast_ghour_list (list[int]): List of in-game hours for casts.
                        last_tea_drink (float): Timestamp of the last tea consumption.
                        last_alcohol_drink (float): Timestamp of the last alcohol consumption.
                        last_lure_change (float): Timestamp of the last lure change.
                        last_spod_rod_recast (float): Timestamp of the last spod rod recast.
                        last_pause (float): Timestamp of the last script pause.
                    """
                
                    def __init__(self, cfg=None):
                        """Initialize the Timer class with configuration settings.
                
                        :param cfg: Configuration node for timer settings.
                        """
                        self.cfg = cfg
                        self.start_time = time.time()
                        self.start_datetime = time.strftime("%m/%d %H:%M:%S", time.localtime())
                
                        # Cast tracking
                        self.cast_rhour: Optional[int] = None
                        self.cast_ghour: Optional[int] = None
                        self.cast_rhour_list: List[int] = []
                        self.cast_ghour_list: List[int] = []
                
                        # Cooldown tracking
                        self.last_tea_drink = 0.0
                        self.last_alcohol_drink = 0.0
                        self.last_lure_change = self.start_time
                        self.last_spod_rod_recast = self.start_time
                        self.last_pause = self.start_time
                
                    def get_running_time(self) -> float:
                        """Calculate the execution time of the program in seconds.
                
                        :return: Running time in seconds.
                        :rtype: float
                        """
                        return time.time() - self.start_time
                
                    def get_running_time_str(self) -> str:
                        """Calculate the execution time of the program as formatted string.
                
                        :return: Formatted execution time (hh:mm:ss).
                        :rtype: str
                        """
                        total_seconds = int(self.get_running_time())
                        return str(datetime.timedelta(seconds=total_seconds))
                
                    def get_cur_timestamp(self) -> str:
                        """Generate timestamp for images in screenshots/.
                
                        :return: Current timestamp.
                        :rtype: str
                        """
                        return time.strftime("%Y-%m-%d--%H-%M-%S", time.localtime())
                
                    def get_start_datetime(self) -> str:
                        """Generate a simplified timestamp for quit message.
                
                        :return: Start date and time.
                        :rtype: str
                        """
                        return self.start_datetime
                
                    def get_cur_datetime(self) -> str:
                        """Generate a simplified timestamp for quit message.
                
                        :return: Current date and time.
                        :rtype: str
                        """
                        return time.strftime("%m/%d %H:%M:%S", time.localtime())
                
                    def update_cast_time(self) -> None:
                        """Update the latest real and in-game hour of casting."""
                        dt = datetime.datetime.now()
                        self.cast_rhour = int((time.time() - self.start_time) // 3600)
                        self.cast_ghour = int((dt.minute / 60 + dt.second / 3600) * 24 % 24)
                
                    def add_cast_time(self) -> None:
                        """Record the latest real and in-game hour of casting."""
                        if self.cast_rhour is not None:
                            self.cast_rhour_list.append(self.cast_rhour)
                        if self.cast_ghour is not None:
                            self.cast_ghour_list.append(self.cast_ghour)
                
                    def get_cast_time_list(self) -> Tuple[List[int], List[int]]:
                        """Get lists of real and in-game hours for casts.
                
                        :return: Lists of real and in-game hours.
                        :rtype: tuple[list[int], list[int]]
                        """
                        return self.cast_rhour_list, self.cast_ghour_list
                
                    def is_tea_drinkable(self) -> bool:
                        """Check if it has been a long time since the last tea consumption.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        tea_delay = 300  # Default 5 minutes
                        
                        if self.cfg and hasattr(self.cfg, 'STAT') and hasattr(self.cfg.STAT, 'TEA_DELAY'):
                            tea_delay = self.cfg.STAT.TEA_DELAY
                            
                        if cur_time - self.last_tea_drink > tea_delay:
                            self.last_tea_drink = cur_time
                            return True
                        return False
                
                    def is_alcohol_drinkable(self) -> bool:
                        """Check if it has been a long time since the last alcohol consumption.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        alcohol_delay = 900  # Default 15 minutes
                        
                        if self.cfg and hasattr(self.cfg, 'STAT') and hasattr(self.cfg.STAT, 'ALCOHOL_DELAY'):
                            alcohol_delay = self.cfg.STAT.ALCOHOL_DELAY
                            
                        if cur_time - self.last_alcohol_drink > alcohol_delay:
                            self.last_alcohol_drink = cur_time
                            self.last_tea_drink = cur_time  # Alcohol also refills comfort
                            return True
                        return False
                
                    def is_lure_changeable(self) -> bool:
                        """Check if it has been a long time since the last lure change.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        lure_delay = 1800  # Default 30 minutes
                        
                        if (self.cfg and hasattr(self.cfg, 'SCRIPT') and 
                            hasattr(self.cfg.SCRIPT, 'LURE_CHANGE_DELAY')):
                            lure_delay = self.cfg.SCRIPT.LURE_CHANGE_DELAY
                            
                        if cur_time - self.last_lure_change > lure_delay:
                            self.last_lure_change = cur_time
                            return True
                        return False
                
                    def is_spod_rod_castable(self) -> bool:
                        """Check if it has been a long time since the last spod rod recast.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        spod_delay = 1800  # Default 30 minutes
                        
                        if (self.cfg and hasattr(self.cfg, 'SCRIPT') and 
                            hasattr(self.cfg.SCRIPT, 'SPOD_ROD_RECAST_DELAY')):
                            spod_delay = self.cfg.SCRIPT.SPOD_ROD_RECAST_DELAY
                            
                        if cur_time - self.last_spod_rod_recast > spod_delay:
                            self.last_spod_rod_recast = cur_time
                            return True
                        return False
                
                    def is_script_pausable(self) -> bool:
                        """Check if it has been a long time since the last script pause.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        pause_delay = 1800  # Default 30 minutes
                        
                        if (self.cfg and hasattr(self.cfg, 'PAUSE') and 
                            hasattr(self.cfg.PAUSE, 'DELAY')):
                            pause_delay = self.cfg.PAUSE.DELAY
                            
                        if cur_time - self.last_pause > pause_delay:
                            self.last_pause = cur_time
                            return True
                        return False
                
                    def plot_and_save(self) -> None:
                        """Plot and save an image using rhour and ghour lists from the timer object."""
                        if not MATPLOTLIB_AVAILABLE:
                            if RICH_AVAILABLE:
                                print("[yellow]Matplotlib not available - skipping plot generation[/yellow]")
                            else:
                                print("Matplotlib not available - skipping plot generation")
                            return
                
                        try:
                            logger.info("Plotting line chart")
                
                            cast_rhour_list, cast_ghour_list = self.get_cast_time_list()
                            
                            if not cast_rhour_list or not cast_ghour_list:
                                if RICH_AVAILABLE:
                                    print("[yellow]No cast data available for plotting[/yellow]")
                                else:
                                    print("No cast data available for plotting")
                                return
                
                            fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(12, 5))
                            
                            # Plot fish per real hour
                            ax[0].set_ylabel("Fish")
                            last_rhour = max(cast_rhour_list)
                            fish_per_rhour = [0] * (last_rhour + 1)
                            
                            for hour in cast_rhour_list:
                                if 0 <= hour <= last_rhour:
                                    fish_per_rhour[hour] += 1
                                    
                            ax[0].plot(range(last_rhour + 1), fish_per_rhour, marker='o')
                            ax[0].set_title("Fish Caught per Real Hour")
                            ax[0].set_xticks(range(last_rhour + 2))
                            ax[0].set_xlabel("Hour (real running time)")
                            ax[0].yaxis.set_major_locator(MaxNLocator(integer=True))
                            ax[0].grid(True, alpha=0.3)
                
                            # Plot fish per game hour
                            fish_per_ghour = [0] * 24
                            for hour in cast_ghour_list:
                                if 0 <= hour < 24:
                                    fish_per_ghour[hour] += 1
                                    
                            ax[1].bar(range(0, 24), fish_per_ghour, alpha=0.7)
                            ax[1].set_title("Fish Caught per Game Hour")
                            ax[1].set_xticks(range(0, 24, 2))
                            ax[1].set_xlabel("Hour (game time)")
                            ax[1].yaxis.set_major_locator(MaxNLocator(integer=True))
                            ax[1].grid(True, alpha=0.3)
                
                            plt.tight_layout()
                            
                            # Ensure logs directory exists
                            logs_dir = ROOT / "logs"
                            logs_dir.mkdir(exist_ok=True)
                            
                            # Save plot
                            plot_path = logs_dir / f"{self.get_cur_timestamp()}.png"
                            plt.savefig(str(plot_path), dpi=150, bbox_inches='tight')
                            plt.close(fig)  # Close figure to free memory
                            
                            logger.info(f"Chart has been saved: {plot_path}")
                            
                            if RICH_AVAILABLE:
                                print(f"[green]Chart saved: {plot_path}[/green]")
                            else:
                                print(f"Chart saved: {plot_path}")
                
                        except Exception as e:
                            error_msg = f"Failed to create plot: {e}"
                            logger.error(error_msg)
                            
                            if RICH_AVAILABLE:
                                print(f"[red]{error_msg}[/red]")
                            else:
                                print(error_msg)
                
                    # Additional utility methods for compatibility
                    def reset_timers(self):
                        """Reset all timers to current time."""
                        current_time = time.time()
                        self.last_tea_drink = 0.0
                        self.last_alcohol_drink = 0.0
                        self.last_lure_change = current_time
                        self.last_spod_rod_recast = current_time
                        self.last_pause = current_time
                
                    def get_time_since_start(self) -> float:
                        """Get time elapsed since timer start."""
                        return time.time() - self.start_time
                
                    def get_cast_statistics(self) -> dict:
                        """Get statistics about casts."""
                        total_casts = len(self.cast_rhour_list)
                        running_time_hours = self.get_running_time() / 3600
                        
                        return {
                            'total_casts': total_casts,
                            'running_time_hours': running_time_hours,
                            'casts_per_hour': total_casts / max(0.01, running_time_hours),
                            'unique_real_hours': len(set(self.cast_rhour_list)) if self.cast_rhour_list else 0,
                            'unique_game_hours': len(set(self.cast_ghour_list)) if self.cast_ghour_list else 0
                        }
                
                    def force_tea_drink_time(self):
                        """Force update tea drink time (for manual consumption)."""
                        self.last_tea_drink = time.time()
                
                    def force_alcohol_drink_time(self):
                        """Force update alcohol drink time (for manual consumption)."""
                        self.last_alcohol_drink = time.time()
                        self.last_tea_drink = time.time()  # Alcohol also refills comfort
                
                    def get_next_tea_time(self) -> float:
                        """Get seconds until next tea can be consumed."""
                        tea_delay = 300
                        if self.cfg and hasattr(self.cfg, 'STAT') and hasattr(self.cfg.STAT, 'TEA_DELAY'):
                            tea_delay = self.cfg.STAT.TEA_DELAY
                            
                        time_passed = time.time() - self.last_tea_drink
                        return max(0, tea_delay - time_passed)
                
                    def get_next_alcohol_time(self) -> float:
                        """Get seconds until next alcohol can be consumed."""
                        alcohol_delay = 900
                        if self.cfg and hasattr(self.cfg, 'STAT') and hasattr(self.cfg.STAT, 'ALCOHOL_DELAY'):
                            alcohol_delay = self.cfg.STAT.ALCOHOL_DELAY
                            
                        time_passed = time.time() - self.last_alcohol_drink
                        return max(0, alcohol_delay - time_passed)
                
                    def __str__(self) -> str:
                        """String representation of timer."""
                        return f"Timer(running={self.get_running_time_str()}, casts={len(self.cast_rhour_list)})"
                
                    def __repr__(self) -> str:
                        """Detailed representation of timer."""
                        return (f"Timer(start_time={self.start_time}, "
                                f"running_time={self.get_running_time():.1f}s, "
                                f"casts={len(self.cast_rhour_list)})")
            üìÑ window.py
                """RF4S Window controller"""
                class Window:
                    """Game window management"""
                    
                    def __init__(self): 
                        pass
                        
                    def is_title_bar_exist(self):
                        """Check if window has title bar"""
                        return False
                        
                    def is_size_supported(self):
                        """Check if window size is supported"""
                        return True
                        
                    def get_resolution_str(self):
                        """Get resolution string"""
                        return "1920x1080"
                        
                    def activate_game_window(self):
                        """Activate game window"""
                        print("Activating game window...")
                        
                    def activate_script_window(self):
                        """Activate script window"""
                        print("Activating script window...")
                        
                    def save_screenshot(self, filename):
                        """Save screenshot"""
                        print(f"Screenshot saved: {filename}")
            üìÑ __init__.py
                """RF4S Controller module"""
                try:
                    from .detection import Detection
                    from .window import Window
                    __all__ = ['Detection', 'Window']
                except ImportError:
                    __all__ = []
            üìÅ __pycache__/
                üìÑ detection.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ notification.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ timer.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ window.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ result/
            üìÑ result.py
                """RF4S Result tracking"""
                from dataclasses import dataclass
                
                @dataclass
                class Result:
                    """Basic result tracking"""
                    
                    def __init__(self):
                        self.data = {}
                        
                    def as_dict(self):
                        """Return result as dictionary"""
                        return self.data
                        
                    def add_result(self, key, value):
                        """Add result entry"""
                        self.data[key] = value
                        
                    def clear(self):
                        """Clear all results"""
                        self.data = {}
            üìÑ __init__.py
                """RF4S Result module"""
                try:
                    from .result import Result
                    __all__ = ['Result']
                except ImportError:
                    __all__ = []
            üìÅ __pycache__/
                üìÑ result.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ utils/
            üìÑ utils.py
                """RF4S Utility functions"""
                import sys
                import time
                import logging
                import os
                from pathlib import Path
                
                try:
                    from rich.logging import RichHandler
                    from rich.console import Console
                    from rich import print
                    console = Console()
                    RICH_AVAILABLE = True
                except ImportError:
                    RICH_AVAILABLE = False
                    console = None
                    def print(*args, **kwargs):
                        import builtins
                        builtins.print(*args)
                
                def is_compiled():
                    """Check if script is running as compiled executable"""
                    return (
                        hasattr(sys, 'frozen') or
                        hasattr(sys, '_MEIPASS') or
                        '__compiled__' in globals() or
                        'python' not in sys.executable.lower()
                    )
                
                def safe_exit():
                    """Safely exit the application"""
                    if RICH_AVAILABLE:
                        print("[yellow]Exiting safely...[/yellow]")
                    else:
                        print("Exiting safely...")
                    sys.exit(0)
                
                def create_rich_logger(name="RF4S", level=logging.INFO):
                    """Create a rich logger with formatting"""
                    logger = logging.getLogger(name)
                    
                    if logger.handlers:
                        return logger
                    
                    logger.setLevel(level)
                    
                    if RICH_AVAILABLE:
                        rich_handler = RichHandler(
                            console=console,
                            rich_tracebacks=True,
                            markup=True,
                            show_path=False
                        )
                        formatter = logging.Formatter(fmt="%(message)s", datefmt="[%X]")
                        rich_handler.setFormatter(formatter)
                        logger.addHandler(rich_handler)
                    else:
                        handler = logging.StreamHandler()
                        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                        handler.setFormatter(formatter)
                        logger.addHandler(handler)
                    
                    return logger
                
                def update_argv():
                    """Update sys.argv for compatibility"""
                    pass
                
                def get_root_path():
                    """Get root path depending on runtime environment"""
                    if is_compiled():
                        return Path(sys.executable).parent
                    else:
                        return Path(__file__).resolve().parents[2]
                
                def format_time_duration(seconds):
                    """Format time duration to human readable format"""
                    if seconds < 60:
                        return f"{seconds:.1f}s"
                    elif seconds < 3600:
                        minutes = seconds / 60
                        return f"{minutes:.1f}m"
                    else:
                        hours = seconds / 3600
                        return f"{hours:.1f}h"
                
                def sleep_and_decrease(counter, delay):
                    """Sleep for delay and decrease counter"""
                    time.sleep(delay)
                    return counter - delay
                
                def hold_mouse_button(duration):
                    """Hold mouse button for specified duration"""
                    try:
                        import pyautogui
                        if duration > 0:
                            pyautogui.mouseDown()
                            time.sleep(duration)
                            pyautogui.mouseUp()
                    except ImportError:
                        if RICH_AVAILABLE:
                            print("[yellow]PyAutoGUI not available[/yellow]")
                        else:
                            print("PyAutoGUI not available")
                
                def reset_friction_brake_after(func):
                    """Decorator to reset friction brake after function execution"""
                    def wrapper(*args, **kwargs):
                        try:
                            return func(*args, **kwargs)
                        finally:
                            pass
                    return wrapper
            üìÑ __init__.py
                """RF4S Utils module"""
                try:
                    from .utils import (
                        safe_exit, create_rich_logger, update_argv, is_compiled,
                        get_root_path, format_time_duration
                    )
                    __all__ = [
                        'safe_exit', 'create_rich_logger', 'update_argv', 'is_compiled',
                        'get_root_path', 'format_time_duration'
                    ]
                except ImportError:
                    __all__ = []
            üìÅ __pycache__/
                üìÑ utils.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ __pycache__/
            üìÑ exceptions.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ player.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ utils.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ __init__.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
    üìÅ screenshots/
    üìÅ static/
        üìÅ en/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ classic_feed_mix.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ dry_feed_mix.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ ok_black.png [IMAGE FILE]
            üìÑ ok_white.png [IMAGE FILE]
            üìÑ perch.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ pva_stick_or_pva_stringer.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ shorthorn_sculpin.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ readme/
            üìÑ clicklock.png [IMAGE FILE]
            üìÑ favorite_food.png [IMAGE FILE]
            üìÑ favorite_lure.png [IMAGE FILE]
            üìÑ icon.png [IMAGE FILE]
            üìÑ mtx1.png [IMAGE FILE]
            üìÑ mtx2.png [IMAGE FILE]
            üìÑ mtx3.png [IMAGE FILE]
            üìÑ path.png [IMAGE FILE]
            üìÑ RF4S.png [IMAGE FILE]
            üìÑ RF4S_original.png [IMAGE FILE]
            üìÑ status.png [IMAGE FILE]
        üìÅ ru/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ classic_feed_mix.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ dry_feed_mix.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ ok_black.png [IMAGE FILE]
            üìÑ ok_white.png [IMAGE FILE]
            üìÑ perch.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ pva_stick_or_pva_stringer.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ shorthorn_sculpin.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ sound/
            üìÑ app_1.wav [AUDIO FILE]
            üìÑ app_2.wav [AUDIO FILE]
            üìÑ app_3.wav [AUDIO FILE]
            üìÑ bell_1.wav [AUDIO FILE]
            üìÑ bell_2.wav [AUDIO FILE]
            üìÑ bell_3.wav [AUDIO FILE]
            üìÑ digital.wav [AUDIO FILE]
            üìÑ door_bell.wav [AUDIO FILE]
            üìÑ elevator.wav [AUDIO FILE]
            üìÑ fast_alarm.wav [AUDIO FILE]
            üìÑ flute_1.wav [AUDIO FILE]
            üìÑ flute_2.wav [AUDIO FILE]
            üìÑ guitar.wav [AUDIO FILE]
            üìÑ marimba.wav [AUDIO FILE]
            üìÑ ripple.wav [AUDIO FILE]
        üìÅ zh-CN/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ zh-TW/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
    üìÅ tools/
        üìÑ auto_friction_brake.py
            """Automate friction brake adjustments in Russian Fishing 4.
            
            This module provides functionality to automatically adjust the friction brake
            based on in-game conditions. It supports key bindings for exiting the script
            and resetting the friction brake.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from multiprocessing import Lock
            
            from pynput import keyboard
            from rich import print
            
            sys.path.append(".")
            from rf4s.app.app import ToolApp
            from rf4s.component.friction_brake import FrictionBrake
            from rf4s.config.config import print_cfg
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            logger = create_rich_logger()
            
            
            class FrictionBrakeApp(ToolApp):
                """Main application class for automating friction brake adjustments.
            
                This class manages the configuration, detection, and execution of the friction
                brake automation process. It also handles key bindings for exiting and resetting.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
                    friction_brake (FrictionBrake): Friction brake controller instance.
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    1. Check the game window state.
                    2. Format keybinds in cfg node.
                    3. Display cfg node.
                    4. Initialize a friction brake instance.
                    """
                    super().__init__()
                    if not self.is_game_window_valid():
                        safe_exit()
            
                    # Format keys
                    self.cfg.defrost()
                    self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
                    self.cfg.ARGS.RESET_KEY = f"'{self.cfg.ARGS.RESET_KEY}'"
                    self.cfg.freeze()
                    print_cfg(self.cfg.ARGS)
                    print_cfg(self.cfg.FRICTION_BRAKE)
            
                    self.friction_brake = FrictionBrake(self.cfg, Lock(), self.detection)
            
                def is_game_window_valid(self) -> bool:
                    """Check if the game window mode and size are valid.
            
                    :return: True if valid, False otherwise
                    :rtype: bool
                    """
                    if self.window.is_title_bar_exist():
                        logger.info("Window mode detected. Please don't move the game window")
                    if not self.window.is_size_supported():
                        logger.critical(
                            'Window mode must be "Borderless windowed" or "Window mode"'
                        )
                        logger.critical(
                            "Unsupported window size '%s', "
                            "use '2560x1440', '1920x1080' or '1600x900'",
                            self.window.get_resolution_str(),
                        )
                        return False
                    return True
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(description="Automate friction brake.")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-r",
                        "--reset-key",
                        default="g",
                        type=str,
                        help="key to reset friction brake, g by default",
                        metavar="KEY",
                    )
                    parser.add_argument(
                        "-q",
                        "--quit-key",
                        default="h",
                        type=str,
                        help="key to quit the script, h by default",
                        metavar="KEY",
                    )
                    return parser
            
                def _on_release(self, key: keyboard.KeyCode) -> None:
                    """Handle exit and quit events.
            
                    :param key: The key that was released.
                    :type key: keyboard.KeyCode
                    """
                    keystroke = str(key).lower()
                    if keystroke == self.cfg.ARGS.QUIT_KEY:
                        self.friction_brake.monitor_process.terminate()
                        sys.exit()
                    if keystroke == self.cfg.ARGS.RESET_KEY:
                        self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)
            
                def _start(self):
                    """Start the friction brake automation process.
            
                    Begins the friction brake monitoring process and starts a keyboard listener
                    to handle control keys.
                    """
                    print(
                        f"Press {self.cfg.ARGS.RESET_KEY[1:-1]} to reset friction brake, "
                        f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
                    )
                    self.friction_brake.monitor_process.start()
                    with keyboard.Listener(on_release=self._on_release) as listener:
                        listener.join()
            
            
            def run_app_from_main():
                try:
                    FrictionBrakeApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    FrictionBrakeApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ calculate.py
            """Calculate the maximum friction brake you can use on your tackle.
            
            This module provides functionality to calculate the maximum friction brake and tension
            based on the reel's max drag, friction brake wear, leader's load capacity, and wear.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import sys
            
            from rich import print
            from rich.prompt import Prompt
            from rich.table import Table
            
            sys.path.append(".")
            from rf4s import utils
            
            BIAS = 1e-6
            
            
            def get_tackle_stats():
                """Get actual stats of reel and leader based on their wears.
            
                Prompts the user for input and calculates the true max drag and load capacity
                after accounting for wear.
            
                :return: A tuple containing the true max drag and true load capacity.
                :rtype: tuple[float, float]
                """
                prompts = (
                    "Reel's max drag (kg)",
                    "Reel's friction brake wear (%)",
                    "Leader's load capacity (kg)",
                    "Leader's wear (%)",
                )
            
                while True:
                    restart = False
                    stats = []
                    for prompt in prompts:
                        validated_input = get_validated_input(prompt)
                        if validated_input is None:
                            restart = True
                            break
                        stats.append(validated_input)
            
                    if restart:
                        continue
            
                    max_drag, friction_brake_wear, leader_load_capacity, leader_wear = stats
                    true_max_drag = max_drag * (100 - friction_brake_wear) / 100
                    true_load_capacity = leader_load_capacity * (100 - leader_wear) / 100
                    return true_max_drag, true_load_capacity
            
            
            def get_validated_input(prompt: str) -> float | None:
                """Get validated input from the user.
            
                Prompts the user for input and validates it. Supports quitting and restarting.
            
                :param prompt: The prompt message to display to the user.
                :type prompt: str
                :return: The validated input as a float, or None if the user chooses to restart.
                :rtype: float or None
                """
                while True:
                    user_input = Prompt.ask(prompt)
                    if user_input == "q":
                        print("Bye.")
                        sys.exit()
                    if user_input == "r":
                        return None
            
                    try:
                        return float(user_input)
                    except ValueError:
                        utils.print_error("Invalid input. Please enter a number.")
            
            
            def main():
                """Main function to run the friction brake calculation.
            
                Prompts the user for input, calculates the result, and displays them in a table.
                """
                print("Please enter your tackle's stats, type q to quit, r to restart:")
                while True:
                    max_drag, load_capacity = get_tackle_stats()
                    max_friction_brake = int(min(load_capacity * 30 / (max_drag + BIAS) - 1, 29))
                    max_tension = max_drag * max_friction_brake / 30
            
                    table = Table(
                        "Result",
                        title="Your tackle's real stats üé£",
                        show_header=False,
                        min_width=36,
                    )
                    table.add_row("Reel's true max drag", f"{max_drag:.2f} kg")
                    table.add_row("Leader's true load capacity", f"{load_capacity:.2f} kg")
                    table.add_row("Friction brake tension", f"{max_tension:.2f} kg")
                    table.add_row("Maximum friction brake to use", f"{max_friction_brake}")
                    print(table)
            
            
            def run_app_from_main():
                main()
            
            
            if __name__ == "__main__":
                main()
        üìÑ craft.py
            """Activate game window and start crafting things until running out of materials.
            
            This module automates the crafting process in Russian Fishing 4. It supports
            discarding crafted items, fast crafting mode, and a configurable crafting limit.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import random
            import sys
            from datetime import datetime
            from pathlib import Path
            from time import sleep
            
            import pyautogui as pag
            from pynput import keyboard
            
            sys.path.append(".")
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.result.result import CraftResult
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            CRAFT_DELAY = 4.0
            CRAFT_DELAY_3X = CRAFT_DELAY * 3
            LOOP_DELAY = 0.5
            LOOP_DELAY_3X = LOOP_DELAY * 3
            ROOT = Path(__file__).resolve().parents[1]
            
            logger = create_rich_logger()
            
            
            class CraftApp(ToolApp):
                """Main application class for automating crafting.
            
                This class manages the configuration, detection, and execution of the crafting
                process. It tracks the number of successful and failed crafts, as well as the
                total number of materials used.
                """
            
                def __init__(self):
                    """Initialize the application."""
                    super().__init__()
                    print_cfg(self.cfg.ARGS)
                    self.result = CraftResult()
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(description="Craft items automatically.")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-d",
                        "--discard",
                        action="store_true",
                        help="discard all the crafted items (for groundbaits)",
                    )
                    parser.add_argument(
                        "-f",
                        "--fast",
                        action="store_true",
                        help="disable delay randomization to speed up crafting",
                    )
                    parser.add_argument(
                        "-n",
                        "--craft-limit",
                        type=int,
                        default=-1,
                        help="number of items to craft, no limit by default",
                        metavar="LIMIT",
                    )
                    return parser
            
                def get_action_delays(self) -> tuple[float, float]:
                    """Get crafting and checking delays.
            
                    :return: Two delays in seconds
                    :rtype: tuple[float, float]
                    """
                    if self.cfg.ARGS.FAST:
                        return CRAFT_DELAY, LOOP_DELAY
                    return (
                        random.uniform(CRAFT_DELAY, CRAFT_DELAY_3X),
                        random.uniform(LOOP_DELAY, LOOP_DELAY_3X),
                    )
            
                def move_cursor_to_make_button(self) -> None:
                    """Move the cursor to the make button position.
            
                    This method uses the Detection class to find the position of the make button
                    and moves the cursor to that position.
                    """
                    make_button_position = self.detection.get_make_button_position()
                    if make_button_position is None:
                        logger.critical(
                            "Make button not found, please set the interface scale to "
                            "1x or move your mouse around"
                        )
                        self.window.activate_script_window()
                        safe_exit()
                    pag.moveTo(make_button_position)
            
                def craft_item(
                    self, craft_delay: float, accept_delay: float, accept_key: str
                ) -> None:
                    """Craft an item.
            
                    :param craft_delay: Delay in seconds before accepting the crafted item.
                    :type craft_delay: float
                    :param accept_delay: Delay in seconds after accepting the crafted item.
                    :type accept_delay: float
                    :param accept_key: Key to press after accepting the crafted item.
                    :type accept_key: str
                    """
                    logger.info("Crafting item")
                    pag.click()
                    sleep(craft_delay)
                    self.result.material += 1
                    while True:
                        if self.detection.is_operation_success():
                            logger.info("Crafting successed")
                            self.result.succes += 1
                            break
            
                        if self.detection.is_operation_failed():
                            logger.warning("Crafting failed")
                            self.result.fail += 1
                            break
                        sleep(LOOP_DELAY)
                    pag.press(accept_key)
                    sleep(accept_delay)
            
                def _start(self) -> None:
                    """Main loop for crafting items.
            
                    Executes the primary loop for crafting items until materials are exhausted or
                    the crafting limit is reached. Supports fast crafting mode and discarding items.
                    """
                    logger.warning("This might get you banned, use at your own risk")
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
                    random.seed(datetime.now().timestamp())
                    accept_key = "backspace" if self.cfg.ARGS.DISCARD else "space"
                    self.move_cursor_to_make_button()
                    while True:
                        if not self.detection.is_material_complete():
                            logger.critical("Running out of materials")
                            return
                        if self.result.succes == self.cfg.ARGS.CRAFT_LIMIT:
                            logger.info("Crafting limit reached")
                            return
                        self.craft_item(*self.get_action_delays(), accept_key)
            
            
            def run_app_from_main():
                try:
                    CraftApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    CraftApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ diagnostics.py
            """
            –î–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∏–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫ –∑–∞–ø—É—Å–∫—É
            """
            
            import sys
            import os
            sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            
            from rf4s.config.config import ConfigManager
            from rf4s.config.env_config import EnvironmentConfig
            
            
            def run_diagnostics():
                """–ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ —Å–∏—Å—Ç–µ–º—ã."""
                print("üîç –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê Russian Fishing 4 Bot")
                print("=" * 50)
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
                print("\n1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è:")
                env_config = EnvironmentConfig()
                env_validation = env_config.validate_environment()
                
                if env_validation['env_file_exists']:
                    print("   ‚úÖ .env —Ñ–∞–π–ª –Ω–∞–π–¥–µ–Ω")
                else:
                    print("   ‚ùå .env —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")
                
                if env_validation['discord_configured']:
                    print("   ‚úÖ Discord webhook –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
                else:
                    print("   ‚ö†Ô∏è  Discord webhook –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
                
                if env_validation['email_configured']:
                    print("   ‚úÖ Email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
                else:
                    print("   ‚ö†Ô∏è  Email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                print("\n2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:")
                try:
                    config_manager = ConfigManager()
                    
                    # –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å config.yaml
                    config_path = "config.yaml"
                    if os.path.exists(config_path):
                        config_manager.load_config(config_path)
                        print("   ‚úÖ config.yaml –∑–∞–≥—Ä—É–∂–µ–Ω")
                    else:
                        print("   ‚ö†Ô∏è  config.yaml –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–µ—Ñ–æ–ª—Ç–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è")
                    
                    # –í–∞–ª–∏–¥–∞—Ü–∏—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫
                    startup_errors = config_manager.validate_startup()
                    
                    if not startup_errors:
                        print("   ‚úÖ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ –ø–æ—Ä—è–¥–∫–µ")
                    else:
                        print("   ‚ùå –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏:")
                        for error in startup_errors:
                            print(f"      - {error}")
                    
                    # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ—Ñ–∏–ª—è—Ö
                    profiles = config_manager.get_profile_list()
                    print(f"   üìã –î–æ—Å—Ç—É–ø–Ω–æ –ø—Ä–æ—Ñ–∏–ª–µ–π: {len(profiles)}")
                    for profile in profiles:
                        print(f"      - {profile}")
                    
                except Exception as e:
                    print(f"   ‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
                    return False
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
                print("\n3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:")
                required_modules = ['PyQt6', 'yaml', 'dotenv', 'PIL', 'cv2', 'numpy', 'requests']
                
                for module in required_modules:
                    try:
                        if module == 'PyQt6':
                            import PyQt6
                        elif module == 'yaml':
                            import yaml
                        elif module == 'dotenv':
                            import dotenv
                        elif module == 'PIL':
                            import PIL
                        elif module == 'cv2':
                            import cv2
                        elif module == 'numpy':
                            import numpy
                        elif module == 'requests':
                            import requests
                        
                        print(f"   ‚úÖ {module}")
                    except ImportError:
                        print(f"   ‚ùå {module} - –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                
                # –ò—Ç–æ–≥–æ–≤–æ–µ –∑–∞–∫–ª—é—á–µ–Ω–∏–µ
                print("\n" + "=" * 50)
                
                if startup_errors:
                    print("‚ùå –°–ò–°–¢–ï–ú–ê –ù–ï –ì–û–¢–û–í–ê –ö –ó–ê–ü–£–°–ö–£")
                    print("\n–ò—Å–ø—Ä–∞–≤—å—Ç–µ —Å–ª–µ–¥—É—é—â–∏–µ –ø—Ä–æ–±–ª–µ–º—ã:")
                    for error in startup_errors:
                        print(f"  - {error}")
                    
                    print("\n–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:")
                    if not env_validation['env_file_exists']:
                        print("  - –°–æ–∑–¥–∞–π—Ç–µ .env —Ñ–∞–π–ª –Ω–∞ –æ—Å–Ω–æ–≤–µ .env.example")
                    if not env_validation['discord_configured'] and not env_validation['email_configured']:
                        print("  - –ù–∞—Å—Ç—Ä–æ–π—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ .env —Ñ–∞–π–ª–µ")
                    
                    return False
                else:
                    print("‚úÖ –°–ò–°–¢–ï–ú–ê –ì–û–¢–û–í–ê –ö –ó–ê–ü–£–°–ö–£")
                    return True
            
            
            if __name__ == "__main__":
                success = run_diagnostics()
                sys.exit(0 if success else 1)
        üìÑ harvest.py
            """Script for automatic baits harvesting and hunger/comfort refill.
            
            This module provides functionality to automate the harvesting of baits and refilling
            of hunger and comfort in Russian Fishing 4. It includes options for power-saving
            mode and configurable check delays.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from pathlib import Path
            from time import sleep
            
            import pyautogui as pag
            from pynput import keyboard
            
            sys.path.append(".")
            
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.controller.timer import Timer
            from rf4s.result.result import HarvestResult
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            ROOT = Path(__file__).resolve().parents[1]
            DIG_DELAY = 5  # 4 + 1 s
            CHECK_DELAY = 0.5
            ANIMATION_DELAY = 0.5
            
            logger = create_rich_logger()
            
            
            class HarvestApp(ToolApp):
                """Main application class for automating bait harvesting and hunger/comfort refill.
            
                This class manages the configuration, detection, and execution of the harvesting
                and refill processes. It also handles power-saving mode and check delays.
            
                Attributes:
                    timer (Timer): Timer instance for managing cooldowns.
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    Loads configuration, parses command-line arguments, and sets up the game window,
                    detection, and timer instances.
                    """
                    super().__init__()
                    print_cfg(self.cfg.ARGS)
            
                    self.timer = Timer(self.cfg)
                    self.result = HarvestResult()
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(
                        description="Harvest baits and refill hunger/comfort automatically.",
                    )
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-r",
                        "--refill",
                        action="store_true",
                        help="refill hunger and comfort by consuming tea and carrot",
                    )
                    parser.add_argument(
                        "-s",
                        "--power-saving",
                        action="store_true",
                        help="open control panel between checks to reduce power consumption",
                    )
                    parser.add_argument(
                        "-n",
                        "--check-delay",
                        type=int,
                        default=32,
                        help="delay time between each checks, 32s by default",
                    )
                    return parser
            
                def harvest_baits(self) -> None:
                    """Harvest baits using shovel/spoon.
            
                    The digging tool should be pulled out before calling this method. Waits for
                    harvest success and presses the spacebar to complete the process.
                    """
                    logger.info("Harvesting baits")
                    pag.click()
                    sleep(DIG_DELAY)
                    while not self.detection.is_harvest_success():
                        sleep(CHECK_DELAY)
                    pag.press("space")
                    logger.info("Baits harvested succussfully")
                    sleep(ANIMATION_DELAY)
            
                def refill_player_stats(self) -> None:
                    """Refill player stats using tea and carrot."""
                    if not self.cfg.ARGS.REFILL:
                        return
            
                    logger.info("Refilling player stats")
                    # Comfort is affected by weather, add a check to avoid over drink
                    if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
                        self._use_item("tea")
                        self.result.tea += 1
            
                    if self.detection.is_hunger_low():
                        self._use_item("carrot")
                        self.result.carrot += 1
            
                def _use_item(self, item: str) -> None:
                    """Access an item by name using quick selection shortcut or menu.
            
                    :param item: The name of the item to access.
                    :type item: str
                    """
                    logger.info("Using item: %s", item)
                    key = str(self.cfg.KEY[item.upper()])
                    if key != "-1":  # Use shortcut
                        pag.press(key)
                    else:  # Open food menu
                        with pag.hold("t"):
                            sleep(ANIMATION_DELAY)
                            food_position = self.detection.get_food_position(item)
                            pag.moveTo(food_position)
                            pag.click()
                    sleep(ANIMATION_DELAY)
            
                def _start(self) -> None:
                    """Main loop for eating and harvesting.
            
                    Executes the primary loop for checking hunger/comfort levels, consuming food,
                    and harvesting baits. Supports power-saving mode and configurable check delays.
                    """
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
            
                    pag.press(str(self.cfg.KEY.DIGGING_TOOL))
                    sleep(3)
                    while True:
                        self.refill_player_stats()
                        if self.detection.is_energy_high():
                            self.harvest_baits()
                            self.result.bait += 1
                        else:
                            logger.info("Energy is not high enough")
            
                        if self.cfg.ARGS.POWER_SAVING:
                            pag.press("esc")
                            sleep(self.cfg.ARGS.CHECK_DELAY)
                            pag.press("esc")
                        else:
                            sleep(self.cfg.ARGS.CHECK_DELAY)
                        sleep(ANIMATION_DELAY)
            
            
            def run_app_from_main():
                try:
                    HarvestApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    HarvestApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ main.py
            """Main CLI for Russian Fishing 4 Script.
            
            This module provides the command-line interface and main execution logic
            for automating fishing in Russian Fishing 4. It handles configuration,
            argument parsing, window management, and fishing automation.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import shlex
            import smtplib
            import sys
            from argparse import ArgumentParser, Namespace
            from pathlib import Path
            from socket import gaierror
            
            from pynput import keyboard
            from rich import box, print
            from rich.panel import Panel
            from rich.style import Style
            from rich.table import Column, Table
            from yacs.config import CfgNode as CN
            
            sys.path.append(".")  # python -m module -> python file
            import auto_friction_brake
            import calculate
            import craft
            import harvest
            import move
            
            from rf4s import utils
            from rf4s.app.app import App
            from rf4s.config import config
            from rf4s.player import Player
            from rf4s.utils import create_rich_logger
            
            logger = create_rich_logger()
            
            ARGUMENTS = (
                ("R", "rainbow", "rainbow line meter for retrieval detection"),
                ("t", "tag", "keep only tagged fishes"),
                ("c", "coffee", "drink coffee if stamina is low during a fish fight"),
                ("a", "alcohol", "drink alcohol before keeping the fish"),
                ("r", "refill", "consume tea and carrot if hunger or comfort is low"),
                ("H", "harvest", "harvest baits before casting the rod"),
                ("L", "lure", "change current lure with a random one, mode: spin"),
                ("m", "mouse", "move mouse randomly before casting the rod"),
                ("P", "pause", "pause the script before casting the rod occasionally"),
                ("RC", "random-cast", "do a redundant rod cast randomly"),
                ("SC", "skip-cast", "skip the first rod cast"),
                ("l", "lift", "lift the tackle constantly during a fish fight"),
                ("e", "electro", "enable electric mode for Electro Raptor series reel"),
                ("FB", "friction-brake", "adjust friction brake automatically"),
                ("GR", "gear-ratio", "switch the gear ratio after the retrieval timed out"),
                ("b", "bite", "save a screenshot in screenshots/ before rod cast (for bite spot)"),
                ("s", "screenshot", "save a screenshot in screenshots/ after you caught a fish"),
                ("d", "data", "save fishing data in /logs"),
                ("E", "email", "send email noticication after the script stop"),
                ("M", "miaotixing", "send miaotixing notification after the script stop"),
                ("D", "discord", "send Discord notification after the script stop"),
                ("S", "shutdown", "shutdown computer after the script stop"),
                ("SO", "signout", "sign out instead of closing the game"),
                ("SR", "spod-rod", "recast spod rod"),
                ("DM", "dry-mix", "enable dry mix refill, mode: bottom"),
                ("GB", "groundbait", "enable groundbait refill, mode: bottom"),
                ("PVA", "pva", "enable pva refill, mode: bottom"),
            )
            
            LOGO = """
            ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
            ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
            ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë          ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
            ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù          ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"""
            GITHUB_LINK = "GitHub: https://github.com/dereklee0310/RussianFishing4Script"
            DISCORD_LINK = "Discord: https://discord.gg/BZQWQnAMbY"
            # https://patorjk.com/software/taag/#p=testall&f=3D-ASCII&t=RF4S%0A, ANSI Shadow
            
            ROOT = Path(__file__).resolve().parents[1]
            
            FEATURES = (
                "Fishing Bot",
                "Craft Items",
                "Harvest Baits",
                "Toggle Moving Forward",
                "Automate Friction Brake",
                "Calculate tackle's stats",
            )
            
            
            class RF4SApp(App):
                """Main application class for Russian Fishing 4 automation.
            
                This class orchestrates the entire automation process, from parsing command-line
                arguments to configuring the environment and executing the fishing routine.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments
                    args (Namespace): Parsed command-line arguments
                    window (Window): Game window controller instance
                    player (Player): Player instance for fishing automation
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    Loads configuration, parses command-line arguments, and sets up the environment.
                    """
                    super().__init__()
                    self.parser = self.create_parser()
                    # Parser will use the last occurence if the arguments are duplicated,
                    # so put argv at the end to overwrite launch options.
                    self.args = self.parser.parse_args(
                        shlex.split(self.cfg.SCRIPT.LAUNCH_OPTIONS) + sys.argv[1:]
                    )
                    if not self.is_args_valid(self.args):
                        utils.safe_exit()
                    self.cfg.merge_from_other_cfg(CN({"ARGS": config.dict_to_cfg(vars(self.args))}))
            
                def create_parser(self) -> ArgumentParser:
                    """Configure the argument parser with all supported command-line options.
            
                    :return: Configured ArgumentParser instance with all options and flags.
                    :rtype: ArgumentParser
                    """
                    parser = ArgumentParser(description="Start AFK script for Russian Fishing 4")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
            
                    for argument in ARGUMENTS:
                        flag1 = f"-{argument[0]}"
                        flag2 = f"--{argument[1]}"
                        help_message = argument[2]
                        parser.add_argument(flag1, flag2, action="store_true", help=help_message)
            
                    profile_selection_strategy = parser.add_mutually_exclusive_group()
                    profile_selection_strategy.add_argument(
                        "-p",
                        "--pid",
                        type=int,
                        help="id of the profile you want to use",
                        metavar="PID",
                    )
                    profile_selection_strategy.add_argument(
                        "-N",
                        "--pname",
                        type=str,
                        help="name of the profile you want to use",
                        metavar="PROFILE_NAME",
                    )
                    parser.add_argument(
                        "-n",
                        "--fishes-in-keepnet",
                        default=0,
                        type=int,
                        help="number of fishes in your keepnet, 0 by default",
                        metavar="FISH_COUNT",
                    )
                    parser.add_argument(
                        "-BT",
                        "--boat-ticket",
                        nargs="?",
                        const=5,
                        type=int,
                        choices=[1, 2, 3, 5],
                        help=("renew boat ticket, DURATION: 1, 2, 3 or 5, 5 by default"),
                        metavar="DURATION",
                    )
                    parser.add_argument(
                        "-T",
                        "--trolling",
                        nargs="?",
                        const="forward",
                        type=str,
                        choices=["forward", "left", "right"],
                        help=(
                            "enable trolling mode, DIRECTION: 'forward', 'left', or 'right', "
                            "'forward' by default"
                        ),
                        metavar="DIRECTION",
                    )
                    parser.add_argument(
                        "-BL",
                        "--broken-lure",
                        nargs="?",
                        const="replace",
                        type=str,
                        choices=["replace", "alarm"],
                        help=(
                            "replace broken lure, ACTION: 'replace' or 'alarm', "
                            "'replace' by default"
                        ),
                        metavar="ACTION",
                    )
                    return parser
            
                def is_args_valid(self, args: Namespace) -> bool:
                    """Validate provided command-line arguments.
            
                    :param args: Parsed command-line arguments to validate.
                    :type args: Namespace
                    :return: Whether the arguments are valid.
                    :rtype: bool
                    """
                    if not 0 <= args.fishes_in_keepnet < self.cfg.KEEPNET.CAPACITY:
                        logger.critical(
                            "Invalid number of fishes in keepnet: '%s'", args.fishes_in_keepnet
                        )
                        return False
            
                    if args.pid is not None and not self.is_pid_valid(str(args.pid)):
                        logger.critical("Invalid profile id: '%s'", args.pid)
                        return False
            
                    if args.pname is not None and args.pname not in self.cfg.PROFILE:
                        logger.critical("Invalid profile name: '%s'", args.pname)
                        return False
            
                    # boat_ticket_duration already checked by choices[...]
                    return True
            
                def is_pid_valid(self, pid: str) -> bool:
                    """Check if the profile ID is valid.
            
                    :param pid: Profile ID to validate.
                    :type pid: str
                    :return: Whether the profile ID is valid.
                    :rtype: bool
                    """
                    return pid.isdigit() and 0 <= int(pid) < len(self.cfg.PROFILE)
            
                def is_smtp_valid(self) -> bool:
                    """Verify SMTP server connection for email notifications.
            
                    Tests the connection to the configured SMTP server using stored
                    credentials if email notifications are enabled.
            
                    :return: Whether the SMTP configuration is valid or not needed.
                    :rtype: bool
                    """
                    if not self.cfg.ARGS.EMAIL or not self.cfg.SCRIPT.SMTP_VERIFICATION:
                        return True
            
                    logger.info("Verifying SMTP connection")
            
                    email = self.cfg.NOTIFICATION.EMAIL
                    password = self.cfg.NOTIFICATION.PASSWORD
                    smtp_server_name = self.cfg.NOTIFICATION.SMTP_SERVER
            
                    try:
                        with smtplib.SMTP_SSL(smtp_server_name, 465) as smtp_server:
                            smtp_server.login(email, password)
                    except smtplib.SMTPAuthenticationError:
                        logger.critical(
                            "Email address or app password not accepted,\n"
                            "please check your email address and password.\n"
                            "For Gmail users, please refer to\n"
                            "https://support.google.com/accounts/answer/185833\n"
                        )
                        return False
                    except (TimeoutError, gaierror):
                        logger.critical("Invalid SMTP Server or connection timed out")
                        return False
                    return True
            
                def is_discord_webhook_url_valid(self) -> bool:
                    if not self.cfg.ARGS.DISCORD:
                        return True
                    if not self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL:
                        logger.critical(
                            "Discord Webhook url is not set, see\n"
                            "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks"
                        )
                        return False
                    return True
            
                def is_images_valid(self) -> bool:
                    """Verify that all required image files exist for the selected language.
            
                    Compares files in the reference 'en' directory with those in the current
                    language directory and reports any missing files.
            
                    :return: Whether all required image files are present.
                    :rtype: bool
                    """
                    if not self.cfg.SCRIPT.IMAGE_VERIFICATION:
                        return True
            
                    logger.info("Verifying image files")
                    if self.cfg.SCRIPT.LANGUAGE == "en":
                        return True
                    logger.warning(
                        "Language '%s' is not fully supported, consider using EN version",
                        self.cfg.SCRIPT.LANGUAGE,
                    )
                    image_dir = ROOT / "static" / self.cfg.SCRIPT.LANGUAGE
                    try:
                        current_images = [f.name for f in image_dir.iterdir() if f.is_file()]
                    except FileNotFoundError:
                        logger.critical("Invalid language: '%s'", self.cfg.SCRIPT.LANGUAGE)
                        return False
                    template_dir = ROOT / "static" / "en"
                    target_images = [f.name for f in template_dir.iterdir() if f.is_file()]
                    missing_images = set(target_images) - set(current_images)
                    if len(missing_images) > 0:
                        logger.critical("Some images are missing, please add them manually")
                        table = Table(
                            # "Filename",
                            Column("Filename", style=Style(color="red")),
                            title="Missing Images",
                            box=box.DOUBLE,
                            show_header=False,
                        )
                        for filename in missing_images:
                            table.add_row(f"static/{self.cfg.SCRIPT.LANGUAGE}/{filename}")
                        print(table)
                        return False
                    return True
            
                def is_profile_valid(self, profile_name: str) -> bool:
                    """Check if a profile configuration is valid and complete.
            
                    :param profile_name: Name of the profile to validate.
                    :type profile_name: str
                    :return: Whether the profile is valid.
                    :rtype: bool
                    """
                    if profile_name not in self.cfg.PROFILE:
                        logger.critical("Invalid profile name: '%s'", profile_name)
                        return False
            
                    mode = self.cfg.PROFILE[profile_name].MODE
                    if mode.upper() not in self.cfg.PROFILE:
                        logger.critical("Invalid mode: '%s'", mode)
                        return False
            
                    expected_keys = set(self.cfg.PROFILE[mode.upper()])
                    actual_keys = set(self.cfg.PROFILE[profile_name])
            
                    invalid_keys = actual_keys - expected_keys
                    missing_keys = expected_keys - actual_keys
            
                    if invalid_keys or missing_keys:
                        for key in invalid_keys:
                            logger.warning("Invalid setting: '%s'", key)
                        for key in missing_keys:
                            logger.warning("Missing setting: '%s'", key)
                    return True
            
                def display_profiles(self) -> None:
                    """Display a table of available profiles for user selection.
            
                    Shows a formatted table with profile IDs and names.
                    """
                    table = Table(
                        "Profiles",
                        title="Select a profile to start ‚öôÔ∏è",
                        show_header=False,
                        min_width=36,
                    )
                    for i, profile in enumerate(self.cfg.PROFILE):
                        table.add_row(f"{i:>2}. {profile}")
                    print(table)
            
                def get_pid(self) -> None:
                    """Prompt the user to enter a profile ID and validate the input.
            
                    Continuously prompts until a valid profile ID is entered or the
                    user chooses to quit.
                    """
                    print("Enter profile id to use, h to see help message, q to quit:")
            
                    while True:
                        user_input = input(">>> ")
                        if self.is_pid_valid(user_input):
                            break
                        if user_input == "q":
                            print("Bye.")
                            sys.exit()
                        if user_input == "h":
                            self.parser.print_help()
                            continue
                        utils.print_error("Invalid profile id, please try again.")
            
                    self.cfg.ARGS.PID = int(user_input)
            
                def create_user_profile(self) -> None:
                    """Configure the user profile based on arguments or interactive selection.
            
                    Selects a profile based on command-line arguments or user input,
                    validates the profile, and merges it with the configuration.
                    """
                    if self.cfg.ARGS.PNAME is not None:
                        profile_name = self.cfg.ARGS.PNAME
                    else:
                        if self.cfg.ARGS.PID is None:
                            self.display_profiles()
                            self.get_pid()
                        profile_name = list(self.cfg.PROFILE)[self.cfg.ARGS.PID]
            
                    if not self.is_profile_valid(profile_name):
                        utils.safe_exit()
            
                    # Merge args.opts here because we can only overwrite cfg.SELECTED
                    # after it's constructed using profile id or name.
                    # Process list-like values if possible
                    if "KEY.BOTTOM_RODS" in self.args.opts:
                        value_idx = self.args.opts.index("KEY.BOTTOM_RODS") + 1
                        self.args.opts[value_idx] = [
                            x.strip() for x in self.args.opts[value_idx].split(",")
                        ]
                    self.cfg.merge_from_list(self.args.opts)
            
                    mode = self.cfg.PROFILE[profile_name].MODE.upper()
                    self.cfg.SELECTED = CN({"NAME": profile_name}, new_allowed=True)
                    self.cfg.SELECTED.merge_from_other_cfg(self.cfg.PROFILE[mode])
                    self.cfg.SELECTED.merge_from_other_cfg(self.cfg.PROFILE[profile_name])
            
                    if (
                        hasattr(self.cfg.SELECTED, "LAUNCH_OPTIONS")
                        and self.cfg.SELECTED.LAUNCH_OPTIONS
                    ):  # Overwrite
                        args_list = shlex.split(self.cfg.SELECTED.LAUNCH_OPTIONS) + sys.argv[1:]
                        self.args = self.parser.parse_args(args_list)
                        self.cfg.ARGS = config.dict_to_cfg(vars(self.args))
            
                    # Check here because config might got overwritten
                    if (
                        not self.is_smtp_valid()
                        or not self.is_images_valid()
                        or not self.is_discord_webhook_url_valid()
                    ):
                        utils.safe_exit()
                    config.print_cfg(self.cfg.ARGS)
                    config.print_cfg(self.cfg.SELECTED)
            
                def is_window_valid(self) -> None:
                    """Set up and validate the game window.
            
                    Creates a Window object, checks if the window size is supported,
                    and disables incompatible features if needed.
                    """
                    if self.window.is_title_bar_exist():
                        logger.info("Window mode detected. Please don't move the game window")
                    if not self.window.is_size_supported():
                        logger.warning('Window mode must be "Borderless windowed" or "Window mode"')
                        logger.warning(
                            "Unsupported window size '%s', "
                            "use '2560x1440', '1920x1080' or '1600x900'",
                            self.window.get_resolution_str(),
                        )
                        logger.error(
                            "Snag detection will be disabled\n"
                            "Spooling detection will be disabled\n"
                            "Auto friction brake will be disabled\n"
                        )
            
                        self.cfg.ARGS.FRICTION_BRAKE = False
                        self.cfg.SCRIPT.SNAG_DETECTION = False
                        self.cfg.SCRIPT.SPOOLING_DETECTION = False
            
                    if (
                        self.cfg.SELECTED.MODE in ("telescopic", "bolognese")
                        and not self.window.is_size_supported()
                    ):
                        logger.critical(
                            "Fishing mode '%s' doesn't support window size '%s'",
                            self.cfg.SELECTED.MODE,
                            self.window.get_resolution_str(),
                        )
                        return False
                    return True
            
                def is_electro_valid(self):
                    """Display helpful information about the current configuration.
            
                    Checks configuration compatibility and prints warnings for
                    potential issues.
                    """
                    if not self.cfg.ARGS.ELECTRO:
                        return True
            
                    if self.cfg.SELECTED.MODE in ("pirk", "elevator"):
                        logger.info(
                            "Electric mode is enabled, make sure you're using Electro Raptor"
                        )
                    else:
                        logger.error(
                            "Electric mode is not compatible with mode '%s'"
                            "Electric mode will be disabled",
                            self.cfg.SELECTED.MODE,
                        )
                        self.cfg.ARGS.ELECTRO = False
                    return True
            
                def _start(self) -> None:
                    """Entry point."""
                    self.player = Player(self.cfg, self.window)
                    self.player.start_fishing()
            
                def start(self) -> None:
                    """Start the fishing automation process.
            
                    Sets up all required components, activates the game window,
                    registers key listeners, and begins the fishing automation.
                    Handles termination and displays result.
                    """
                    self.create_user_profile()
                    if not self.is_window_valid() or not self.is_electro_valid():
                        utils.safe_exit()
                    self.cfg.freeze()
            
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
                    self.window.activate_game_window()
                    try:
                        self._start()
                    except KeyboardInterrupt:
                        pass
            
                    self.display_result()
                    if self.cfg.ARGS.DATA:
                        self.player.timer.plot_and_save()
            
                def display_result(self):
                    print(
                        self.player.build_result_table(
                            self.player.build_result_dict("Terminated by user")
                        )
                    )
            
            
            def display_features() -> None:
                """Display a table of available features for user selection.
            
                Shows a formatted table with feature IDs and names.
                """
                table = Table(
                    "Features",
                    title="Select a feature to start üöÄ",
                    show_header=False,
                    min_width=36,
                )
            
                for i, feature in enumerate(FEATURES):
                    table.add_row(f"{i:>2}. {feature}")
                print(table)
            
            
            def get_pid() -> None:
                """Prompt the user to enter a profile ID and validate the input.
            
                Continuously prompts until a valid profile ID is entered or the
                user chooses to quit.
                """
                # print("Enter profile id to use, h to see help message, q to quit:")
                print("Enter feature id to use, q to quit:")
            
                while True:
                    user_input = input(">>> ")
                    if user_input.isdigit() and 0 <= int(user_input) < len(FEATURES):
                        break
                    if user_input == "q":
                        print("Bye.")
                        sys.exit()
                    utils.print_error("Invalid feature id, please try again.")
            
                return int(user_input)
            
            
            if __name__ == "__main__":
                print(Panel.fit(LOGO, box=box.HEAVY), GITHUB_LINK, DISCORD_LINK, sep="\n")
                utils.update_argv()
                display_features()
                match get_pid():
                    case 0:
                        try:
                            RF4SApp().start()
                        except Exception as e:
                            logger.critical(e, exc_info=True)
                        utils.safe_exit()
                    case 1:
                        craft.run_app_from_main()
                    case 2:
                        harvest.run_app_from_main()
                    case 3:
                        move.run_app_from_main()
                    case 4:
                        auto_friction_brake.run_app_from_main()
                    case 5:
                        calculate.run_app_from_main()
        üìÑ move.py
            """Movement automation for Russian Fishing 4 using keyboard controls.
            
            This module automates character movement in Russian Fishing 4 by simulating W key presses.
            Supports toggling movement state and includes optional Shift key integration for sprinting.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from pathlib import Path
            
            import pyautogui as pag
            from pynput import keyboard
            from rich import print
            
            sys.path.append(".")
            from rf4s import utils
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            ROOT = Path(__file__).resolve().parents[1]
            
            logger = create_rich_logger()
            
            
            class MoveApp(ToolApp):
                """Main controller for movement automation in Russian Fishing 4.
            
                Manages configuration, keyboard event listeners, and W/Shift key simulation.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
                    w_key_pressed (bool): Tracks current state of W key simulation.
                """
            
                def __init__(self):
                    """Initialize configuration, CLI arguments, and game window.
            
                    1. Format keybinds in cfg node.
                    2. Create w key flag.
                    """
                    super().__init__()
            
                    # Format key
                    self.cfg.defrost()
                    self.cfg.ARGS.PAUSE_KEY = f"'{self.cfg.ARGS.PAUSE_KEY}'"
                    self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
                    self.cfg.freeze()
                    print_cfg(self.cfg.ARGS)
            
                    self.w_key_pressed = True
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(
                        description="Moving the game character forward with W key."
                    )
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-s", "--shift", action="store_true", help="Hold Shift key while moving"
                    )
                    parser.add_argument(
                        "-p",
                        "--pause-key",
                        default="w",
                        type=str,
                        help="key to pause the script, w by default",
                        metavar="KEY",
                    )
                    parser.add_argument(
                        "-q",
                        "--quit-key",
                        default="s",
                        type=str,
                        help="key to quit the script, s by default",
                        metavar="KEY",
                    )
                    return parser
            
                def _on_release(self, key: keyboard.KeyCode) -> None:
                    """Handle keyboard release events for script control.
            
                    :param key: Key released by the user.
                    :type key: keyboard.KeyCode
                    """
                    if str(key).lower() == self.cfg.ARGS.QUIT_KEY:
                        sys.exit()
                    elif str(key).lower() == self.cfg.ARGS.PAUSE_KEY:
                        if self.w_key_pressed:
                            self.w_key_pressed = False
                            return
                        pag.keyDown("w")
                        self.w_key_pressed = True
            
                @utils.release_keys_after(arrow_keys=True)
                def _start(self) -> None:
                    """Start W key automation and keyboard listener."""
                    print(
                        f"Press {self.cfg.ARGS.PAUSE_KEY[1:-1]} to pause, "
                        f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
                    )
                    if self.cfg.ARGS.SHIFT:
                        pag.keyDown("shift")
                    pag.keyDown("w")
                    # Blocking listener loop
                    with keyboard.Listener(on_release=self._on_release) as listener:
                        listener.join()
            
            
            def run_app_from_main():
                try:
                    MoveApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    MoveApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ quick_fix.py
            """
            –ë—ã—Å—Ç—Ä–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            """
            
            import sys
            import os
            sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            
            from rf4s.config.config import ConfigManager
            
            
            def quick_fix_config():
                """–ë—ã—Å—Ç—Ä–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏."""
                print("üõ†Ô∏è  –ë–´–°–¢–†–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò")
                print("=" * 40)
                
                config_manager = ConfigManager()
                config_path = "config.yaml"
                
                try:
                    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é
                    if os.path.exists(config_path):
                        config_manager.load_config(config_path)
                        print("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è")
                    else:
                        print("‚ö†Ô∏è  config.yaml –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤—ã–π")
                    
                    # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã
                    fixed_issues = []
                    
                    # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º MAIN_ROD
                    keys = config_manager.config.get('KEY', {})
                    if keys.get('MAIN_ROD', -1) == -1:
                        keys['MAIN_ROD'] = 1
                        fixed_issues.append("MAIN_ROD —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ 1")
                    
                    # –û—á–∏—â–∞–µ–º —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ config.yaml
                    notification = config_manager.config.get('NOTIFICATION', {})
                    if notification.get('DISCORD_WEBHOOK_URL'):
                        notification['DISCORD_WEBHOOK_URL'] = ''
                        fixed_issues.append("Discord webhook URL –æ—á–∏—â–µ–Ω –∏–∑ config.yaml")
                    
                    if notification.get('EMAIL'):
                        notification['EMAIL'] = ''
                        notification['PASSWORD'] = ''
                        fixed_issues.append("Email –¥–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã –∏–∑ config.yaml")
                    
                    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è FRICTION_BRAKE
                    friction = config_manager.config.get('FRICTION_BRAKE', {})
                    if friction.get('INITIAL', 15) >= friction.get('MAX', 26):
                        friction['INITIAL'] = 29
                        friction['MAX'] = 30
                        fixed_issues.append("–ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ FRICTION_BRAKE")
                    
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
                    config_manager.save_config(config_path)
                    
                    print(f"\n‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∞! –ò–∑–º–µ–Ω–µ–Ω–∏—è:")
                    for issue in fixed_issues:
                        print(f"  - {issue}")
                    
                    # –°–æ–∑–¥–∞–µ–º .env.example –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
                    env_example_path = ".env.example"
                    if not os.path.exists(env_example_path):
                        with open(env_example_path, 'w', encoding='utf-8') as f:
                            f.write("""# Discord webhook URL –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
            DISCORD_WEBHOOK_URL=your_webhook_url_here
            
            # Email –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            EMAIL=your_email@example.com
            EMAIL_PASSWORD=your_app_password
            SMTP_SERVER=smtp.gmail.com
            
            # Miao Code –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            MIAO_CODE=your_miao_code_here
            """)
                        print("  - –°–æ–∑–¥–∞–Ω .env.example")
                    
                    print(f"\nüìã –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏:")
                    print("  1. –°–æ–∑–¥–∞–π—Ç–µ .env —Ñ–∞–π–ª –Ω–∞ –æ—Å–Ω–æ–≤–µ .env.example")
                    print("  2. –î–æ–±–∞–≤—å—Ç–µ –≤–∞—à Discord webhook URL –≤ .env")
                    print("  3. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∫–ª–∞–≤–∏—à–∏ –≤ GUI –∏–ª–∏ config.yaml –ø–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏")
                    print("  4. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É: python tools/diagnostics.py")
                    
                    return True
                    
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–∏: {e}")
                    return False
            
            
            if __name__ == "__main__":
                success = quick_fix_config()
                sys.exit(0 if success else 1)
        üìÑ __init__.py
            """Tools module"""
            __version__ = "0.5.2"
        üìÅ __pycache__/
            üìÑ auto_friction_brake.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ calculate.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ craft.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ harvest.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ move.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
    üìÅ __pycache__/
        üìÑ config_manager.cpython-312.pyc
            [ERROR: Unable to decode as UTF-8 or read file]
        üìÑ main_window.cpython-312.pyc
            [ERROR: Unable to decode as UTF-8 or read file]
        üìÑ script_runner.cpython-312.pyc
            [ERROR: Unable to decode as UTF-8 or read file]
        üìÑ translations.cpython-312.pyc
            [ERROR: Unable to decode as UTF-8 or read file]
        üìÑ ui_theme.cpython-312.pyc
            [ERROR: Unable to decode as UTF-8 or read file]