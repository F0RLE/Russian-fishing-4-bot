üìÅ ./
    üìÑ config.yaml
        VERSION: "0.5.2"
        
        # ---------------------------------------------------------------------------- #
        #                                    General                                   #
        # ---------------------------------------------------------------------------- #
        SCRIPT:
          LANGUAGE: "ru"
          LAUNCH_OPTIONS: "-FB -t -l -r"
          SMTP_VERIFICATION: true
          IMAGE_VERIFICATION: true
          SNAG_DETECTION: true  
          SPOOLING_DETECTION: true
          RANDOM_ROD_SELECTION: false
          SPOOL_CONFIDENCE: 0.98
          SPOD_ROD_RECAST_DELAY: 1800
          LURE_CHANGE_DELAY: 1800
          ALARM_SOUND: "./static/sound/guitar.wav"
          RANDOM_CAST_PROBABILITY: 0.25
          SCREENSHOT_TAGS:
            - "green"
            - "yellow"
            - "blue"
            - "purple"
            - "pink"
        
        # ---------------------------------------------------------------------------- #
        #                                  Key Binding                                 #
        # ---------------------------------------------------------------------------- #
        KEY:
          TEA: 5
          CARROT: 4
          BOTTOM_RODS: [1, 2, 3]
          COFFEE: -1
          DIGGING_TOOL: 5
          ALCOHOL: 6
          MAIN_ROD: 1
          SPOD_ROD: 7
          QUIT: "CTRL-C"
          NET: "SPACE"
        
        # ---------------------------------------------------------------------------- #
        #                                 Player Stats                                 #
        # ---------------------------------------------------------------------------- #
        STAT:
          ENERGY_THRESHOLD: 0.74
          HUNGER_THRESHOLD: 0.5
          COMFORT_THRESHOLD: 0.51
          TEA_DELAY: 300
          COFFEE_LIMIT: 10
          COFFEE_PER_DRINK: 1
          ALCOHOL_DELAY: 900
          ALCOHOL_PER_DRINK: 1
        
        # ---------------------------------------------------------------------------- #
        #                   Friction Brake (Use -FB flag to enable it)                #
        # ---------------------------------------------------------------------------- #
        FRICTION_BRAKE:
          INITIAL: 15
          MAX: 26
          START_DELAY: 0.01
          INCREASE_DELAY: 0.01
          SENSITIVITY: "medium"
        
        # ---------------------------------------------------------------------------- #
        #                                 Fish Fight                                   #
        # ---------------------------------------------------------------------------- #
        FISH_FIGHT:
          RETRIEVAL_INTERVAL: 2.0
          LIFT_ENABLED: true
          AUTO_NET: true
          NET_KEY: "SPACE"
          CONTINUOUS_LIFT: true
          RETRIEVAL_DURING_FIGHT: true
        
        # ---------------------------------------------------------------------------- #
        #                                    Keepnet                                   #
        # ---------------------------------------------------------------------------- #
        KEEPNET:
          CAPACITY: 100
          FISH_DELAY: 0.0
          GIFT_DELAY: 4.0
          FULL_ACTION: "quit"
          WHITELIST:
            - "mackerel"
            - "saithe"
            - "herring"
            - "squid"
            - "scallop"
            - "mussel"
          BLACKLIST: []
          TAGS:
            - "green"
            - "yellow"
            - "blue"
            - "purple"
            - "pink"
        
        # ---------------------------------------------------------------------------- #
        #                                 Notification                                 #
        # ---------------------------------------------------------------------------- #
        NOTIFICATION:
          EMAIL: "email@example.com"
          PASSWORD: "password"
          SMTP_SERVER: "smtp.gmail.com"
          MIAO_CODE: "example"
          DISCORD_WEBHOOK_URL: "https://discord.com/api/webhooks/1381306998586343637/t-6xkZiqrACMLSs_DhzE_p9dPAG-sVhUzN_bXqnf7SukxpRhNxL6jS8QfRKySoeKhgeJ"
        
        # ---------------------------------------------------------------------------- #
        #                       Pause ( use -P flag to enable it)                     #
        # ---------------------------------------------------------------------------- #
        PAUSE:
          DELAY: 1800
          DURATION: 600
        
        # ---------------------------------------------------------------------------- #
        #                                   Profiles                                   #
        # ---------------------------------------------------------------------------- #
        PROFILE:
          # -------------------------------------------------------------------------- #
          #                             Spin Fishing Profile                          #
          # -------------------------------------------------------------------------- #
          SPIN:
            MODE: "spin"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 5.0
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 1.5
            RETRIEVAL_DELAY: 1.5
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: "auto"
            TYPE: "lift"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          SPIN_WITH_PAUSE:
            MODE: "spin"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            TIGHTEN_DURATION: 1.0
            RETRIEVAL_DURATION: 1.3
            RETRIEVAL_DELAY: 1.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: "auto"
            TYPE: "pause"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          SPIN_WITH_LIFT:
            MODE: "spin"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 5.0
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 2.0
            RETRIEVAL_DELAY: 4.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: "auto"
            TYPE: "lift"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                            Bottom Fishing Profile                         #
          # -------------------------------------------------------------------------- #
          BOTTOM:
            MODE: "bottom"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            POST_ACCELERATION: "auto"
            CHECK_DELAY: 32.0
            CHECK_MISS_LIMIT: 16
            PUT_DOWN_DELAY: 0.0
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                      Marine / Wakey Rig Pirking Profile                   #
          # -------------------------------------------------------------------------- #
          PIRK:
            MODE: "pirk"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 4.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: false
            SHIFT: false
            PIRK_DURATION: 0.5
            PIRK_DELAY: 2.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          PIRK_WITH_RETRIEVAL:
            MODE: "pirk"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 0.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: false
            SHIFT: false
            PIRK_DURATION: 0.5
            PIRK_DELAY: 2.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: true
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          WAKEY_RIG:
            MODE: "pirk"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 45.0
            TIGHTEN_DURATION: 1.0
            DEPTH_ADJUST_DELAY: 4.0
            DEPTH_ADJUST_DURATION: 1.0
            CTRL: true
            SHIFT: false
            PIRK_DURATION: 1.5
            PIRK_DELAY: 4.0
            PIRK_TIMEOUT: 32.0
            PIRK_RETRIEVAL: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                            Marine Elevator Profile                        #
          # -------------------------------------------------------------------------- #
          ELEVATOR:
            MODE: "elevator"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            ELEVATE_DURATION: 4.0
            ELEVATE_DELAY: 4.0
            ELEVATE_TIMEOUT: 40.0
            DROP: false
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          ELEVATOR_WITH_DROP:
            MODE: "elevator"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 1.0
            CAST_DELAY: 4.0
            SINK_TIMEOUT: 60.0
            TIGHTEN_DURATION: 1.0
            ELEVATE_DURATION: 4.0
            ELEVATE_DELAY: 4.0
            ELEVATE_TIMEOUT: 40.0
            DROP: true
            HOOK_DELAY: 0.5
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                          Telescopic fishing Profile                       #
          # -------------------------------------------------------------------------- #
          TELESCOPIC:
            MODE: "telescopic"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            FLOAT_SENSITIVITY: 0.68
            CHECK_DELAY: 1.0
            PULL_DELAY: 0.5
            DRIFT_TIMEOUT: 16.0
            CAMERA_SHAPE: "square"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                           Bolognese Fishing Profile                       #
          # -------------------------------------------------------------------------- #
          BOLOGNESE:
            MODE: "bolognese"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            FLOAT_SENSITIVITY: 0.68
            CHECK_DELAY: 1.0
            PULL_DELAY: 0.5
            DRIFT_TIMEOUT: 32.0
            CAMERA_SHAPE: "square"
            POST_ACCELERATION: "auto"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
        
          # -------------------------------------------------------------------------- #
          #                           Custom Auto Fight Profile                       #
          # -------------------------------------------------------------------------- #
          AUTO_FIGHT_SPIN:
            MODE: "spin"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 6.0
            TIGHTEN_DURATION: 0.0
            RETRIEVAL_DURATION: 2.0
            RETRIEVAL_DELAY: 2.0
            RETRIEVAL_TIMEOUT: 256.0
            PRE_ACCELERATION: false
            POST_ACCELERATION: "auto"
            TYPE: "lift"
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
            AUTO_FIGHT_MODE: true
            FIGHT_LIFT_INTERVAL: 2.0
            FIGHT_RETRIEVAL_INTERVAL: 2.0
        
          AUTO_FIGHT_BOTTOM:
            MODE: "bottom"
            LAUNCH_OPTIONS: ""
            CAST_POWER_LEVEL: 5.0
            CAST_DELAY: 4.0
            POST_ACCELERATION: "auto"
            CHECK_DELAY: 32.0
            CHECK_MISS_LIMIT: 16
            PUT_DOWN_DELAY: 0.0
            LIFT_DURING_FIGHT: true
            RETRIEVAL_INTERVAL: 2.0
            CONTINUOUS_RETRIEVAL: true
            AUTO_FIGHT_MODE: true
            FIGHT_LIFT_INTERVAL: 2.0
            FIGHT_RETRIEVAL_INTERVAL: 2.0
    üìÑ LICENSE
                            GNU GENERAL PUBLIC LICENSE
                               Version 3, 29 June 2007
        
         Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
         Everyone is permitted to copy and distribute verbatim copies
         of this license document, but changing it is not allowed.
        
                                    Preamble
        
          The GNU General Public License is a free, copyleft license for
        software and other kinds of works.
        
          The licenses for most software and other practical works are designed
        to take away your freedom to share and change the works.  By contrast,
        the GNU General Public License is intended to guarantee your freedom to
        share and change all versions of a program--to make sure it remains free
        software for all its users.  We, the Free Software Foundation, use the
        GNU General Public License for most of our software; it applies also to
        any other work released this way by its authors.  You can apply it to
        your programs, too.
        
          When we speak of free software, we are referring to freedom, not
        price.  Our General Public Licenses are designed to make sure that you
        have the freedom to distribute copies of free software (and charge for
        them if you wish), that you receive source code or can get it if you
        want it, that you can change the software or use pieces of it in new
        free programs, and that you know you can do these things.
        
          To protect your rights, we need to prevent others from denying you
        these rights or asking you to surrender the rights.  Therefore, you have
        certain responsibilities if you distribute copies of the software, or if
        you modify it: responsibilities to respect the freedom of others.
        
          For example, if you distribute copies of such a program, whether
        gratis or for a fee, you must pass on to the recipients the same
        freedoms that you received.  You must make sure that they, too, receive
        or can get the source code.  And you must show them these terms so they
        know their rights.
        
          Developers that use the GNU GPL protect your rights with two steps:
        (1) assert copyright on the software, and (2) offer you this License
        giving you legal permission to copy, distribute and/or modify it.
        
          For the developers' and authors' protection, the GPL clearly explains
        that there is no warranty for this free software.  For both users' and
        authors' sake, the GPL requires that modified versions be marked as
        changed, so that their problems will not be attributed erroneously to
        authors of previous versions.
        
          Some devices are designed to deny users access to install or run
        modified versions of the software inside them, although the manufacturer
        can do so.  This is fundamentally incompatible with the aim of
        protecting users' freedom to change the software.  The systematic
        pattern of such abuse occurs in the area of products for individuals to
        use, which is precisely where it is most unacceptable.  Therefore, we
        have designed this version of the GPL to prohibit the practice for those
        products.  If such problems arise substantially in other domains, we
        stand ready to extend this provision to those domains in future versions
        of the GPL, as needed to protect the freedom of users.
        
          Finally, every program is threatened constantly by software patents.
        States should not allow patents to restrict development and use of
        software on general-purpose computers, but in those that do, we wish to
        avoid the special danger that patents applied to a free program could
        make it effectively proprietary.  To prevent this, the GPL assures that
        patents cannot be used to render the program non-free.
        
          The precise terms and conditions for copying, distribution and
        modification follow.
        
                               TERMS AND CONDITIONS
        
          0. Definitions.
        
          "This License" refers to version 3 of the GNU General Public License.
        
          "Copyright" also means copyright-like laws that apply to other kinds of
        works, such as semiconductor masks.
        
          "The Program" refers to any copyrightable work licensed under this
        License.  Each licensee is addressed as "you".  "Licensees" and
        "recipients" may be individuals or organizations.
        
          To "modify" a work means to copy from or adapt all or part of the work
        in a fashion requiring copyright permission, other than the making of an
        exact copy.  The resulting work is called a "modified version" of the
        earlier work or a work "based on" the earlier work.
        
          A "covered work" means either the unmodified Program or a work based
        on the Program.
        
          To "propagate" a work means to do anything with it that, without
        permission, would make you directly or secondarily liable for
        infringement under applicable copyright law, except executing it on a
        computer or modifying a private copy.  Propagation includes copying,
        distribution (with or without modification), making available to the
        public, and in some countries other activities as well.
        
          To "convey" a work means any kind of propagation that enables other
        parties to make or receive copies.  Mere interaction with a user through
        a computer network, with no transfer of a copy, is not conveying.
        
          An interactive user interface displays "Appropriate Legal Notices"
        to the extent that it includes a convenient and prominently visible
        feature that (1) displays an appropriate copyright notice, and (2)
        tells the user that there is no warranty for the work (except to the
        extent that warranties are provided), that licensees may convey the
        work under this License, and how to view a copy of this License.  If
        the interface presents a list of user commands or options, such as a
        menu, a prominent item in the list meets this criterion.
        
          1. Source Code.
        
          The "source code" for a work means the preferred form of the work
        for making modifications to it.  "Object code" means any non-source
        form of a work.
        
          A "Standard Interface" means an interface that either is an official
        standard defined by a recognized standards body, or, in the case of
        interfaces specified for a particular programming language, one that
        is widely used among developers working in that language.
        
          The "System Libraries" of an executable work include anything, other
        than the work as a whole, that (a) is included in the normal form of
        packaging a Major Component, but which is not part of that Major
        Component, and (b) serves only to enable use of the work with that
        Major Component, or to implement a Standard Interface for which an
        implementation is available to the public in source code form.  A
        "Major Component", in this context, means a major essential component
        (kernel, window system, and so on) of the specific operating system
        (if any) on which the executable work runs, or a compiler used to
        produce the work, or an object code interpreter used to run it.
        
          The "Corresponding Source" for a work in object code form means all
        the source code needed to generate, install, and (for an executable
        work) run the object code and to modify the work, including scripts to
        control those activities.  However, it does not include the work's
        System Libraries, or general-purpose tools or generally available free
        programs which are used unmodified in performing those activities but
        which are not part of the work.  For example, Corresponding Source
        includes interface definition files associated with source files for
        the work, and the source code for shared libraries and dynamically
        linked subprograms that the work is specifically designed to require,
        such as by intimate data communication or control flow between those
        subprograms and other parts of the work.
        
          The Corresponding Source need not include anything that users
        can regenerate automatically from other parts of the Corresponding
        Source.
        
          The Corresponding Source for a work in source code form is that
        same work.
        
          2. Basic Permissions.
        
          All rights granted under this License are granted for the term of
        copyright on the Program, and are irrevocable provided the stated
        conditions are met.  This License explicitly affirms your unlimited
        permission to run the unmodified Program.  The output from running a
        covered work is covered by this License only if the output, given its
        content, constitutes a covered work.  This License acknowledges your
        rights of fair use or other equivalent, as provided by copyright law.
        
          You may make, run and propagate covered works that you do not
        convey, without conditions so long as your license otherwise remains
        in force.  You may convey covered works to others for the sole purpose
        of having them make modifications exclusively for you, or provide you
        with facilities for running those works, provided that you comply with
        the terms of this License in conveying all material for which you do
        not control copyright.  Those thus making or running the covered works
        for you must do so exclusively on your behalf, under your direction
        and control, on terms that prohibit them from making any copies of
        your copyrighted material outside their relationship with you.
        
          Conveying under any other circumstances is permitted solely under
        the conditions stated below.  Sublicensing is not allowed; section 10
        makes it unnecessary.
        
          3. Protecting Users' Legal Rights From Anti-Circumvention Law.
        
          No covered work shall be deemed part of an effective technological
        measure under any applicable law fulfilling obligations under article
        11 of the WIPO copyright treaty adopted on 20 December 1996, or
        similar laws prohibiting or restricting circumvention of such
        measures.
        
          When you convey a covered work, you waive any legal power to forbid
        circumvention of technological measures to the extent such circumvention
        is effected by exercising rights under this License with respect to
        the covered work, and you disclaim any intention to limit operation or
        modification of the work as a means of enforcing, against the work's
        users, your or third parties' legal rights to forbid circumvention of
        technological measures.
        
          4. Conveying Verbatim Copies.
        
          You may convey verbatim copies of the Program's source code as you
        receive it, in any medium, provided that you conspicuously and
        appropriately publish on each copy an appropriate copyright notice;
        keep intact all notices stating that this License and any
        non-permissive terms added in accord with section 7 apply to the code;
        keep intact all notices of the absence of any warranty; and give all
        recipients a copy of this License along with the Program.
        
          You may charge any price or no price for each copy that you convey,
        and you may offer support or warranty protection for a fee.
        
          5. Conveying Modified Source Versions.
        
          You may convey a work based on the Program, or the modifications to
        produce it from the Program, in the form of source code under the
        terms of section 4, provided that you also meet all of these conditions:
        
            a) The work must carry prominent notices stating that you modified
            it, and giving a relevant date.
        
            b) The work must carry prominent notices stating that it is
            released under this License and any conditions added under section
            7.  This requirement modifies the requirement in section 4 to
            "keep intact all notices".
        
            c) You must license the entire work, as a whole, under this
            License to anyone who comes into possession of a copy.  This
            License will therefore apply, along with any applicable section 7
            additional terms, to the whole of the work, and all its parts,
            regardless of how they are packaged.  This License gives no
            permission to license the work in any other way, but it does not
            invalidate such permission if you have separately received it.
        
            d) If the work has interactive user interfaces, each must display
            Appropriate Legal Notices; however, if the Program has interactive
            interfaces that do not display Appropriate Legal Notices, your
            work need not make them do so.
        
          A compilation of a covered work with other separate and independent
        works, which are not by their nature extensions of the covered work,
        and which are not combined with it such as to form a larger program,
        in or on a volume of a storage or distribution medium, is called an
        "aggregate" if the compilation and its resulting copyright are not
        used to limit the access or legal rights of the compilation's users
        beyond what the individual works permit.  Inclusion of a covered work
        in an aggregate does not cause this License to apply to the other
        parts of the aggregate.
        
          6. Conveying Non-Source Forms.
        
          You may convey a covered work in object code form under the terms
        of sections 4 and 5, provided that you also convey the
        machine-readable Corresponding Source under the terms of this License,
        in one of these ways:
        
            a) Convey the object code in, or embodied in, a physical product
            (including a physical distribution medium), accompanied by the
            Corresponding Source fixed on a durable physical medium
            customarily used for software interchange.
        
            b) Convey the object code in, or embodied in, a physical product
            (including a physical distribution medium), accompanied by a
            written offer, valid for at least three years and valid for as
            long as you offer spare parts or customer support for that product
            model, to give anyone who possesses the object code either (1) a
            copy of the Corresponding Source for all the software in the
            product that is covered by this License, on a durable physical
            medium customarily used for software interchange, for a price no
            more than your reasonable cost of physically performing this
            conveying of source, or (2) access to copy the
            Corresponding Source from a network server at no charge.
        
            c) Convey individual copies of the object code with a copy of the
            written offer to provide the Corresponding Source.  This
            alternative is allowed only occasionally and noncommercially, and
            only if you received the object code with such an offer, in accord
            with subsection 6b.
        
            d) Convey the object code by offering access from a designated
            place (gratis or for a charge), and offer equivalent access to the
            Corresponding Source in the same way through the same place at no
            further charge.  You need not require recipients to copy the
            Corresponding Source along with the object code.  If the place to
            copy the object code is a network server, the Corresponding Source
            may be on a different server (operated by you or a third party)
            that supports equivalent copying facilities, provided you maintain
            clear directions next to the object code saying where to find the
            Corresponding Source.  Regardless of what server hosts the
            Corresponding Source, you remain obligated to ensure that it is
            available for as long as needed to satisfy these requirements.
        
            e) Convey the object code using peer-to-peer transmission, provided
            you inform other peers where the object code and Corresponding
            Source of the work are being offered to the general public at no
            charge under subsection 6d.
        
          A separable portion of the object code, whose source code is excluded
        from the Corresponding Source as a System Library, need not be
        included in conveying the object code work.
        
          A "User Product" is either (1) a "consumer product", which means any
        tangible personal property which is normally used for personal, family,
        or household purposes, or (2) anything designed or sold for incorporation
        into a dwelling.  In determining whether a product is a consumer product,
        doubtful cases shall be resolved in favor of coverage.  For a particular
        product received by a particular user, "normally used" refers to a
        typical or common use of that class of product, regardless of the status
        of the particular user or of the way in which the particular user
        actually uses, or expects or is expected to use, the product.  A product
        is a consumer product regardless of whether the product has substantial
        commercial, industrial or non-consumer uses, unless such uses represent
        the only significant mode of use of the product.
        
          "Installation Information" for a User Product means any methods,
        procedures, authorization keys, or other information required to install
        and execute modified versions of a covered work in that User Product from
        a modified version of its Corresponding Source.  The information must
        suffice to ensure that the continued functioning of the modified object
        code is in no case prevented or interfered with solely because
        modification has been made.
        
          If you convey an object code work under this section in, or with, or
        specifically for use in, a User Product, and the conveying occurs as
        part of a transaction in which the right of possession and use of the
        User Product is transferred to the recipient in perpetuity or for a
        fixed term (regardless of how the transaction is characterized), the
        Corresponding Source conveyed under this section must be accompanied
        by the Installation Information.  But this requirement does not apply
        if neither you nor any third party retains the ability to install
        modified object code on the User Product (for example, the work has
        been installed in ROM).
        
          The requirement to provide Installation Information does not include a
        requirement to continue to provide support service, warranty, or updates
        for a work that has been modified or installed by the recipient, or for
        the User Product in which it has been modified or installed.  Access to a
        network may be denied when the modification itself materially and
        adversely affects the operation of the network or violates the rules and
        protocols for communication across the network.
        
          Corresponding Source conveyed, and Installation Information provided,
        in accord with this section must be in a format that is publicly
        documented (and with an implementation available to the public in
        source code form), and must require no special password or key for
        unpacking, reading or copying.
        
          7. Additional Terms.
        
          "Additional permissions" are terms that supplement the terms of this
        License by making exceptions from one or more of its conditions.
        Additional permissions that are applicable to the entire Program shall
        be treated as though they were included in this License, to the extent
        that they are valid under applicable law.  If additional permissions
        apply only to part of the Program, that part may be used separately
        under those permissions, but the entire Program remains governed by
        this License without regard to the additional permissions.
        
          When you convey a copy of a covered work, you may at your option
        remove any additional permissions from that copy, or from any part of
        it.  (Additional permissions may be written to require their own
        removal in certain cases when you modify the work.)  You may place
        additional permissions on material, added by you to a covered work,
        for which you have or can give appropriate copyright permission.
        
          Notwithstanding any other provision of this License, for material you
        add to a covered work, you may (if authorized by the copyright holders of
        that material) supplement the terms of this License with terms:
        
            a) Disclaiming warranty or limiting liability differently from the
            terms of sections 15 and 16 of this License; or
        
            b) Requiring preservation of specified reasonable legal notices or
            author attributions in that material or in the Appropriate Legal
            Notices displayed by works containing it; or
        
            c) Prohibiting misrepresentation of the origin of that material, or
            requiring that modified versions of such material be marked in
            reasonable ways as different from the original version; or
        
            d) Limiting the use for publicity purposes of names of licensors or
            authors of the material; or
        
            e) Declining to grant rights under trademark law for use of some
            trade names, trademarks, or service marks; or
        
            f) Requiring indemnification of licensors and authors of that
            material by anyone who conveys the material (or modified versions of
            it) with contractual assumptions of liability to the recipient, for
            any liability that these contractual assumptions directly impose on
            those licensors and authors.
        
          All other non-permissive additional terms are considered "further
        restrictions" within the meaning of section 10.  If the Program as you
        received it, or any part of it, contains a notice stating that it is
        governed by this License along with a term that is a further
        restriction, you may remove that term.  If a license document contains
        a further restriction but permits relicensing or conveying under this
        License, you may add to a covered work material governed by the terms
        of that license document, provided that the further restriction does
        not survive such relicensing or conveying.
        
          If you add terms to a covered work in accord with this section, you
        must place, in the relevant source files, a statement of the
        additional terms that apply to those files, or a notice indicating
        where to find the applicable terms.
        
          Additional terms, permissive or non-permissive, may be stated in the
        form of a separately written license, or stated as exceptions;
        the above requirements apply either way.
        
          8. Termination.
        
          You may not propagate or modify a covered work except as expressly
        provided under this License.  Any attempt otherwise to propagate or
        modify it is void, and will automatically terminate your rights under
        this License (including any patent licenses granted under the third
        paragraph of section 11).
        
          However, if you cease all violation of this License, then your
        license from a particular copyright holder is reinstated (a)
        provisionally, unless and until the copyright holder explicitly and
        finally terminates your license, and (b) permanently, if the copyright
        holder fails to notify you of the violation by some reasonable means
        prior to 60 days after the cessation.
        
          Moreover, your license from a particular copyright holder is
        reinstated permanently if the copyright holder notifies you of the
        violation by some reasonable means, this is the first time you have
        received notice of violation of this License (for any work) from that
        copyright holder, and you cure the violation prior to 30 days after
        your receipt of the notice.
        
          Termination of your rights under this section does not terminate the
        licenses of parties who have received copies or rights from you under
        this License.  If your rights have been terminated and not permanently
        reinstated, you do not qualify to receive new licenses for the same
        material under section 10.
        
          9. Acceptance Not Required for Having Copies.
        
          You are not required to accept this License in order to receive or
        run a copy of the Program.  Ancillary propagation of a covered work
        occurring solely as a consequence of using peer-to-peer transmission
        to receive a copy likewise does not require acceptance.  However,
        nothing other than this License grants you permission to propagate or
        modify any covered work.  These actions infringe copyright if you do
        not accept this License.  Therefore, by modifying or propagating a
        covered work, you indicate your acceptance of this License to do so.
        
          10. Automatic Licensing of Downstream Recipients.
        
          Each time you convey a covered work, the recipient automatically
        receives a license from the original licensors, to run, modify and
        propagate that work, subject to this License.  You are not responsible
        for enforcing compliance by third parties with this License.
        
          An "entity transaction" is a transaction transferring control of an
        organization, or substantially all assets of one, or subdividing an
        organization, or merging organizations.  If propagation of a covered
        work results from an entity transaction, each party to that
        transaction who receives a copy of the work also receives whatever
        licenses to the work the party's predecessor in interest had or could
        give under the previous paragraph, plus a right to possession of the
        Corresponding Source of the work from the predecessor in interest, if
        the predecessor has it or can get it with reasonable efforts.
        
          You may not impose any further restrictions on the exercise of the
        rights granted or affirmed under this License.  For example, you may
        not impose a license fee, royalty, or other charge for exercise of
        rights granted under this License, and you may not initiate litigation
        (including a cross-claim or counterclaim in a lawsuit) alleging that
        any patent claim is infringed by making, using, selling, offering for
        sale, or importing the Program or any portion of it.
        
          11. Patents.
        
          A "contributor" is a copyright holder who authorizes use under this
        License of the Program or a work on which the Program is based.  The
        work thus licensed is called the contributor's "contributor version".
        
          A contributor's "essential patent claims" are all patent claims
        owned or controlled by the contributor, whether already acquired or
        hereafter acquired, that would be infringed by some manner, permitted
        by this License, of making, using, or selling its contributor version,
        but do not include claims that would be infringed only as a
        consequence of further modification of the contributor version.  For
        purposes of this definition, "control" includes the right to grant
        patent sublicenses in a manner consistent with the requirements of
        this License.
        
          Each contributor grants you a non-exclusive, worldwide, royalty-free
        patent license under the contributor's essential patent claims, to
        make, use, sell, offer for sale, import and otherwise run, modify and
        propagate the contents of its contributor version.
        
          In the following three paragraphs, a "patent license" is any express
        agreement or commitment, however denominated, not to enforce a patent
        (such as an express permission to practice a patent or covenant not to
        sue for patent infringement).  To "grant" such a patent license to a
        party means to make such an agreement or commitment not to enforce a
        patent against the party.
        
          If you convey a covered work, knowingly relying on a patent license,
        and the Corresponding Source of the work is not available for anyone
        to copy, free of charge and under the terms of this License, through a
        publicly available network server or other readily accessible means,
        then you must either (1) cause the Corresponding Source to be so
        available, or (2) arrange to deprive yourself of the benefit of the
        patent license for this particular work, or (3) arrange, in a manner
        consistent with the requirements of this License, to extend the patent
        license to downstream recipients.  "Knowingly relying" means you have
        actual knowledge that, but for the patent license, your conveying the
        covered work in a country, or your recipient's use of the covered work
        in a country, would infringe one or more identifiable patents in that
        country that you have reason to believe are valid.
        
          If, pursuant to or in connection with a single transaction or
        arrangement, you convey, or propagate by procuring conveyance of, a
        covered work, and grant a patent license to some of the parties
        receiving the covered work authorizing them to use, propagate, modify
        or convey a specific copy of the covered work, then the patent license
        you grant is automatically extended to all recipients of the covered
        work and works based on it.
        
          A patent license is "discriminatory" if it does not include within
        the scope of its coverage, prohibits the exercise of, or is
        conditioned on the non-exercise of one or more of the rights that are
        specifically granted under this License.  You may not convey a covered
        work if you are a party to an arrangement with a third party that is
        in the business of distributing software, under which you make payment
        to the third party based on the extent of your activity of conveying
        the work, and under which the third party grants, to any of the
        parties who would receive the covered work from you, a discriminatory
        patent license (a) in connection with copies of the covered work
        conveyed by you (or copies made from those copies), or (b) primarily
        for and in connection with specific products or compilations that
        contain the covered work, unless you entered into that arrangement,
        or that patent license was granted, prior to 28 March 2007.
        
          Nothing in this License shall be construed as excluding or limiting
        any implied license or other defenses to infringement that may
        otherwise be available to you under applicable patent law.
        
          12. No Surrender of Others' Freedom.
        
          If conditions are imposed on you (whether by court order, agreement or
        otherwise) that contradict the conditions of this License, they do not
        excuse you from the conditions of this License.  If you cannot convey a
        covered work so as to satisfy simultaneously your obligations under this
        License and any other pertinent obligations, then as a consequence you may
        not convey it at all.  For example, if you agree to terms that obligate you
        to collect a royalty for further conveying from those to whom you convey
        the Program, the only way you could satisfy both those terms and this
        License would be to refrain entirely from conveying the Program.
        
          13. Use with the GNU Affero General Public License.
        
          Notwithstanding any other provision of this License, you have
        permission to link or combine any covered work with a work licensed
        under version 3 of the GNU Affero General Public License into a single
        combined work, and to convey the resulting work.  The terms of this
        License will continue to apply to the part which is the covered work,
        but the special requirements of the GNU Affero General Public License,
        section 13, concerning interaction through a network will apply to the
        combination as such.
        
          14. Revised Versions of this License.
        
          The Free Software Foundation may publish revised and/or new versions of
        the GNU General Public License from time to time.  Such new versions will
        be similar in spirit to the present version, but may differ in detail to
        address new problems or concerns.
        
          Each version is given a distinguishing version number.  If the
        Program specifies that a certain numbered version of the GNU General
        Public License "or any later version" applies to it, you have the
        option of following the terms and conditions either of that numbered
        version or of any later version published by the Free Software
        Foundation.  If the Program does not specify a version number of the
        GNU General Public License, you may choose any version ever published
        by the Free Software Foundation.
        
          If the Program specifies that a proxy can decide which future
        versions of the GNU General Public License can be used, that proxy's
        public statement of acceptance of a version permanently authorizes you
        to choose that version for the Program.
        
          Later license versions may give you additional or different
        permissions.  However, no additional obligations are imposed on any
        author or copyright holder as a result of your choosing to follow a
        later version.
        
          15. Disclaimer of Warranty.
        
          THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
        APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
        HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
        OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
        THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
        IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
        ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
        
          16. Limitation of Liability.
        
          IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
        WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
        THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
        GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
        USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
        DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
        PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
        EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
        SUCH DAMAGES.
        
          17. Interpretation of Sections 15 and 16.
        
          If the disclaimer of warranty and limitation of liability provided
        above cannot be given local legal effect according to their terms,
        reviewing courts shall apply local law that most closely approximates
        an absolute waiver of all civil liability in connection with the
        Program, unless a warranty or assumption of liability accompanies a
        copy of the Program in return for a fee.
        
                             END OF TERMS AND CONDITIONS
        
                    How to Apply These Terms to Your New Programs
        
          If you develop a new program, and you want it to be of the greatest
        possible use to the public, the best way to achieve this is to make it
        free software which everyone can redistribute and change under these terms.
        
          To do so, attach the following notices to the program.  It is safest
        to attach them to the start of each source file to most effectively
        state the exclusion of warranty; and each file should have at least
        the "copyright" line and a pointer to where the full notice is found.
        
            <one line to give the program's name and a brief idea of what it does.>
            Copyright (C) <year>  <name of author>
        
            This program is free software: you can redistribute it and/or modify
            it under the terms of the GNU General Public License as published by
            the Free Software Foundation, either version 3 of the License, or
            (at your option) any later version.
        
            This program is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            GNU General Public License for more details.
        
            You should have received a copy of the GNU General Public License
            along with this program.  If not, see <https://www.gnu.org/licenses/>.
        
        Also add information on how to contact you by electronic and paper mail.
        
          If the program does terminal interaction, make it output a short
        notice like this when it starts in an interactive mode:
        
            <program>  Copyright (C) <year>  <name of author>
            This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
            This is free software, and you are welcome to redistribute it
            under certain conditions; type `show c' for details.
        
        The hypothetical commands `show w' and `show c' should show the appropriate
        parts of the General Public License.  Of course, your program's commands
        might be different; for a GUI interface, you would use an "about box".
        
          You should also get your employer (if you work as a programmer) or school,
        if any, to sign a "copyright disclaimer" for the program, if necessary.
        For more information on this, and how to apply and follow the GNU GPL, see
        <https://www.gnu.org/licenses/>.
        
          The GNU General Public License does not permit incorporating your program
        into proprietary programs.  If your program is a subroutine library, you
        may consider it more useful to permit linking proprietary applications with
        the library.  If this is what you want to do, use the GNU Lesser General
        Public License instead of this License.  But first, please read
        <https://www.gnu.org/licenses/why-not-lgpl.html>.
    üìÑ README.md
        **[[‰∏≠ÊñáÁâà]][readme]**
        <div align="center">
        
        ![RF4S][rf4s_logo]
        <h1 align="center">RF4S: Russian Fishing 4 Script</h1>
        
        **A simple Russian Fishing 4 fishing bot, supporting spin, bottom, marine, and float fishing modes.**
        
        <a target="_blank" href="https://opensource.org/license/gpl-3-0" style="background:none">
            <img src="https://img.shields.io/badge/License-GPLv3-blue.svg" style="height: 22px;" />
        </a>
        <a target="_blank" href="https://discord.gg/BZQWQnAMbY" style="background:none">
            <img src="https://img.shields.io/badge/discord-join-rf44.svg?labelColor=191937&color=6F6FF7&logo=discord" style="height: 22px;" />
        </a>
        <a target="_blank" href="http://makeapullrequest.com" style="background:none">
            <img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat" style="height: 22px;" />
        </a>
        <!-- <a target="_blank" href="https://github.com/pylint-dev/pylint" style="background:none">
            <img src="https://img.shields.io/badge/linting-pylint-yellowgreen" style="height: 22px;" />
        </a> -->
        <!-- <a target="_blank" href="https://github.com/psf/black" style="background:none">
            <img src="https://img.shields.io/badge/code%20style-black-000000.svg" style="height: 22px;" />
        </a> -->
        <!-- <a target="_blank" href="link_to_docs, tbd" style="background:none">
            <img src="https://img.shields.io/badge/docs-%23BE1B55" style="height: 22px;" />
        </a> -->  
        
        ![Python badge][python_badge]
        ![Windows badge][windows_badge]
        
        </div>
        
        > [!TIP]
        > Join the [Discord server][discord] if you want to suggest new features, report bugs or get help on how to use the script.
        
        
        ## Getting Started
        ### Installation
        You can download executables from [Releases][releases] directly.
        To run it from Python interpreter, see **[INSTALLATION][installation]**.
        ## Usage
        ### Before you start...
        - Move your character to the fishing spot before running the script
        - For Spin/Marine/Float/Wakey Rig Fishing: Pick up the rod you want to use.
        - For Bottom Fishing:
            - Add tackles to quick selection slots.
            - Cast them and place them nearby so the bot can access them via shortcuts (1 ~ 3).
        > [!NOTE]
        > Currently, only bottom fishing mode support multiple rods.
        
        ### Let's Run it!
        > [!IMPORTANT]
        > For executables, replace `python tools\xxx.py` with `.\xxx` or double-click the file to run it.
        
        > [!TIP]
        > See **[CONFIGURATION][configuration]** for advanced usage and configuration options.
        
        
        1. Open cmd/PowerShell
        2. Navigate into the project directory and run the script with default configuration. Type `CTRL-C` to quit.
        ```
        cd "path\to\the\project"
        python tools\main.py
        ```
        > [!TIP]
        > `path\to\the\project` is the directory where you placed the files after cloning or extracting the project.  
        > ![path]
        
        ## Tools
        ### Craft items
        Select materials before you run it, press `Ctrl-C` to quit.
        ```
        python tools\craft.py
        ```
        ### Harvest baits
        Press `Ctrl-C` to quit.
        ```
        python tools\harvest.py
        ```
        ### Toggle moving forward
        Press `W`to pause, `S` to quit.
        ```
        python tools\move.py
        ```
        ### Automate friction brake
        Press `G` to reset, `H` to quit.
        ```
        python tools\auto_friction_brake.py
        ```
        ### Calculate tackle's stats and friction brake
        ```
        python tools\calculate.py
        ```
        
        ## Troubleshooting
        <details>
        <summary>How to stop the script?</summary>
        
        - Type `Ctrl-C` in your terminal. 
        </details>
        <!-- ------------------------------- divide -------------------------------- -->
        <details>
        <summary>Can't stop the script?</summary>
        
        - Some keys might have been pressed down (e.g. `Ctrl`, `Shift`, `Mouse button`, etc.),  
          press them again to release it and type `Ctrl-C` as usual.
        </details>
        <!-- ------------------------------- divide -------------------------------- -->
        <details>
        <summary>Stuck at casting 128%?</summary>
        
        - Check that the game language and script language settings are the same.
        - Make sure your reel is fully loaded, or equip a rainbow line and use `-R` flag. 
        </details>
        
        <!-- ------------------------------- divide -------------------------------- -->
        <details>
        <summary>Didn't lift the rod after the retrieval is finished?</summary>
        
        - Make sure your reel is fully loaded, or equip a rainbow line and use `-R` flag. 
        - Change the game window size.
        - Reduce the value of `SPOOL_CONFIDENCE` in `config.yaml`.
        - Keep away from light sources or turn off the boat light.
        </details>
        <!-- ------------------------------- divide -------------------------------- -->
        <details>
        <summary>Script is running but nothing happen?</summary>
        
        - Open cmd/Powershell as administrator and run it again.
        </details>
        <!-- ------------------------------- divide -------------------------------- -->
        
        ## Changelog
        See **[CHANGELOG][changelog].**
        
        ## License
        **[GNU General Public License version 3][license]**
        
        ## Contributing
        Any contribution, bug report, or idea about new features is welcome.
        
        ## Contact me
        dereklee0310@gmail.com 
        
        [readme]: /docs/zh-TW/README.md
        [rf4s_logo]: /static/readme/RF4S.png
        [python_badge]: https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white
        [windows_badge]: https://img.shields.io/badge/Windows-0078D6?style=for-the-badge&logo=windows&logoColor=white
        
        [discord]: https://discord.gg/BZQWQnAMbY
        [python]: https://www.python.org/downloads/
        [releases]: https://github.com/dereklee0310/RussianFishing4Script/releases
        [installation]: /docs/en/INSTALLATION.md
        [configuration]: /docs/en/CONFIGURATION.md
        [changelog]: /docs/en/CHANGELOG.md
        [path]: /static/readme/path.png
        [license]: /LICENSE
    üìÑ requirements.txt
        pyautogui==0.9.54
        keyboard==0.13.5
        pywin32==306
        pynput==1.7.6
        opencv-python==4.8.0.76
        Pillow==10.1.0
        PyScreeze==0.1.29
        python-dotenv==1.0.1
        matplotlib==3.8.0
        playsound==1.2.2 # downgrade to avoid bug
        pyyaml==6.0.2
        yacs==0.1.8
        rich==13.9.4
        bump-my-version==0.32.1
        discord-webhook==1.4.1
        PyQt6>=6.4.0
        PyYAML>=6.0
        pyyaml>=6.0
        # reference: https://stackoverflow.com/questions/68704443/python-playsound-error-261-for-command-the-driver-cannot-recognize-the-specifie
    üìÑ setup.bat
        @echo off
        
        echo This might take a while...
        
        @REM for playsound module: https://github.com/TaylorSMarks/playsound/issues/145
        python -m pip install wheel setuptools pip --upgrade
        python -m pip install -r requirements.txt
        
        if not exist ".\screenshots" mkdir screenshots
        if not exist ".\logs" mkdir logs
        if not exist ".\config.yaml" copy ".\rf4s\config\config.yaml" ".\config.yaml"
    üìÑ tree_with_content_beautiful.py
        import os
        import mimetypes
        
        # –†–∞—Å—à–∏—Ä–µ–Ω–∏—è –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ –∑–≤—É–∫–æ–≤
        IMAGE_EXTS = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.webp'}
        AUDIO_EXTS = {'.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a'}
        
        def is_image(filename):
            ext = os.path.splitext(filename)[1].lower()
            if ext in IMAGE_EXTS:
                return True
            mime, _ = mimetypes.guess_type(filename)
            return mime and mime.startswith('image')
        
        def is_audio(filename):
            ext = os.path.splitext(filename)[1].lower()
            if ext in AUDIO_EXTS:
                return True
            mime, _ = mimetypes.guess_type(filename)
            return mime and mime.startswith('audio')
        
        def get_file_content(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                return content
            except Exception:
                return "[ERROR: Unable to decode as UTF-8 or read file]"
        
        def tree_with_contents(start_path='.'):
            result = []
        
            for root, dirs, files in os.walk(start_path):
                level = root.replace(start_path, '').count(os.sep)
                indent = '    ' * level
                folder_name = os.path.basename(root) or os.path.abspath(root)
                result.append(f"{indent}üìÅ {folder_name}/")
                subindent = '    ' * (level + 1)
                for fname in files:
                    fpath = os.path.join(root, fname)
                    f_disp = f"{subindent}üìÑ {fname}"
                    if is_image(fname):
                        result.append(f"{f_disp} [IMAGE FILE]")
                    elif is_audio(fname):
                        result.append(f"{f_disp} [AUDIO FILE]")
                    else:
                        result.append(f"{f_disp}")
                        content = get_file_content(fpath)
                        # –ö—Ä–∞—Å–∏–≤–æ –≤—ã–≤–æ–¥–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
                        content_lines = content.splitlines()
                        for line in content_lines:
                            result.append(f"{subindent}    {line}")
                        if not content_lines:
                            result.append(f"{subindent}    [EMPTY FILE]")
            return '\n'.join(result)
        
        if __name__ == "__main__":
            output_file = "tree_with_contents.txt"
            folder = '.'
            tree_str = tree_with_contents(folder)
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(tree_str)
            print(f"–î–µ—Ä–µ–≤–æ —Ñ–∞–π–ª–æ–≤ –∏ –∏—Ö —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ {output_file}")
    üìÅ gui/
        üìÑ config.yaml
            VERSION: 0.5.2
            SCRIPT:
              LANGUAGE: en
              LAUNCH_OPTIONS: ''
              SMTP_VERIFICATION: false
              IMAGE_VERIFICATION: false
              SNAG_DETECTION: false
              SPOOLING_DETECTION: false
              RANDOM_ROD_SELECTION: false
              SPOOL_CONFIDENCE: 0.98
              SPOD_ROD_RECAST_DELAY: 1800
              LURE_CHANGE_DELAY: 1800
              ALARM_SOUND: ./static/sound/guitar.wav
              RANDOM_CAST_PROBABILITY: 0.25
              SCREENSHOT_TAGS:
              - green
              - yellow
              - blue
              - purple
              - pink
            KEY:
              TEA: -1
              CARROT: -1
              BOTTOM_RODS:
              - 1
              - 2
              - 3
              COFFEE: -1
              DIGGING_TOOL: -1
              ALCOHOL: -1
              MAIN_ROD: -1
              SPOD_ROD: -1
              QUIT: CTRL-C
            STAT:
              ENERGY_THRESHOLD: 0.74
              HUNGER_THRESHOLD: 0.5
              COMFORT_THRESHOLD: 0.51
              TEA_DELAY: 300
              COFFEE_LIMIT: 10
              COFFEE_PER_DRINK: 1
              ALCOHOL_DELAY: 900
              ALCOHOL_PER_DRINK: 1
            FRICTION_BRAKE:
              INITIAL: 15
              MAX: 26
              START_DELAY: 0.01
              INCREASE_DELAY: 0.01
              SENSITIVITY: medium
            KEEPNET:
              CAPACITY: 100
              FISH_DELAY: 0.0
              GIFT_DELAY: 4.0
              FULL_ACTION: quit
              WHITELIST:
              - mackerel
              - saithe
              - herring
              - squid
              - scallop
              - mussel
              BLACKLIST: []
              TAGS:
              - green
              - yellow
              - blue
              - purple
              - pink
            NOTIFICATION:
              EMAIL: ''
              PASSWORD: ''
              SMTP_SERVER: ''
              MIAO_CODE: ''
              DISCORD_WEBHOOK_URL: https://discord.com/api/webhooks/1381306998586343637/t-6xkZiqrACMLSs_DhzE_p9dPAG-sVhUzN_bXqnf7SukxpRhNxL6jS8QfRKySoeKhgeJ
            PAUSE:
              DELAY: 1800
              DURATION: 600
            PROFILE:
              SPIN:
                MODE: spin
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 6.0
                POST_ACCELERATION: 'off'
                TIGHTEN_DURATION: 0.0
                RETRIEVAL_DURATION: 0.0
                RETRIEVAL_DELAY: 0.0
                RETRIEVAL_TIMEOUT: 256.0
                PRE_ACCELERATION: false
                TYPE: normal
              SPIN_WITH_PAUSE:
                MODE: spin
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 6.0
                TIGHTEN_DURATION: 1.0
                RETRIEVAL_DURATION: 1.0
                RETRIEVAL_DELAY: 3.0
                RETRIEVAL_TIMEOUT: 256.0
                PRE_ACCELERATION: false
                POST_ACCELERATION: 'off'
                TYPE: pause
              SPIN_WITH_LIFT:
                MODE: spin
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 6.0
                TIGHTEN_DURATION: 0.0
                RETRIEVAL_DURATION: 1.0
                RETRIEVAL_DELAY: 1.0
                RETRIEVAL_TIMEOUT: 256.0
                PRE_ACCELERATION: false
                POST_ACCELERATION: 'off'
                TYPE: lift
              BOTTOM:
                MODE: bottom
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 4.0
                POST_ACCELERATION: 'off'
                CHECK_DELAY: 32.0
                CHECK_MISS_LIMIT: 16
                PUT_DOWN_DELAY: 0.0
              PIRK:
                MODE: pirk
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 60.0
                TIGHTEN_DURATION: 1.0
                DEPTH_ADJUST_DELAY: 4.0
                DEPTH_ADJUST_DURATION: 1.0
                CTRL: false
                SHIFT: false
                PIRK_DURATION: 0.5
                PIRK_DELAY: 2.0
                PIRK_TIMEOUT: 32.0
                PIRK_RETRIEVAL: false
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              PIRK_WITH_RETRIEVAL:
                MODE: pirk
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 60.0
                TIGHTEN_DURATION: 1.0
                DEPTH_ADJUST_DELAY: 0.0
                DEPTH_ADJUST_DURATION: 1.0
                CTRL: false
                SHIFT: false
                PIRK_DURATION: 0.5
                PIRK_DELAY: 2.0
                PIRK_TIMEOUT: 32.0
                PIRK_RETRIEVAL: true
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              WAKEY_RIG:
                MODE: pirk
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 45.0
                TIGHTEN_DURATION: 1.0
                DEPTH_ADJUST_DELAY: 4.0
                DEPTH_ADJUST_DURATION: 1.0
                CTRL: true
                SHIFT: false
                PIRK_DURATION: 1.5
                PIRK_DELAY: 4.0
                PIRK_TIMEOUT: 32.0
                PIRK_RETRIEVAL: false
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              ELEVATOR:
                MODE: elevator
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 60.0
                TIGHTEN_DURATION: 1.0
                ELEVATE_DURATION: 4.0
                ELEVATE_DELAY: 4.0
                ELEVATE_TIMEOUT: 40.0
                DROP: false
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              ELEVATOR_WITH_DROP:
                MODE: elevator
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 60.0
                TIGHTEN_DURATION: 1.0
                ELEVATE_DURATION: 4.0
                ELEVATE_DELAY: 4.0
                ELEVATE_TIMEOUT: 40.0
                DROP: true
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              TELESCOPIC:
                MODE: telescopic
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 4.0
                FLOAT_SENSITIVITY: 0.68
                CHECK_DELAY: 1.0
                PULL_DELAY: 0.5
                DRIFT_TIMEOUT: 16.0
                CAMERA_SHAPE: square
              BOLOGNESE:
                MODE: bolognese
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 4.0
                FLOAT_SENSITIVITY: 0.68
                CHECK_DELAY: 1.0
                PULL_DELAY: 0.5
                DRIFT_TIMEOUT: 32.0
                CAMERA_SHAPE: square
                POST_ACCELERATION: 'off'
        üìÑ config.yaml.backup
            VERSION: 0.5.2
            SCRIPT:
              LANGUAGE: en
              LAUNCH_OPTIONS: ''
              SMTP_VERIFICATION: false
              IMAGE_VERIFICATION: false
              SNAG_DETECTION: false
              SPOOLING_DETECTION: false
              RANDOM_ROD_SELECTION: false
              SPOOL_CONFIDENCE: 0.98
              SPOD_ROD_RECAST_DELAY: 1800
              LURE_CHANGE_DELAY: 1800
              ALARM_SOUND: ./static/sound/guitar.wav
              RANDOM_CAST_PROBABILITY: 0.25
              SCREENSHOT_TAGS:
              - green
              - yellow
              - blue
              - purple
              - pink
            KEY:
              TEA: -1
              CARROT: -1
              BOTTOM_RODS:
              - 1
              - 2
              - 3
              COFFEE: -1
              DIGGING_TOOL: -1
              ALCOHOL: -1
              MAIN_ROD: -1
              SPOD_ROD: -1
              QUIT: CTRL-C
            STAT:
              ENERGY_THRESHOLD: 0.74
              HUNGER_THRESHOLD: 0.5
              COMFORT_THRESHOLD: 0.51
              TEA_DELAY: 300
              COFFEE_LIMIT: 10
              COFFEE_PER_DRINK: 1
              ALCOHOL_DELAY: 900
              ALCOHOL_PER_DRINK: 1
            FRICTION_BRAKE:
              INITIAL: 15
              MAX: 26
              START_DELAY: 0.01
              INCREASE_DELAY: 0.01
              SENSITIVITY: medium
            KEEPNET:
              CAPACITY: 100
              FISH_DELAY: 0.0
              GIFT_DELAY: 4.0
              FULL_ACTION: quit
              WHITELIST:
              - mackerel
              - saithe
              - herring
              - squid
              - scallop
              - mussel
              BLACKLIST: []
              TAGS:
              - green
              - yellow
              - blue
              - purple
              - pink
            NOTIFICATION:
              EMAIL: ''
              PASSWORD: ''
              SMTP_SERVER: ''
              MIAO_CODE: ''
              DISCORD_WEBHOOK_URL: https://discord.com/api/webhooks/1381306998586343637/t-6xkZiqrACMLSs_DhzE_p9dPAG-sVhUzN_bXqnf7SukxpRhNxL6jS8QfRKySoeKhgeJ
            PAUSE:
              DELAY: 1800
              DURATION: 600
            PROFILE:
              SPIN:
                MODE: spin
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 6.0
                POST_ACCELERATION: 'off'
                TIGHTEN_DURATION: 0.0
                RETRIEVAL_DURATION: 0.0
                RETRIEVAL_DELAY: 0.0
                RETRIEVAL_TIMEOUT: 256.0
                PRE_ACCELERATION: false
                TYPE: normal
              SPIN_WITH_PAUSE:
                MODE: spin
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 6.0
                TIGHTEN_DURATION: 1.0
                RETRIEVAL_DURATION: 1.0
                RETRIEVAL_DELAY: 3.0
                RETRIEVAL_TIMEOUT: 256.0
                PRE_ACCELERATION: false
                POST_ACCELERATION: 'off'
                TYPE: pause
              SPIN_WITH_LIFT:
                MODE: spin
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 6.0
                TIGHTEN_DURATION: 0.0
                RETRIEVAL_DURATION: 1.0
                RETRIEVAL_DELAY: 1.0
                RETRIEVAL_TIMEOUT: 256.0
                PRE_ACCELERATION: false
                POST_ACCELERATION: 'off'
                TYPE: lift
              BOTTOM:
                MODE: bottom
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 4.0
                POST_ACCELERATION: 'off'
                CHECK_DELAY: 32.0
                CHECK_MISS_LIMIT: 16
                PUT_DOWN_DELAY: 0.0
              PIRK:
                MODE: pirk
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 60.0
                TIGHTEN_DURATION: 1.0
                DEPTH_ADJUST_DELAY: 4.0
                DEPTH_ADJUST_DURATION: 1.0
                CTRL: false
                SHIFT: false
                PIRK_DURATION: 0.5
                PIRK_DELAY: 2.0
                PIRK_TIMEOUT: 32.0
                PIRK_RETRIEVAL: false
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              PIRK_WITH_RETRIEVAL:
                MODE: pirk
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 60.0
                TIGHTEN_DURATION: 1.0
                DEPTH_ADJUST_DELAY: 0.0
                DEPTH_ADJUST_DURATION: 1.0
                CTRL: false
                SHIFT: false
                PIRK_DURATION: 0.5
                PIRK_DELAY: 2.0
                PIRK_TIMEOUT: 32.0
                PIRK_RETRIEVAL: true
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              WAKEY_RIG:
                MODE: pirk
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 45.0
                TIGHTEN_DURATION: 1.0
                DEPTH_ADJUST_DELAY: 4.0
                DEPTH_ADJUST_DURATION: 1.0
                CTRL: true
                SHIFT: false
                PIRK_DURATION: 1.5
                PIRK_DELAY: 4.0
                PIRK_TIMEOUT: 32.0
                PIRK_RETRIEVAL: false
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              ELEVATOR:
                MODE: elevator
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 60.0
                TIGHTEN_DURATION: 1.0
                ELEVATE_DURATION: 4.0
                ELEVATE_DELAY: 4.0
                ELEVATE_TIMEOUT: 40.0
                DROP: false
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              ELEVATOR_WITH_DROP:
                MODE: elevator
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 1.0
                CAST_DELAY: 4.0
                SINK_TIMEOUT: 60.0
                TIGHTEN_DURATION: 1.0
                ELEVATE_DURATION: 4.0
                ELEVATE_DELAY: 4.0
                ELEVATE_TIMEOUT: 40.0
                DROP: true
                HOOK_DELAY: 0.5
                POST_ACCELERATION: auto
              TELESCOPIC:
                MODE: telescopic
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 4.0
                FLOAT_SENSITIVITY: 0.68
                CHECK_DELAY: 1.0
                PULL_DELAY: 0.5
                DRIFT_TIMEOUT: 16.0
                CAMERA_SHAPE: square
              BOLOGNESE:
                MODE: bolognese
                LAUNCH_OPTIONS: ''
                CAST_POWER_LEVEL: 5.0
                CAST_DELAY: 4.0
                FLOAT_SENSITIVITY: 0.68
                CHECK_DELAY: 1.0
                PULL_DELAY: 0.5
                DRIFT_TIMEOUT: 32.0
                CAMERA_SHAPE: square
                POST_ACCELERATION: 'off'
        üìÑ config_manager.py
            """
            Configuration management for Russian Fishing 4 Script GUI
            Enhanced with better validation and error handling
            """
            
            import yaml
            import os
            from pathlib import Path
            from typing import Dict, Any, List, Tuple
            import copy
            import re
            
            
            class ConfigManager:
                """Manages configuration loading, saving, and validation with enhanced features."""
                
                def __init__(self):
                    self.config = {}
                    self.default_config = self._get_default_config()
                    self.config_file_path = None
                    
                def _get_default_config(self) -> Dict[str, Any]:
                    """Get comprehensive default configuration structure."""
                    return {
                        "VERSION": "0.5.2",
                        "SCRIPT": {
                            "LANGUAGE": "en",
                            "LAUNCH_OPTIONS": "",
                            "SMTP_VERIFICATION": True,
                            "IMAGE_VERIFICATION": True,
                            "SNAG_DETECTION": True,
                            "SPOOLING_DETECTION": True,
                            "RANDOM_ROD_SELECTION": True,
                            "SPOOL_CONFIDENCE": 0.98,
                            "SPOD_ROD_RECAST_DELAY": 1800,
                            "LURE_CHANGE_DELAY": 1800,
                            "ALARM_SOUND": "./static/sound/guitar.wav",
                            "RANDOM_CAST_PROBABILITY": 0.25,
                            "SCREENSHOT_TAGS": ["green", "yellow", "blue", "purple", "pink"]
                        },
                        "KEY": {
                            "TEA": -1,
                            "CARROT": -1,
                            "BOTTOM_RODS": [1, 2, 3],
                            "COFFEE": -1,
                            "DIGGING_TOOL": 5,
                            "ALCOHOL": 6,
                            "MAIN_ROD": 1,
                            "SPOD_ROD": 7,
                            "QUIT": "CTRL-C"
                        },
                        "STAT": {
                            "ENERGY_THRESHOLD": 0.74,
                            "HUNGER_THRESHOLD": 0.5,
                            "COMFORT_THRESHOLD": 0.51,
                            "TEA_DELAY": 300,
                            "COFFEE_LIMIT": 10,
                            "COFFEE_PER_DRINK": 1,
                            "ALCOHOL_DELAY": 900,
                            "ALCOHOL_PER_DRINK": 1
                        },
                        "FRICTION_BRAKE": {
                            "INITIAL": 29,
                            "MAX": 30,
                            "START_DELAY": 2.0,
                            "INCREASE_DELAY": 1.0,
                            "SENSITIVITY": "medium"
                        },
                        "KEEPNET": {
                            "CAPACITY": 100,
                            "FISH_DELAY": 0.0,
                            "GIFT_DELAY": 4.0,
                            "FULL_ACTION": "quit",
                            "WHITELIST": ["mackerel", "saithe", "herring", "squid", "scallop", "mussel"],
                            "BLACKLIST": [],
                            "TAGS": ["green", "yellow", "blue", "purple", "pink"]
                        },
                        "NOTIFICATION": {
                            "EMAIL": "",
                            "PASSWORD": "",
                            "SMTP_SERVER": "smtp.gmail.com",
                            "MIAO_CODE": "",
                            "DISCORD_WEBHOOK_URL": ""
                        },
                        "PAUSE": {
                            "DELAY": 1800,
                            "DURATION": 600
                        },
                        "PROFILE": {
                            "SPIN": {
                                "MODE": "spin",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 5.0,
                                "CAST_DELAY": 6.0,
                                "TIGHTEN_DURATION": 0.0,
                                "RETRIEVAL_DURATION": 0.0,
                                "RETRIEVAL_DELAY": 0.0,
                                "RETRIEVAL_TIMEOUT": 256.0,
                                "PRE_ACCELERATION": False,
                                "POST_ACCELERATION": "off",
                                "TYPE": "normal"
                            },
                            "SPIN_WITH_PAUSE": {
                                "MODE": "spin",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 5.0,
                                "CAST_DELAY": 6.0,
                                "TIGHTEN_DURATION": 1.0,
                                "RETRIEVAL_DURATION": 1.0,
                                "RETRIEVAL_DELAY": 3.0,
                                "RETRIEVAL_TIMEOUT": 256.0,
                                "PRE_ACCELERATION": False,
                                "POST_ACCELERATION": "off",
                                "TYPE": "pause"
                            },
                            "SPIN_WITH_LIFT": {
                                "MODE": "spin",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 5.0,
                                "CAST_DELAY": 6.0,
                                "TIGHTEN_DURATION": 0.0,
                                "RETRIEVAL_DURATION": 1.0,
                                "RETRIEVAL_DELAY": 1.0,
                                "RETRIEVAL_TIMEOUT": 256.0,
                                "PRE_ACCELERATION": False,
                                "POST_ACCELERATION": "off",
                                "TYPE": "lift"
                            },
                            "BOTTOM": {
                                "MODE": "bottom",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 5.0,
                                "CAST_DELAY": 4.0,
                                "POST_ACCELERATION": "off",
                                "CHECK_DELAY": 32.0,
                                "CHECK_MISS_LIMIT": 16,
                                "PUT_DOWN_DELAY": 0.0
                            },
                            "PIRK": {
                                "MODE": "pirk",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 1.0,
                                "CAST_DELAY": 4.0,
                                "SINK_TIMEOUT": 60.0,
                                "TIGHTEN_DURATION": 1.0,
                                "DEPTH_ADJUST_DELAY": 4.0,
                                "DEPTH_ADJUST_DURATION": 1.0,
                                "CTRL": False,
                                "SHIFT": False,
                                "PIRK_DURATION": 0.5,
                                "PIRK_DELAY": 2.0,
                                "PIRK_TIMEOUT": 32.0,
                                "PIRK_RETRIEVAL": False,
                                "HOOK_DELAY": 0.5,
                                "POST_ACCELERATION": "auto"
                            },
                            "PIRK_WITH_RETRIEVAL": {
                                "MODE": "pirk",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 1.0,
                                "CAST_DELAY": 4.0,
                                "SINK_TIMEOUT": 60.0,
                                "TIGHTEN_DURATION": 1.0,
                                "DEPTH_ADJUST_DELAY": 0.0,
                                "DEPTH_ADJUST_DURATION": 1.0,
                                "CTRL": False,
                                "SHIFT": False,
                                "PIRK_DURATION": 0.5,
                                "PIRK_DELAY": 2.0,
                                "PIRK_TIMEOUT": 32.0,
                                "PIRK_RETRIEVAL": True,
                                "HOOK_DELAY": 0.5,
                                "POST_ACCELERATION": "auto"
                            },
                            "WAKEY_RIG": {
                                "MODE": "pirk",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 1.0,
                                "CAST_DELAY": 4.0,
                                "SINK_TIMEOUT": 45.0,
                                "TIGHTEN_DURATION": 1.0,
                                "DEPTH_ADJUST_DELAY": 4.0,
                                "DEPTH_ADJUST_DURATION": 1.0,
                                "CTRL": True,
                                "SHIFT": False,
                                "PIRK_DURATION": 1.5,
                                "PIRK_DELAY": 4.0,
                                "PIRK_TIMEOUT": 32.0,
                                "PIRK_RETRIEVAL": False,
                                "HOOK_DELAY": 0.5,
                                "POST_ACCELERATION": "auto"
                            },
                            "ELEVATOR": {
                                "MODE": "elevator",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 1.0,
                                "CAST_DELAY": 4.0,
                                "SINK_TIMEOUT": 60.0,
                                "TIGHTEN_DURATION": 1.0,
                                "ELEVATE_DURATION": 4.0,
                                "ELEVATE_DELAY": 4.0,
                                "ELEVATE_TIMEOUT": 40.0,
                                "DROP": False,
                                "HOOK_DELAY": 0.5,
                                "POST_ACCELERATION": "auto"
                            },
                            "ELEVATOR_WITH_DROP": {
                                "MODE": "elevator",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 1.0,
                                "CAST_DELAY": 4.0,
                                "SINK_TIMEOUT": 60.0,
                                "TIGHTEN_DURATION": 1.0,
                                "ELEVATE_DURATION": 4.0,
                                "ELEVATE_DELAY": 4.0,
                                "ELEVATE_TIMEOUT": 40.0,
                                "DROP": True,
                                "HOOK_DELAY": 0.5,
                                "POST_ACCELERATION": "auto"
                            },
                            "TELESCOPIC": {
                                "MODE": "telescopic",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 5.0,
                                "CAST_DELAY": 4.0,
                                "FLOAT_SENSITIVITY": 0.68,
                                "CHECK_DELAY": 1.0,
                                "PULL_DELAY": 0.5,
                                "DRIFT_TIMEOUT": 16.0,
                                "CAMERA_SHAPE": "square"
                            },
                            "BOLOGNESE": {
                                "MODE": "bolognese",
                                "LAUNCH_OPTIONS": "",
                                "CAST_POWER_LEVEL": 5.0,
                                "CAST_DELAY": 4.0,
                                "FLOAT_SENSITIVITY": 0.68,
                                "CHECK_DELAY": 1.0,
                                "PULL_DELAY": 0.5,
                                "DRIFT_TIMEOUT": 32.0,
                                "CAMERA_SHAPE": "square",
                                "POST_ACCELERATION": "off"
                            }
                        }
                    }
                    
                def load_config(self, file_path: str) -> None:
                    """Load configuration from YAML file with enhanced error handling."""
                    try:
                        self.config_file_path = file_path
                        
                        if not os.path.exists(file_path):
                            raise FileNotFoundError(f"Configuration file not found: {file_path}")
                            
                        with open(file_path, 'r', encoding='utf-8') as f:
                            loaded_config = yaml.safe_load(f) or {}
                            
                        # Validate and merge with defaults
                        self.config = self._merge_with_defaults(loaded_config)
                        self._validate_config()
                        
                    except yaml.YAMLError as e:
                        raise Exception(f"Invalid YAML format in {file_path}: {str(e)}")
                    except Exception as e:
                        raise Exception(f"Failed to load configuration from {file_path}: {str(e)}")
                        
                def save_config(self, file_path: str) -> None:
                    """Save configuration to YAML file with backup."""
                    try:
                        # Create backup if file exists
                        if os.path.exists(file_path):
                            backup_path = f"{file_path}.backup"
                            try:
                                import shutil
                                shutil.copy2(file_path, backup_path)
                            except Exception as e:
                                print(f"Warning: Could not create backup: {e}")
                                
                        # Ensure directory exists
                        os.makedirs(os.path.dirname(file_path) if os.path.dirname(file_path) else ".", exist_ok=True)
                        
                        # Save configuration
                        with open(file_path, 'w', encoding='utf-8') as f:
                            yaml.dump(
                                self.config, 
                                f, 
                                default_flow_style=False,
                                allow_unicode=True, 
                                sort_keys=False,
                                indent=2,
                                width=120
                            )
                            
                        self.config_file_path = file_path
                        
                    except Exception as e:
                        raise Exception(f"Failed to save configuration to {file_path}: {str(e)}")
                        
                def _merge_with_defaults(self, loaded_config: dict) -> dict:
                    """Merge loaded config with defaults, preserving user settings."""
                    def merge_dict(default, loaded):
                        result = default.copy()
                        for key, value in loaded.items():
                            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                                result[key] = merge_dict(result[key], value)
                            else:
                                result[key] = value
                        return result
                        
                    return merge_dict(self.default_config, loaded_config)
                    
                def reset_to_defaults(self) -> None:
                    """Reset configuration to default values."""
                    self.config = copy.deepcopy(self.default_config)
                    
                def _validate_config(self) -> None:
                    """Comprehensive configuration validation."""
                    errors = []
                    
                    try:
                        # Validate script section
                        errors.extend(self._validate_script_section())
                        
                        # Validate key section
                        errors.extend(self._validate_key_section())
                        
                        # Validate stat section
                        errors.extend(self._validate_stat_section())
                        
                        # Validate profiles
                        errors.extend(self._validate_profiles())
                        
                        if errors:
                            print("Configuration validation warnings:")
                            for error in errors:
                                print(f"  - {error}")
                                
                    except Exception as e:
                        print(f"Configuration validation error: {e}")
                        
                def _validate_script_section(self) -> List[str]:
                    """Validate SCRIPT section."""
                    errors = []
                    script = self.config.get('SCRIPT', {})
                    defaults = self.default_config['SCRIPT']
                    
                    # Language validation
                    valid_languages = ['en', 'ru', 'zh-TW', 'zh-CN']
                    if script.get('LANGUAGE') not in valid_languages:
                        script['LANGUAGE'] = defaults['LANGUAGE']
                        errors.append(f"Invalid language, reset to {defaults['LANGUAGE']}")
                        
                    # Spool confidence range
                    spool_conf = script.get('SPOOL_CONFIDENCE', defaults['SPOOL_CONFIDENCE'])
                    if not isinstance(spool_conf, (int, float)) or not (0.0 <= spool_conf <= 1.0):
                        script['SPOOL_CONFIDENCE'] = defaults['SPOOL_CONFIDENCE']
                        errors.append("Invalid spool confidence, reset to default")
                        
                    # Random cast probability range
                    cast_prob = script.get('RANDOM_CAST_PROBABILITY', defaults['RANDOM_CAST_PROBABILITY'])
                    if not isinstance(cast_prob, (int, float)) or not (0.0 <= cast_prob <= 1.0):
                        script['RANDOM_CAST_PROBABILITY'] = defaults['RANDOM_CAST_PROBABILITY']
                        errors.append("Invalid random cast probability, reset to default")
                        
                    return errors
                    
                def _validate_key_section(self) -> List[str]:
                    """Validate KEY section."""
                    errors = []
                    keys = self.config.get('KEY', {})
                    defaults = self.default_config['KEY']
                    
                    # Validate bottom rods
                    bottom_rods = keys.get('BOTTOM_RODS', defaults['BOTTOM_RODS'])
                    if not isinstance(bottom_rods, list) or not all(isinstance(x, int) for x in bottom_rods):
                        keys['BOTTOM_RODS'] = defaults['BOTTOM_RODS']
                        errors.append("Invalid bottom rods configuration, reset to default")
                        
                    # Validate individual keys
                    for key_name in ['TEA', 'CARROT', 'COFFEE', 'DIGGING_TOOL', 'ALCOHOL', 'MAIN_ROD', 'SPOD_ROD']:
                        value = keys.get(key_name, defaults[key_name])
                        if not isinstance(value, int) or value < -1:
                            keys[key_name] = defaults[key_name]
                            errors.append(f"Invalid {key_name} key, reset to default")
                            
                    return errors
                    
                def _validate_stat_section(self) -> List[str]:
                    """Validate STAT section."""
                    errors = []
                    stat = self.config.get('STAT', {})
                    defaults = self.default_config['STAT']
                    
                    # Validate threshold ranges (0.0 to 1.0)
                    thresholds = ['ENERGY_THRESHOLD', 'HUNGER_THRESHOLD', 'COMFORT_THRESHOLD']
                    for threshold in thresholds:
                        value = stat.get(threshold, defaults[threshold])
                        if not isinstance(value, (int, float)) or not (0.0 <= value <= 1.0):
                            stat[threshold] = defaults[threshold]
                            errors.append(f"Invalid {threshold}, reset to default")
                            
                    # Validate delays (positive integers)
                    delays = ['TEA_DELAY', 'ALCOHOL_DELAY']
                    for delay in delays:
                        value = stat.get(delay, defaults[delay])
                        if not isinstance(value, int) or value < 0:
                            stat[delay] = defaults[delay]
                            errors.append(f"Invalid {delay}, reset to default")
                            
                    return errors
                    
                def _validate_profiles(self) -> List[str]:
                    """Validate PROFILE section."""
                    errors = []
                    profiles = self.config.get('PROFILE', {})
                    
                    valid_modes = ['spin', 'bottom', 'pirk', 'elevator', 'telescopic', 'bolognese']
                    valid_acceleration = ['on', 'off', 'auto']
                    valid_spin_types = ['normal', 'pause', 'lift']
                    
                    for profile_name, profile_config in profiles.items():
                        if not isinstance(profile_config, dict):
                            continue
                            
                        # Validate mode
                        mode = profile_config.get('MODE')
                        if mode not in valid_modes:
                            errors.append(f"Profile {profile_name}: Invalid mode '{mode}'")
                            
                        # Validate cast power level
                        cast_power = profile_config.get('CAST_POWER_LEVEL')
                        if isinstance(cast_power, (int, float)) and not (1.0 <= cast_power <= 5.0):
                            errors.append(f"Profile {profile_name}: Cast power level should be 1.0-5.0")
                            
                        # Validate POST_ACCELERATION
                        post_acc = profile_config.get('POST_ACCELERATION')
                        if post_acc and post_acc not in valid_acceleration:
                            errors.append(f"Profile {profile_name}: Invalid POST_ACCELERATION value")
                            
                        # Validate spin-specific settings
                        if mode == 'spin':
                            spin_type = profile_config.get('TYPE')
                            if spin_type and spin_type not in valid_spin_types:
                                errors.append(f"Profile {profile_name}: Invalid spin TYPE value")
                                
                    return errors
                    
                def get_profile_list(self) -> List[str]:
                    """Get list of available profiles."""
                    return list(self.config.get('PROFILE', {}).keys())
                    
                def get_profile_config(self, profile_name: str) -> dict:
                    """Get configuration for specific profile."""
                    profiles = self.config.get('PROFILE', {})
                    return profiles.get(profile_name, {}).copy()
                    
                def set_profile_config(self, profile_name: str, profile_config: dict) -> None:
                    """Set configuration for specific profile."""
                    if 'PROFILE' not in self.config:
                        self.config['PROFILE'] = {}
                    self.config['PROFILE'][profile_name] = profile_config.copy()
                    
                def validate_launch_options(self, options: str) -> Tuple[bool, List[str]]:
                    """Validate launch options string and return invalid options."""
                    valid_options = {
                        # Boolean flags
                        '-R', '--rainbow', '-t', '--tag', '-c', '--coffee', '-a', '--alcohol',
                        '-r', '--refill', '-H', '--harvest', '-L', '--lure', '-m', '--mouse',
                        '-P', '--pause', '-RC', '--random-cast', '-SC', '--skip-cast',
                        '-l', '--lift', '-e', '--electro', '-FB', '--friction-brake',
                        '-GR', '--gear-ratio', '-b', '--bite', '-s', '--screenshot',
                        '-d', '--data', '-E', '--email', '-M', '--miaotixing',
                        '-D', '--discord', '-S', '--shutdown', '-SO', '--signout',
                        '-SR', '--spod-rod', '-DM', '--dry-mix', '-GB', '--groundbait',
                        '-PVA', '--pva',
                        # Options with arguments
                        '-p', '--pid', '-N', '--pname', '-n', '--fishes-in-keepnet',
                        '-BT', '--boat-ticket', '-T', '--trolling', '-BL', '--broken-lure'
                    }
                    
                    # Options that take arguments
                    options_with_args = {
                        '-p', '--pid', '-N', '--pname', '-n', '--fishes-in-keepnet',
                        '-BT', '--boat-ticket', '-T', '--trolling', '-BL', '--broken-lure'
                    }
                    
                    if not options.strip():
                        return True, []
                        
                    try:
                        import shlex
                        parsed_options = shlex.split(options)
                    except ValueError:
                        parsed_options = options.split()
                        
                    invalid_options = []
                    i = 0
                    
                    while i < len(parsed_options):
                        option = parsed_options[i]
                        
                        if option.startswith('-'):
                            if option in valid_options:
                                # If this option takes an argument, skip the next item
                                if option in options_with_args and i + 1 < len(parsed_options):
                                    i += 1  # Skip the argument
                            else:
                                invalid_options.append(option)
                        else:
                            # This might be an argument to a previous option or an invalid standalone argument
                            if i == 0 or not parsed_options[i-1].startswith('-'):
                                invalid_options.append(option)
                                
                        i += 1
                        
                    return len(invalid_options) == 0, invalid_options
                    
                def export_config(self, file_path: str) -> None:
                    """Export current configuration to specified file."""
                    self.save_config(file_path)
                    
                def import_config(self, file_path: str) -> None:
                    """Import configuration from specified file."""
                    self.load_config(file_path)
                    
                def get_config_summary(self) -> dict:
                    """Get a summary of current configuration."""
                    summary = {
                        'version': self.config.get('VERSION', 'Unknown'),
                        'language': self.config.get('SCRIPT', {}).get('LANGUAGE', 'Unknown'),
                        'profiles_count': len(self.config.get('PROFILE', {})),
                        'profiles': list(self.config.get('PROFILE', {}).keys()),
                        'email_configured': bool(self.config.get('NOTIFICATION', {}).get('EMAIL')),
                        'discord_configured': bool(self.config.get('NOTIFICATION', {}).get('DISCORD_WEBHOOK_URL')),
                        'config_file': self.config_file_path or 'Not saved'
                    }
                    return summary
        üìÑ main_window.py
            """
            PyQt6 GUI for Russian Fishing 4 Script
            Main window implementation with tabbed interface
            """
            
            import sys
            import os
            import subprocess
            from pathlib import Path
            from datetime import datetime
            from ui_theme import get_light_theme, get_dark_theme
            from PyQt6.QtWidgets import (
                QApplication, QMainWindow, QTabWidget, QVBoxLayout, QHBoxLayout,
                QWidget, QLabel, QPushButton, QComboBox, QSpinBox, QDoubleSpinBox,
                QCheckBox, QLineEdit, QTextEdit, QGroupBox, QGridLayout, QScrollArea,
                QMessageBox, QFileDialog, QSplitter, QProgressBar, QStatusBar,
                QFrame
            )
            from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer, QSettings
            from PyQt6.QtGui import QFont, QIcon, QPixmap, QTextCursor
            
            from config_manager import ConfigManager
            from script_runner import ScriptRunner
            from translations import Translations
            
            
            class MainWindow(QMainWindow):
                """Main GUI window for Russian Fishing 4 Script."""
                
                def __init__(self):
                    super().__init__()
                    self.config_manager = ConfigManager()
                    self.script_runner = ScriptRunner()
                    self.translations = Translations()
                    
                    self.current_language = "en"
                    self.current_theme = "light"
                    self.script_process = None
                    self.is_script_running = False
                    
                    # Settings –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –æ–∫–Ω–∞
                    self.settings = QSettings("RF4S", "GUI")
                    
                    self.init_ui()
                    self.apply_theme()
                    self.load_config()
                    self.connect_signals()
                    self.load_window_state()
                    
                def apply_theme(self):
                    """Apply selected theme to the application."""
                    if self.current_theme == "light":
                        self.setStyleSheet(get_light_theme())
                    else:
                        self.setStyleSheet(get_dark_theme())
                    
                def init_ui(self):
                    """Initialize the user interface."""
                    self.setWindowTitle("Russian Fishing 4 Script GUI v1.0")
                    self.setGeometry(100, 100, 1400, 900)
                    
                    # Central widget with splitter
                    central_widget = QWidget()
                    self.setCentralWidget(central_widget)
                    
                    layout = QVBoxLayout(central_widget)
                    layout.setContentsMargins(5, 5, 5, 5)
                    
                    # Top toolbar
                    self.create_toolbar(layout)
                    
                    # Add separator
                    separator = QFrame()
                    separator.setFrameShape(QFrame.Shape.HLine)
                    separator.setFrameShadow(QFrame.Shadow.Sunken)
                    layout.addWidget(separator)
                    
                    # Main content splitter
                    splitter = QSplitter(Qt.Orientation.Horizontal)
                    layout.addWidget(splitter)
                    
                    # Configuration tabs
                    self.tab_widget = QTabWidget()
                    splitter.addWidget(self.tab_widget)
                    
                    self.create_tabs()
                    
                    # Right panel for script control and logs
                    self.create_control_panel(splitter)
                    
                    # Status bar
                    self.create_status_bar()
                    
                    # Set splitter proportions
                    splitter.setSizes([900, 500])
                    
                def create_toolbar(self, layout):
                    """Create top toolbar with language and file controls."""
                    toolbar_widget = QWidget()
                    toolbar_layout = QHBoxLayout(toolbar_widget)
                    toolbar_layout.setContentsMargins(10, 5, 10, 5)
                    
                    # Language selection
                    lang_label = QLabel("Language:")
                    lang_label.setStyleSheet("font-weight: bold;")
                    self.language_combo = QComboBox()
                    self.language_combo.addItems(["English", "–†—É—Å—Å–∫–∏–π"])
                    self.language_combo.setCurrentText("English")
                    self.language_combo.currentTextChanged.connect(self.change_language)
                    
                    # Theme selector
                    theme_label = QLabel("Theme:")
                    theme_label.setStyleSheet("font-weight: bold;")
                    self.theme_combo = QComboBox()
                    self.theme_combo.addItems(["Light", "Dark"])
                    self.theme_combo.setCurrentText("Light")
                    self.theme_combo.currentTextChanged.connect(self.change_theme)
            
                    toolbar_layout.addWidget(theme_label)
                    toolbar_layout.addWidget(self.theme_combo)
                    toolbar_layout.addWidget(self.create_separator())
                    
                    toolbar_layout.addWidget(lang_label)
                    toolbar_layout.addWidget(self.language_combo)
                    toolbar_layout.addWidget(self.create_separator())
                    
                    # File operations
                    self.load_button = QPushButton("üìÅ Load Config")
                    self.save_button = QPushButton("üíæ Save Config")
                    self.reset_button = QPushButton("üîÑ Reset to Default")
                    
                    # Style buttons
                    button_style = """
                    QPushButton {
                        padding: 5px 10px;
                        border: 1px solid #ccc;
                        border-radius: 3px;
                        background-color: #f0f0f0;
                    }
                    QPushButton:hover {
                        background-color: #e0e0e0;
                    }
                    QPushButton:pressed {
                        background-color: #d0d0d0;
                    }
                    """
                    
                    for btn in [self.load_button, self.save_button, self.reset_button]:
                        btn.setStyleSheet(button_style)
                    
                    self.load_button.clicked.connect(self.load_config_file)
                    self.save_button.clicked.connect(self.save_config_file)
                    self.reset_button.clicked.connect(self.reset_config)
                    
                    toolbar_layout.addStretch()
                    toolbar_layout.addWidget(self.load_button)
                    toolbar_layout.addWidget(self.save_button)
                    toolbar_layout.addWidget(self.reset_button)
                    
                    layout.addWidget(toolbar_widget)
                    
                def change_theme(self, theme_name):
                    """Change application theme."""
                    self.current_theme = "light" if theme_name == "Light" else "dark"
                    self.apply_theme()
                    self.update_status(f"Theme changed to {theme_name}")
                    
                def create_separator(self):
                    """Create vertical separator."""
                    separator = QFrame()
                    separator.setFrameShape(QFrame.Shape.VLine)
                    separator.setFrameShadow(QFrame.Shadow.Sunken)
                    return separator
                    
                def create_status_bar(self):
                    """Create status bar with additional info."""
                    self.status_bar = self.statusBar()
                    
                    # Status label
                    self.status_label = QLabel("Ready")
                    self.status_bar.addWidget(self.status_label)
                    
                    # Config file indicator
                    self.config_indicator = QLabel("No config loaded")
                    self.config_indicator.setStyleSheet("color: orange;")
                    self.status_bar.addPermanentWidget(self.config_indicator)
                    
                    # Script status indicator
                    self.script_status = QLabel("Script: Stopped")
                    self.script_status.setStyleSheet("color: red;")
                    self.status_bar.addPermanentWidget(self.script_status)
                    
                def update_status(self, message):
                    """Update status bar message."""
                    self.status_label.setText(f"[{datetime.now().strftime('%H:%M:%S')}] {message}")
                    
                def create_tabs(self):
                    """Create configuration tabs."""
                    # Script Settings Tab
                    self.script_tab = self.create_script_tab()
                    self.tab_widget.addTab(self.script_tab, "‚öôÔ∏è Script Settings")
                    
                    # Key Bindings Tab
                    self.keys_tab = self.create_keys_tab()
                    self.tab_widget.addTab(self.keys_tab, "üéÆ Key Bindings")
                    
                    # Player Stats Tab
                    self.stats_tab = self.create_stats_tab()
                    self.tab_widget.addTab(self.stats_tab, "üìä Player Stats")
                    
                    # Profiles Tab
                    self.profiles_tab = self.create_profiles_tab()
                    self.tab_widget.addTab(self.profiles_tab, "üé£ Fishing Profiles")
                    
                    # Friction Brake Tab
                    self.friction_tab = self.create_friction_tab()
                    self.tab_widget.addTab(self.friction_tab, "üîß Friction Brake")
                    
                    # Keepnet Tab
                    self.keepnet_tab = self.create_keepnet_tab()
                    self.tab_widget.addTab(self.keepnet_tab, "üóÉÔ∏è Keepnet")
                    
                    # Notifications Tab
                    self.notifications_tab = self.create_notifications_tab()
                    self.tab_widget.addTab(self.notifications_tab, "üìß Notifications")
                    
                def create_script_tab(self):
                    """Create script settings tab."""
                    widget = QWidget()
                    layout = QVBoxLayout(widget)
                    
                    # General Settings Group
                    general_group = QGroupBox("General Settings")
                    general_layout = QGridLayout(general_group)
                    
                    # Language
                    general_layout.addWidget(QLabel("Script Language:"), 0, 0)
                    self.script_language_combo = QComboBox()
                    self.script_language_combo.addItems(["en", "ru", "zh-TW", "zh-CN"])
                    self.script_language_combo.setToolTip("Language for script messages and interface")
                    general_layout.addWidget(self.script_language_combo, 0, 1)
                    
                    # Launch Options
                    general_layout.addWidget(QLabel("Default Launch Options:"), 1, 0)
                    self.launch_options_edit = QLineEdit()
                    self.launch_options_edit.setPlaceholderText("e.g., -r -c -H")
                    self.launch_options_edit.setToolTip("Default command line options (see documentation)")
                    general_layout.addWidget(self.launch_options_edit, 1, 1)
                    
                    # Detection Settings Group
                    detection_group = QGroupBox("Detection Settings")
                    detection_layout = QGridLayout(detection_group)
                    
                    self.smtp_verification_cb = QCheckBox("SMTP Verification")
                    self.smtp_verification_cb.setToolTip("Enable SMTP verification for email notifications")
                    
                    self.image_verification_cb = QCheckBox("Image Verification")
                    self.image_verification_cb.setToolTip("Enable image-based verification")
                    
                    self.snag_detection_cb = QCheckBox("Snag Detection")
                    self.snag_detection_cb.setToolTip("Detect when fishing line is snagged")
                    
                    self.spooling_detection_cb = QCheckBox("Spooling Detection")
                    self.spooling_detection_cb.setToolTip("Detect spooling issues with fishing reel")
                    
                    self.random_rod_selection_cb = QCheckBox("Random Rod Selection")
                    self.random_rod_selection_cb.setToolTip("Randomly select rods in bottom fishing mode")
                    
                    detection_layout.addWidget(self.smtp_verification_cb, 0, 0)
                    detection_layout.addWidget(self.image_verification_cb, 0, 1)
                    detection_layout.addWidget(self.snag_detection_cb, 1, 0)
                    detection_layout.addWidget(self.spooling_detection_cb, 1, 1)
                    detection_layout.addWidget(self.random_rod_selection_cb, 2, 0)
                    
                    # Spool Confidence
                    detection_layout.addWidget(QLabel("Spool Confidence:"), 3, 0)
                    self.spool_confidence_spin = QDoubleSpinBox()
                    self.spool_confidence_spin.setRange(0.0, 1.0)
                    self.spool_confidence_spin.setSingleStep(0.01)
                    self.spool_confidence_spin.setValue(0.98)
                    self.spool_confidence_spin.setToolTip("Confidence threshold for spooling detection (0.0-1.0)")
                    detection_layout.addWidget(self.spool_confidence_spin, 3, 1)
                    
                    # Advanced Settings Group
                    advanced_group = QGroupBox("Advanced Settings")
                    advanced_layout = QGridLayout(advanced_group)
                    
                    # Spod Rod Recast Delay
                    advanced_layout.addWidget(QLabel("Spod Rod Recast Delay (sec):"), 0, 0)
                    self.spod_recast_delay_spin = QSpinBox()
                    self.spod_recast_delay_spin.setRange(60, 7200)
                    self.spod_recast_delay_spin.setValue(1800)
                    self.spod_recast_delay_spin.setToolTip("Delay before recasting spod rod (seconds)")
                    advanced_layout.addWidget(self.spod_recast_delay_spin, 0, 1)
                    
                    # Lure Change Delay
                    advanced_layout.addWidget(QLabel("Lure Change Delay (sec):"), 1, 0)
                    self.lure_change_delay_spin = QSpinBox()
                    self.lure_change_delay_spin.setRange(60, 7200)
                    self.lure_change_delay_spin.setValue(1800)
                    self.lure_change_delay_spin.setToolTip("Delay before changing lure randomly (seconds)")
                    advanced_layout.addWidget(self.lure_change_delay_spin, 1, 1)
                    
                    # Random Cast Probability
                    advanced_layout.addWidget(QLabel("Random Cast Probability:"), 2, 0)
                    self.random_cast_prob_spin = QDoubleSpinBox()
                    self.random_cast_prob_spin.setRange(0.0, 1.0)
                    self.random_cast_prob_spin.setSingleStep(0.01)
                    self.random_cast_prob_spin.setValue(0.25)
                    self.random_cast_prob_spin.setToolTip("Probability of adding redundant rod cast (0.0-1.0)")
                    advanced_layout.addWidget(self.random_cast_prob_spin, 2, 1)
                    
                    layout.addWidget(general_group)
                    layout.addWidget(detection_group)
                    layout.addWidget(advanced_group)
                    layout.addStretch()
                    
                    return widget
                    
                def create_keys_tab(self):
                    """Create key bindings tab."""
                    widget = QWidget()
                    layout = QVBoxLayout(widget)
                    
                    # Info label
                    info_label = QLabel("Configure key bindings for game controls. Use -1 to open selection menu.")
                    info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                    layout.addWidget(info_label)
                    
                    scroll = QScrollArea()
                    scroll_widget = QWidget()
                    scroll_layout = QGridLayout(scroll_widget)
                    
                    # Key bindings
                    self.key_widgets = {}
                    key_settings = [
                        ("TEA", "Tea Key", "Key for tea consumption (-1 for menu)"),
                        ("CARROT", "Carrot Key", "Key for carrot consumption (-1 for menu)"),
                        ("COFFEE", "Coffee Key", "Key for coffee consumption (-1 for menu)"),
                        ("DIGGING_TOOL", "Digging Tool Key", "Key for digging tool"),
                        ("ALCOHOL", "Alcohol Key", "Key for alcohol consumption"),
                        ("MAIN_ROD", "Main Rod Key", "Key for main fishing rod"),
                        ("SPOD_ROD", "Spod Rod Key", "Key for spod rod"),
                    ]
                    
                    row = 0
                    for key, label, tooltip in key_settings:
                        label_widget = QLabel(f"{label}:")
                        label_widget.setMinimumWidth(150)
                        scroll_layout.addWidget(label_widget, row, 0)
                        
                        key_edit = QLineEdit()
                        key_edit.setToolTip(tooltip)
                        key_edit.setPlaceholderText("-1 for menu, or key number")
                        key_edit.setMaximumWidth(100)
                        self.key_widgets[key] = key_edit
                        scroll_layout.addWidget(key_edit, row, 1)
                        
                        # Add tooltip label
                        tooltip_label = QLabel(tooltip)
                        tooltip_label.setStyleSheet("color: #666; font-size: 10px;")
                        scroll_layout.addWidget(tooltip_label, row, 2)
                        
                        row += 1
                        
                    # Bottom rods (special handling)
                    scroll_layout.addWidget(QLabel("Bottom Rods:"), row, 0)
                    self.bottom_rods_edit = QLineEdit()
                    self.bottom_rods_edit.setToolTip("Comma-separated list of rod keys (e.g., 1,2,3)")
                    self.bottom_rods_edit.setPlaceholderText("1,2,3")
                    self.bottom_rods_edit.setMaximumWidth(100)
                    scroll_layout.addWidget(self.bottom_rods_edit, row, 1)
                    
                    tooltip_label = QLabel("Comma-separated rod keys for bottom fishing")
                    tooltip_label.setStyleSheet("color: #666; font-size: 10px;")
                    scroll_layout.addWidget(tooltip_label, row, 2)
                    
                    # Quit key
                    row += 1
                    scroll_layout.addWidget(QLabel("Quit Key:"), row, 0)
                    self.quit_key_edit = QLineEdit()
                    self.quit_key_edit.setToolTip("Key combination to stop script")
                    self.quit_key_edit.setPlaceholderText("CTRL-C")
                    self.quit_key_edit.setMaximumWidth(100)
                    scroll_layout.addWidget(self.quit_key_edit, row, 1)
                    
                    tooltip_label = QLabel("Key combination to stop the script")
                    tooltip_label.setStyleSheet("color: #666; font-size: 10px;")
                    scroll_layout.addWidget(tooltip_label, row, 2)
                    
                    scroll_layout.setColumnStretch(2, 1)
                    scroll.setWidget(scroll_widget)
                    layout.addWidget(scroll)
                    
                    return widget
                    
                def create_stats_tab(self):
                    """Create player stats tab."""
                    widget = QWidget()
                    layout = QVBoxLayout(widget)
                    
                    # Info label
                    info_label = QLabel("Configure thresholds and consumption settings for player stats.")
                    info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                    layout.addWidget(info_label)
                    
                    # Thresholds Group
                    thresholds_group = QGroupBox("Stat Thresholds (0.0 - 1.0)")
                    thresholds_layout = QGridLayout(thresholds_group)
                    
                    # Energy Threshold
                    thresholds_layout.addWidget(QLabel("Energy Threshold:"), 0, 0)
                    self.energy_threshold_spin = QDoubleSpinBox()
                    self.energy_threshold_spin.setRange(0.0, 1.0)
                    self.energy_threshold_spin.setSingleStep(0.01)
                    self.energy_threshold_spin.setValue(0.74)
                    self.energy_threshold_spin.setToolTip("Minimum energy level before drinking coffee")
                    thresholds_layout.addWidget(self.energy_threshold_spin, 0, 1)
                    
                    # Hunger Threshold
                    thresholds_layout.addWidget(QLabel("Hunger Threshold:"), 1, 0)
                    self.hunger_threshold_spin = QDoubleSpinBox()
                    self.hunger_threshold_spin.setRange(0.0, 1.0)
                    self.hunger_threshold_spin.setSingleStep(0.01)
                    self.hunger_threshold_spin.setValue(0.5)
                    self.hunger_threshold_spin.setToolTip("Minimum hunger level before consuming carrot")
                    thresholds_layout.addWidget(self.hunger_threshold_spin, 1, 1)
                    
                    # Comfort Threshold
                    thresholds_layout.addWidget(QLabel("Comfort Threshold:"), 2, 0)
                    self.comfort_threshold_spin = QDoubleSpinBox()
                    self.comfort_threshold_spin.setRange(0.0, 1.0)
                    self.comfort_threshold_spin.setSingleStep(0.01)
                    self.comfort_threshold_spin.setValue(0.51)
                    self.comfort_threshold_spin.setToolTip("Minimum comfort level before consuming tea")
                    thresholds_layout.addWidget(self.comfort_threshold_spin, 2, 1)
                    
                    # Consumption Settings Group
                    consumption_group = QGroupBox("Consumption Settings")
                    consumption_layout = QGridLayout(consumption_group)
                    
                    # Tea Delay
                    consumption_layout.addWidget(QLabel("Tea Delay (seconds):"), 0, 0)
                    self.tea_delay_spin = QSpinBox()
                    self.tea_delay_spin.setRange(0, 3600)
                    self.tea_delay_spin.setValue(300)
                    self.tea_delay_spin.setToolTip("Delay between tea drinks")
                    consumption_layout.addWidget(self.tea_delay_spin, 0, 1)
                    
                    # Coffee Limit
                    consumption_layout.addWidget(QLabel("Coffee Limit:"), 1, 0)
                    self.coffee_limit_spin = QSpinBox()
                    self.coffee_limit_spin.setRange(1, 50)
                    self.coffee_limit_spin.setValue(10)
                    self.coffee_limit_spin.setToolTip("Maximum coffee drinks per fish fight")
                    consumption_layout.addWidget(self.coffee_limit_spin, 1, 1)
                    
                    # Coffee Per Drink
                    consumption_layout.addWidget(QLabel("Coffee Per Drink:"), 2, 0)
                    self.coffee_per_drink_spin = QSpinBox()
                    self.coffee_per_drink_spin.setRange(1, 10)
                    self.coffee_per_drink_spin.setValue(1)
                    self.coffee_per_drink_spin.setToolTip("Amount of coffee consumed per drink")
                    consumption_layout.addWidget(self.coffee_per_drink_spin, 2, 1)
                    
                    # Alcohol settings
                    consumption_layout.addWidget(QLabel("Alcohol Delay (seconds):"), 3, 0)
                    self.alcohol_delay_spin = QSpinBox()
                    self.alcohol_delay_spin.setRange(0, 3600)
                    self.alcohol_delay_spin.setValue(900)
                    self.alcohol_delay_spin.setToolTip("Delay between alcohol drinks")
                    consumption_layout.addWidget(self.alcohol_delay_spin, 3, 1)
                    
                    consumption_layout.addWidget(QLabel("Alcohol Per Drink:"), 4, 0)
                    self.alcohol_per_drink_spin = QSpinBox()
                    self.alcohol_per_drink_spin.setRange(1, 10)
                    self.alcohol_per_drink_spin.setValue(1)
                    self.alcohol_per_drink_spin.setToolTip("Amount of alcohol consumed per drink")
                    consumption_layout.addWidget(self.alcohol_per_drink_spin, 4, 1)
                    
                    layout.addWidget(thresholds_group)
                    layout.addWidget(consumption_group)
                    layout.addStretch()
                    
                    return widget
                    
                def create_profiles_tab(self):
                    """Create fishing profiles tab."""
                    widget = QWidget()
                    layout = QVBoxLayout(widget)
                    
                    # Profile Selection
                    profile_selection_group = QGroupBox("Profile Selection")
                    profile_layout = QHBoxLayout(profile_selection_group)
                    
                    profile_layout.addWidget(QLabel("Current Profile:"))
                    
                    self.profile_combo = QComboBox()
                    self.profile_combo.addItems([
                        "SPIN", "SPIN_WITH_PAUSE", "SPIN_WITH_LIFT", "BOTTOM",
                        "PIRK", "PIRK_WITH_RETRIEVAL", "WAKEY_RIG",
                        "ELEVATOR", "ELEVATOR_WITH_DROP", "TELESCOPIC", "BOLOGNESE"
                    ])
                    self.profile_combo.currentTextChanged.connect(self.load_profile_settings)
                    profile_layout.addWidget(self.profile_combo)
                    
                    # Add profile management buttons
                    self.copy_profile_btn = QPushButton("Copy Profile")
                    self.delete_profile_btn = QPushButton("Delete Profile")
                    self.copy_profile_btn.clicked.connect(self.copy_current_profile)
                    self.delete_profile_btn.clicked.connect(self.delete_current_profile)
                    
                    profile_layout.addStretch()
                    profile_layout.addWidget(self.copy_profile_btn)
                    profile_layout.addWidget(self.delete_profile_btn)
                    
                    layout.addWidget(profile_selection_group)
                    
                    # Profile Settings
                    self.profile_scroll = QScrollArea()
                    self.profile_widget = QWidget()
                    self.profile_layout = QGridLayout(self.profile_widget)
                    
                    self.create_profile_widgets()
                    
                    self.profile_scroll.setWidget(self.profile_widget)
                    layout.addWidget(self.profile_scroll)
                    
                    return widget
                    
                def create_profile_widgets(self):
                    """Create widgets for profile settings."""
                    self.profile_widgets = {}
                    
                    # Clear existing widgets
                    for i in reversed(range(self.profile_layout.count())):
                        self.profile_layout.itemAt(i).widget().setParent(None)
                    
                    # Common profile settings with descriptions
                    settings = [
                        ("MODE", "Fishing Mode", "str", ["spin", "bottom", "pirk", "elevator", "telescopic", "bolognese"], "Type of fishing mode"),
                        ("LAUNCH_OPTIONS", "Launch Options", "str", None, "Profile-specific launch options (overrides global)"),
                        ("CAST_POWER_LEVEL", "Cast Power Level", "float", (1.0, 5.0, 0.1), "Power level for casting (1-5)"),
                        ("CAST_DELAY", "Cast Delay", "float", (0.0, 30.0, 0.1), "Delay after casting before lure sinks"),
                        ("POST_ACCELERATION", "Post Acceleration", "str", ["on", "off", "auto"], "Hold Shift key during fish fight"),
                    ]
                    
                    # Add mode-specific settings based on current profile
                    current_profile = self.profile_combo.currentText()
                    if "SPIN" in current_profile:
                        settings.extend([
                            ("TIGHTEN_DURATION", "Tighten Duration", "float", (0.0, 10.0, 0.1), "Duration to tighten fishing line after casting"),
                            ("RETRIEVAL_DURATION", "Retrieval Duration", "float", (0.0, 10.0, 0.1), "Duration of retrieving the line"),
                            ("RETRIEVAL_DELAY", "Retrieval Delay", "float", (0.0, 10.0, 0.1), "Delay after retrieving the line"),
                            ("RETRIEVAL_TIMEOUT", "Retrieval Timeout", "float", (10.0, 500.0, 1.0), "Timeout for retrieving with pause/lift"),
                            ("PRE_ACCELERATION", "Pre Acceleration", "bool", None, "Hold Shift key when performing special techniques"),
                            ("TYPE", "Technique Type", "str", ["normal", "pause", "lift"], "Type of special spin fishing technique"),
                        ])
                    elif current_profile == "BOTTOM":
                        settings.extend([
                            ("CHECK_DELAY", "Check Delay", "float", (1.0, 60.0, 0.1), "Delay before checking fish bite on next rod"),
                            ("CHECK_MISS_LIMIT", "Check Miss Limit", "int", (1, 50), "Maximum misses before recasting rod"),
                            ("PUT_DOWN_DELAY", "Put Down Delay", "float", (0.0, 10.0, 0.1), "Delay before checking if fish is hooked again"),
                        ])
                    elif "PIRK" in current_profile:
                        settings.extend([
                            ("SINK_TIMEOUT", "Sink Timeout", "float", (10.0, 120.0, 1.0), "Maximum time allowed for sinking"),
                            ("TIGHTEN_DURATION", "Tighten Duration", "float", (0.0, 5.0, 0.1), "Duration to tighten line after sinking"),
                            ("PIRK_DURATION", "Pirk Duration", "float", (0.0, 5.0, 0.1), "Duration of lifting the rod"),
                            ("PIRK_DELAY", "Pirk Delay", "float", (0.0, 10.0, 0.1), "Delay after lifting the rod"),
                            ("PIRK_TIMEOUT", "Pirk Timeout", "float", (10.0, 120.0, 1.0), "Timeout for pirking session"),
                            ("CTRL", "Hold Ctrl", "bool", None, "Hold Ctrl key during pirking"),
                            ("SHIFT", "Hold Shift", "bool", None, "Hold Shift key during pirking"),
                        ])
                    
                    row = 0
                    for setting in settings:
                        key, label, data_type, options, description = setting
                        
                        # Label
                        label_widget = QLabel(f"{label}:")
                        label_widget.setMinimumWidth(150)
                        self.profile_layout.addWidget(label_widget, row, 0)
                        
                        # Widget
                        if data_type == "str" and isinstance(options, list):
                            widget = QComboBox()
                            widget.addItems(options)
                        elif data_type == "str":
                            widget = QLineEdit()
                            widget.setPlaceholderText("Enter value...")
                        elif data_type == "float":
                            widget = QDoubleSpinBox()
                            if options:
                                widget.setRange(options[0], options[1])
                                widget.setSingleStep(options[2])
                            widget.setValue(0.0)
                        elif data_type == "int":
                            widget = QSpinBox()
                            if options:
                                widget.setRange(options[0], options[1])
                            widget.setValue(0)
                        elif data_type == "bool":
                            widget = QCheckBox()
                        else:
                            widget = QLineEdit()
                            
                        widget.setToolTip(description)
                        widget.setMaximumWidth(200)
                        self.profile_widgets[key] = widget
                        self.profile_layout.addWidget(widget, row, 1)
                        
                        # Description
                        desc_label = QLabel(description)
                        desc_label.setStyleSheet("color: #666; font-size: 10px;")
                        desc_label.setWordWrap(True)
                        self.profile_layout.addWidget(desc_label, row, 2)
                        
                        row += 1
                        
                    self.profile_layout.setColumnStretch(2, 1)
                    
                def create_friction_tab(self):
                    """Create friction brake tab."""
                    widget = QWidget()
                    layout = QVBoxLayout(widget)
                    
                    # Info
                    info_label = QLabel("Configure automatic friction brake adjustment (use -FB flag to enable).")
                    info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                    layout.addWidget(info_label)
                    
                    friction_group = QGroupBox("Friction Brake Settings")
                    friction_layout = QGridLayout(friction_group)
                    
                    # Initial Value
                    friction_layout.addWidget(QLabel("Initial Value:"), 0, 0)
                    self.friction_initial_spin = QSpinBox()
                    self.friction_initial_spin.setRange(0, 50)
                    self.friction_initial_spin.setValue(29)
                    self.friction_initial_spin.setToolTip("Initial friction brake value")
                    friction_layout.addWidget(self.friction_initial_spin, 0, 1)
                    
                    # Max Value
                    friction_layout.addWidget(QLabel("Max Value:"), 1, 0)
                    self.friction_max_spin = QSpinBox()
                    self.friction_max_spin.setRange(0, 50)
                    self.friction_max_spin.setValue(30)
                    self.friction_max_spin.setToolTip("Maximum friction brake value")
                    friction_layout.addWidget(self.friction_max_spin, 1, 1)
                    
                    # Start Delay
                    friction_layout.addWidget(QLabel("Start Delay (sec):"), 2, 0)
                    self.friction_start_delay_spin = QDoubleSpinBox()
                    self.friction_start_delay_spin.setRange(0.0, 10.0)
                    self.friction_start_delay_spin.setSingleStep(0.1)
                    self.friction_start_delay_spin.setValue(2.0)
                    self.friction_start_delay_spin.setToolTip("Delay before starting to adjust friction brake after fish is hooked")
                    friction_layout.addWidget(self.friction_start_delay_spin, 2, 1)
                    
                    # Increase Delay
                    friction_layout.addWidget(QLabel("Increase Delay (sec):"), 3, 0)
                    self.friction_increase_delay_spin = QDoubleSpinBox()
                    self.friction_increase_delay_spin.setRange(0.0, 10.0)
                    self.friction_increase_delay_spin.setSingleStep(0.1)
                    self.friction_increase_delay_spin.setValue(1.0)
                    self.friction_increase_delay_spin.setToolTip("Delay before increasing friction brake")
                    friction_layout.addWidget(self.friction_increase_delay_spin, 3, 1)
                    
                    # Sensitivity
                    friction_layout.addWidget(QLabel("Sensitivity:"), 4, 0)
                    self.friction_sensitivity_combo = QComboBox()
                    self.friction_sensitivity_combo.addItems(["low", "medium", "high"])
                    self.friction_sensitivity_combo.setCurrentText("medium")
                    self.friction_sensitivity_combo.setToolTip("Sensitivity of friction brake detection")
                    friction_layout.addWidget(self.friction_sensitivity_combo, 4, 1)
                    
                    layout.addWidget(friction_group)
                    layout.addStretch()
                    
                    return widget
                    
                def create_keepnet_tab(self):
                    """Create keepnet tab."""
                    widget = QWidget()
                    layout = QVBoxLayout(widget)
                    
                    # Info
                    info_label = QLabel("Configure keepnet settings for fish management.")
                    info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                    layout.addWidget(info_label)
                    
                    # Basic Settings
                    basic_group = QGroupBox("Basic Settings")
                    basic_layout = QGridLayout(basic_group)
                    
                    # Capacity
                    basic_layout.addWidget(QLabel("Capacity:"), 0, 0)
                    self.keepnet_capacity_spin = QSpinBox()
                    self.keepnet_capacity_spin.setRange(1, 200)
                    self.keepnet_capacity_spin.setValue(100)
                    self.keepnet_capacity_spin.setToolTip("Maximum number of fish in keepnet")
                    basic_layout.addWidget(self.keepnet_capacity_spin, 0, 1)
                    
                    # Full Action
                    basic_layout.addWidget(QLabel("Full Action:"), 1, 0)
                    self.keepnet_full_action_combo = QComboBox()
                    self.keepnet_full_action_combo.addItems(["quit", "alarm"])
                    self.keepnet_full_action_combo.setToolTip("Action when keepnet is full")
                    basic_layout.addWidget(self.keepnet_full_action_combo, 1, 1)
                    
                    # Fish Delay
                    basic_layout.addWidget(QLabel("Fish Delay (sec):"), 2, 0)
                    self.fish_delay_spin = QDoubleSpinBox()
                    self.fish_delay_spin.setRange(0.0, 10.0)
                    self.fish_delay_spin.setSingleStep(0.1)
                    self.fish_delay_spin.setValue(0.0)
                    self.fish_delay_spin.setToolTip("Delay before keeping fish (for screenshots)")
                    basic_layout.addWidget(self.fish_delay_spin, 2, 1)
                    
                    # Gift Delay
                    basic_layout.addWidget(QLabel("Gift Delay (sec):"), 3, 0)
                    self.gift_delay_spin = QDoubleSpinBox()
                    self.gift_delay_spin.setRange(0.0, 10.0)
                    self.gift_delay_spin.setSingleStep(0.1)
                    self.gift_delay_spin.setValue(4.0)
                    self.gift_delay_spin.setToolTip("Delay before keeping gift (for screenshots)")
                    basic_layout.addWidget(self.gift_delay_spin, 3, 1)
                    
                    # Fish Management
                    fish_group = QGroupBox("Fish Management")
                    fish_layout = QGridLayout(fish_group)
                    
                    # Tags to keep
                    fish_layout.addWidget(QLabel("Keep Tags:"), 0, 0)
                    self.keepnet_tags_edit = QLineEdit()
                    self.keepnet_tags_edit.setPlaceholderText("green,yellow,blue,purple,pink")
                    self.keepnet_tags_edit.setToolTip("Comma-separated list of fish tags to keep (use with -t flag)")
                    fish_layout.addWidget(self.keepnet_tags_edit, 0, 1)
                    
                    # Whitelist
                    fish_layout.addWidget(QLabel("Whitelist:"), 1, 0)
                    self.keepnet_whitelist_edit = QLineEdit()
                    self.keepnet_whitelist_edit.setPlaceholderText("mackerel,saithe,herring")
                    self.keepnet_whitelist_edit.setToolTip("Comma-separated list of fish to always keep")
                    fish_layout.addWidget(self.keepnet_whitelist_edit, 1, 1)
                    
                    # Blacklist
                    fish_layout.addWidget(QLabel("Blacklist:"), 2, 0)
                    self.keepnet_blacklist_edit = QLineEdit()
                    self.keepnet_blacklist_edit.setPlaceholderText("Leave empty or specify fish to release")
                    self.keepnet_blacklist_edit.setToolTip("Comma-separated list of fish to always release")
                    fish_layout.addWidget(self.keepnet_blacklist_edit, 2, 1)
                    
                    layout.addWidget(basic_group)
                    layout.addWidget(fish_group)
                    layout.addStretch()
                    
                    return widget
                    
                def create_notifications_tab(self):
                    """Create notifications tab."""
                    widget = QWidget()
                    layout = QVBoxLayout(widget)
                    
                    # Info
                    info_label = QLabel("Configure notifications for script events.")
                    info_label.setStyleSheet("color: #666; font-style: italic; margin: 5px;")
                    layout.addWidget(info_label)
                    
                    # Email Group
                    email_group = QGroupBox("Email Notifications (use -E flag)")
                    email_layout = QGridLayout(email_group)
                    
                    email_layout.addWidget(QLabel("Email:"), 0, 0)
                    self.email_edit = QLineEdit()
                    self.email_edit.setPlaceholderText("your-email@gmail.com")
                    self.email_edit.setToolTip("Your email address for notifications")
                    email_layout.addWidget(self.email_edit, 0, 1)
                    
                    email_layout.addWidget(QLabel("Password:"), 1, 0)
                    self.password_edit = QLineEdit()
                    self.password_edit.setEchoMode(QLineEdit.EchoMode.Password)
                    self.password_edit.setPlaceholderText("App password (not your regular password)")
                    self.password_edit.setToolTip("App password for email (Gmail: use App Passwords)")
                    email_layout.addWidget(self.password_edit, 1, 1)
                    
                    email_layout.addWidget(QLabel("SMTP Server:"), 2, 0)
                    self.smtp_server_edit = QLineEdit()
                    self.smtp_server_edit.setText("smtp.gmail.com")
                    self.smtp_server_edit.setToolTip("SMTP server address")
                    email_layout.addWidget(self.smtp_server_edit, 2, 1)
                    
                    # Discord Group
                    discord_group = QGroupBox("Discord Notifications (use -D flag)")
                    discord_layout = QGridLayout(discord_group)
                    
                    discord_layout.addWidget(QLabel("Webhook URL:"), 0, 0)
                    self.discord_webhook_edit = QLineEdit()
                    self.discord_webhook_edit.setPlaceholderText("https://discord.com/api/webhooks/...")
                    self.discord_webhook_edit.setToolTip("Discord webhook URL for notifications")
                    discord_layout.addWidget(self.discord_webhook_edit, 0, 1)
                    
                    # Miaotixing Group
                    miao_group = QGroupBox("Miaotixing Notifications (use -M flag)")
                    miao_layout = QGridLayout(miao_group)
                    
                    miao_layout.addWidget(QLabel("Miao Code:"), 0, 0)
                    self.miao_code_edit = QLineEdit()
                    self.miao_code_edit.setPlaceholderText("Your miaotixing code")
                    self.miao_code_edit.setToolTip("Miaotixing notification code")
                    miao_layout.addWidget(self.miao_code_edit, 0, 1)
                    
                    layout.addWidget(email_group)
                    layout.addWidget(discord_group)
                    layout.addWidget(miao_group)
                    layout.addStretch()
                    
                    return widget
                    
                def create_control_panel(self, parent):
                    """Create script control panel."""
                    control_widget = QWidget()
                    layout = QVBoxLayout(control_widget)
                    
                    # Profile Quick Select
                    profile_group = QGroupBox("Quick Profile Selection")
                    profile_layout = QGridLayout(profile_group)
                    
                    profiles = [
                        ("SPIN", "üé£ Spin"),
                        ("BOTTOM", "‚öì Bottom"),
                        ("PIRK", "üêü Pirk"),
                        ("TELESCOPIC", "üéØ Telescopic")
                    ]
                    
                    for i, (profile, display_name) in enumerate(profiles):
                        btn = QPushButton(display_name)
                        btn.setToolTip(f"Switch to {profile} fishing profile")
                        btn.clicked.connect(lambda checked, p=profile: self.select_profile(p))
                        profile_layout.addWidget(btn, i // 2, i % 2)
                        
                    layout.addWidget(profile_group)
                    
                    # Launch Options
                    launch_group = QGroupBox("Launch Options")
                    launch_layout = QVBoxLayout(launch_group)
                    
                    self.current_launch_options = QLineEdit()
                    self.current_launch_options.setPlaceholderText("Enter launch options here...")
                    self.current_launch_options.setToolTip("Command line options for the script")
                    launch_layout.addWidget(self.current_launch_options)
                    
                    # Common options checkboxes
                    options_layout = QGridLayout()
                    self.option_checkboxes = {}
                    
                    common_options = [
                        ("-r", "Refill stats", "Consume tea and carrot if hunger/comfort is low"),
                        ("-c", "Drink coffee", "Drink coffee if stamina is low during fish fight"),
                        ("-H", "Harvest baits", "Harvest baits before casting the rod"),
                        ("-t", "Keep tagged only", "Keep only tagged fishes"),
                        ("-s", "Save screenshots", "Save screenshot after catching fish"),
                        ("-d", "Save data logs", "Save fishing data in logs"),
                        ("-FB", "Friction brake", "Adjust friction brake automatically"),
                        ("-l", "Lift tackle", "Lift tackle constantly during fish fight"),
                    ]
                    
                    for i, (option, short_desc, tooltip) in enumerate(common_options):
                        cb = QCheckBox(f"{option}: {short_desc}")
                        cb.setToolTip(tooltip)
                        cb.stateChanged.connect(self.update_launch_options)
                        self.option_checkboxes[option] = cb
                        options_layout.addWidget(cb, i // 2, i % 2)
                        
                    launch_layout.addLayout(options_layout)
                    layout.addWidget(launch_group)
                    
                    # Script Control
                    control_group = QGroupBox("Script Control")
                    control_layout = QVBoxLayout(control_group)
                    
                    # Buttons
                    button_layout = QHBoxLayout()
                    
                    self.start_button = QPushButton("‚ñ∂Ô∏è Start Script")
                    self.stop_button = QPushButton("‚èπÔ∏è Stop Script")
                    self.stop_button.setEnabled(False)
                    
                    # Style buttons
                    self.start_button.setStyleSheet("""
                    QPushButton {
                        background-color: #4CAF50;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 4px;
                        font-weight: bold;
                    }
                    QPushButton:hover {
                        background-color: #45a049;
                    }
                    QPushButton:disabled {
                        background-color: #cccccc;
                    }
                    """)
                    
                    self.stop_button.setStyleSheet("""
                    QPushButton {
                        background-color: #f44336;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 4px;
                        font-weight: bold;
                    }
                    QPushButton:hover {
                        background-color: #da190b;
                    }
                    QPushButton:disabled {
                        background-color: #cccccc;
                    }
                    """)
                    
                    self.start_button.clicked.connect(self.start_script)
                    self.stop_button.clicked.connect(self.stop_script)
                    
                    button_layout.addWidget(self.start_button)
                    button_layout.addWidget(self.stop_button)
                    control_layout.addLayout(button_layout)
                    
                    # Progress bar
                    self.progress_bar = QProgressBar()
                    self.progress_bar.setVisible(False)
                    control_layout.addWidget(self.progress_bar)
                    
                    # Fish count input
                    fish_layout = QHBoxLayout()
                    fish_layout.addWidget(QLabel("Fishes in keepnet:"))
                    self.fish_count_spin = QSpinBox()
                    self.fish_count_spin.setRange(0, 200)
                    self.fish_count_spin.setValue(0)
                    self.fish_count_spin.setToolTip("Current number of fishes in your keepnet")
                    fish_layout.addWidget(self.fish_count_spin)
                    control_layout.addLayout(fish_layout)
                    
                    layout.addWidget(control_group)
                    
                    # Log viewer
                    log_group = QGroupBox("Script Output")
                    log_layout = QVBoxLayout(log_group)
                    
                    self.log_viewer = QTextEdit()
                    self.log_viewer.setReadOnly(True)
                    self.log_viewer.setFont(QFont("Consolas", 9))
                    self.log_viewer.setStyleSheet("""
                    QTextEdit {
                        background-color: #1e1e1e;
                        color: #ffffff;
                        border: 1px solid #555;
                    }
                    """)
                    log_layout.addWidget(self.log_viewer)
                    
                    # Log controls
                    log_controls = QHBoxLayout()
                    self.clear_log_button = QPushButton("üóëÔ∏è Clear")
                    self.save_log_button = QPushButton("üíæ Save")
                    self.auto_scroll_cb = QCheckBox("Auto-scroll")
                    self.auto_scroll_cb.setChecked(True)
                    
                    self.clear_log_button.clicked.connect(self.clear_log)
                    self.save_log_button.clicked.connect(self.save_log)
                    
                    log_controls.addWidget(self.clear_log_button)
                    log_controls.addWidget(self.save_log_button)
                    log_controls.addWidget(self.auto_scroll_cb)
                    log_controls.addStretch()
                    
                    log_layout.addLayout(log_controls)
                    layout.addWidget(log_group)
                    
                    parent.addWidget(control_widget)
                    
                def connect_signals(self):
                    """Connect signals and slots."""
                    # Script runner signals
                    self.script_runner.output_received.connect(self.append_log)
                    self.script_runner.error_received.connect(self.append_error_log)
                    self.script_runner.finished.connect(self.script_finished)
                    
                    # Profile combo change
                    self.profile_combo.currentTextChanged.connect(self.on_profile_changed)
                    
                def on_profile_changed(self, profile_name):
                    """Handle profile change."""
                    self.create_profile_widgets()
                    self.load_profile_settings(profile_name)
                    
                def change_language(self, language):
                    """Change interface language."""
                    self.current_language = "en" if language == "English" else "ru"
                    self.update_interface_language()
                    self.update_status(f"Language changed to {language}")
                    self.update_status(f"Language changed to {language}")
                    # TODO: Implement full translation updates
                    
                def update_interface_language(self):
                    """Update all interface elements with new language."""
                    lang = self.current_language
                    t = self.translations.get_all_keys(lang)
                
                    # Update window title
                    self.setWindowTitle(t.get("window_title", "Russian Fishing 4 Script GUI v1.0"))
                
                    # Update buttons
                    self.load_button.setText(t.get("load_config", "üìÅ Load Config"))
                    self.save_button.setText(t.get("save_config", "üíæ Save Config"))
                    self.reset_button.setText(t.get("reset_default", "üîÑ Reset to Default"))
                    self.start_button.setText(t.get("start_script", "‚ñ∂Ô∏è Start Script"))
                    self.stop_button.setText(t.get("stop_script", "‚èπÔ∏è Stop Script"))
                
                    # Update tab titles
                    self.tab_widget.setTabText(0, t.get("script_settings", "‚öôÔ∏è Script Settings"))
                    self.tab_widget.setTabText(1, t.get("key_bindings", "üéÆ Key Bindings"))
                    self.tab_widget.setTabText(2, t.get("player_stats", "üìä Player Stats"))
                    self.tab_widget.setTabText(3, t.get("fishing_profiles", "üé£ Fishing Profiles"))
                    self.tab_widget.setTabText(4, t.get("friction_brake", "üîß Friction Brake"))
                    self.tab_widget.setTabText(5, t.get("keepnet", "üóÉÔ∏è Keepnet"))
                    self.tab_widget.setTabText(6, t.get("notifications", "üìß Notifications"))
                    
                def load_config(self):
                    """Load configuration from file."""
                    try:
                        config_path = "config.yaml"
                        if os.path.exists(config_path):
                            self.config_manager.load_config(config_path)
                            self.update_ui_from_config()
                            self.config_indicator.setText("config.yaml")
                            self.config_indicator.setStyleSheet("color: green;")
                            self.update_status("Configuration loaded successfully")
                        else:
                            self.config_indicator.setText("No config")
                            self.config_indicator.setStyleSheet("color: orange;")
                            self.update_status("No config.yaml found, using defaults")
                    except Exception as e:
                        self.config_indicator.setText("Error")
                        self.config_indicator.setStyleSheet("color: red;")
                        QMessageBox.warning(self, "Error", f"Failed to load configuration: {str(e)}")
                        
                def update_ui_from_config(self):
                    """Update UI elements from loaded configuration."""
                    config = self.config_manager.config
                    
                    # Script settings
                    if 'SCRIPT' in config:
                        script = config['SCRIPT']
                        self.script_language_combo.setCurrentText(script.get('LANGUAGE', 'en'))
                        self.launch_options_edit.setText(script.get('LAUNCH_OPTIONS', ''))
                        
                        self.smtp_verification_cb.setChecked(script.get('SMTP_VERIFICATION', True))
                        self.image_verification_cb.setChecked(script.get('IMAGE_VERIFICATION', True))
                        self.snag_detection_cb.setChecked(script.get('SNAG_DETECTION', True))
                        self.spooling_detection_cb.setChecked(script.get('SPOOLING_DETECTION', True))
                        self.random_rod_selection_cb.setChecked(script.get('RANDOM_ROD_SELECTION', True))
                        self.spool_confidence_spin.setValue(script.get('SPOOL_CONFIDENCE', 0.98))
                        self.spod_recast_delay_spin.setValue(script.get('SPOD_ROD_RECAST_DELAY', 1800))
                        self.lure_change_delay_spin.setValue(script.get('LURE_CHANGE_DELAY', 1800))
                        self.random_cast_prob_spin.setValue(script.get('RANDOM_CAST_PROBABILITY', 0.25))
                        
                    # Key bindings
                    if 'KEY' in config:
                        keys = config['KEY']
                        for key, widget in self.key_widgets.items():
                            widget.setText(str(keys.get(key, -1)))
                        
                        bottom_rods = keys.get('BOTTOM_RODS', [1, 2, 3])
                        self.bottom_rods_edit.setText(','.join(map(str, bottom_rods)))
                        self.quit_key_edit.setText(keys.get('QUIT', 'CTRL-C'))
                        
                    # Player stats
                    if 'STAT' in config:
                        stat = config['STAT']
                        self.energy_threshold_spin.setValue(stat.get('ENERGY_THRESHOLD', 0.74))
                        self.hunger_threshold_spin.setValue(stat.get('HUNGER_THRESHOLD', 0.5))
                        self.comfort_threshold_spin.setValue(stat.get('COMFORT_THRESHOLD', 0.51))
                        self.tea_delay_spin.setValue(stat.get('TEA_DELAY', 300))
                        self.coffee_limit_spin.setValue(stat.get('COFFEE_LIMIT', 10))
                        self.coffee_per_drink_spin.setValue(stat.get('COFFEE_PER_DRINK', 1))
                        self.alcohol_delay_spin.setValue(stat.get('ALCOHOL_DELAY', 900))
                        self.alcohol_per_drink_spin.setValue(stat.get('ALCOHOL_PER_DRINK', 1))
                        
                    # Friction brake
                    if 'FRICTION_BRAKE' in config:
                        friction = config['FRICTION_BRAKE']
                        self.friction_initial_spin.setValue(friction.get('INITIAL', 29))
                        self.friction_max_spin.setValue(friction.get('MAX', 30))
                        self.friction_start_delay_spin.setValue(friction.get('START_DELAY', 2.0))
                        self.friction_increase_delay_spin.setValue(friction.get('INCREASE_DELAY', 1.0))
                        self.friction_sensitivity_combo.setCurrentText(friction.get('SENSITIVITY', 'medium'))
                        
                    # Keepnet
                    if 'KEEPNET' in config:
                        keepnet = config['KEEPNET']
                        self.keepnet_capacity_spin.setValue(keepnet.get('CAPACITY', 100))
                        self.keepnet_full_action_combo.setCurrentText(keepnet.get('FULL_ACTION', 'quit'))
                        self.fish_delay_spin.setValue(keepnet.get('FISH_DELAY', 0.0))
                        self.gift_delay_spin.setValue(keepnet.get('GIFT_DELAY', 4.0))
                        
                        tags = keepnet.get('TAGS', [])
                        self.keepnet_tags_edit.setText(','.join(tags) if tags else '')
                        
                        whitelist = keepnet.get('WHITELIST', [])
                        self.keepnet_whitelist_edit.setText(','.join(whitelist) if whitelist else '')
                        
                        blacklist = keepnet.get('BLACKLIST', [])
                        self.keepnet_blacklist_edit.setText(','.join(blacklist) if blacklist else '')
                        
                    # Notifications
                    if 'NOTIFICATION' in config:
                        notif = config['NOTIFICATION']
                        self.email_edit.setText(notif.get('EMAIL', ''))
                        self.password_edit.setText(notif.get('PASSWORD', ''))
                        self.smtp_server_edit.setText(notif.get('SMTP_SERVER', 'smtp.gmail.com'))
                        self.discord_webhook_edit.setText(notif.get('DISCORD_WEBHOOK_URL', ''))
                        self.miao_code_edit.setText(notif.get('MIAO_CODE', ''))
                        
                    # Load profile settings
                    self.load_profile_settings(self.profile_combo.currentText())
                    
                def save_config_file(self):
                    """Save configuration to file."""
                    try:
                        self.update_config_from_ui()
                        self.config_manager.save_config("config.yaml")
                        self.config_indicator.setText("config.yaml")
                        self.config_indicator.setStyleSheet("color: green;")
                        self.update_status("Configuration saved successfully")
                        QMessageBox.information(self, "Success", "Configuration saved successfully!")
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to save configuration: {str(e)}")
                        
                def update_config_from_ui(self):
                    """Update configuration from UI elements."""
                    config = self.config_manager.config
                    
                    # Script settings
                    if 'SCRIPT' not in config:
                        config['SCRIPT'] = {}
                        
                    config['SCRIPT']['LANGUAGE'] = self.script_language_combo.currentText()
                    config['SCRIPT']['LAUNCH_OPTIONS'] = self.launch_options_edit.text()
                    config['SCRIPT']['SMTP_VERIFICATION'] = self.smtp_verification_cb.isChecked()
                    config['SCRIPT']['IMAGE_VERIFICATION'] = self.image_verification_cb.isChecked()
                    config['SCRIPT']['SNAG_DETECTION'] = self.snag_detection_cb.isChecked()
                    config['SCRIPT']['SPOOLING_DETECTION'] = self.spooling_detection_cb.isChecked()
                    config['SCRIPT']['RANDOM_ROD_SELECTION'] = self.random_rod_selection_cb.isChecked()
                    config['SCRIPT']['SPOOL_CONFIDENCE'] = self.spool_confidence_spin.value()
                    config['SCRIPT']['SPOD_ROD_RECAST_DELAY'] = self.spod_recast_delay_spin.value()
                    config['SCRIPT']['LURE_CHANGE_DELAY'] = self.lure_change_delay_spin.value()
                    config['SCRIPT']['RANDOM_CAST_PROBABILITY'] = self.random_cast_prob_spin.value()
                    
                    # Key bindings
                    if 'KEY' not in config:
                        config['KEY'] = {}
                        
                    for key, widget in self.key_widgets.items():
                        try:
                            value = int(widget.text()) if widget.text() else -1
                            config['KEY'][key] = value
                        except ValueError:
                            config['KEY'][key] = -1
                            
                    # Bottom rods
                    try:
                        bottom_rods = [int(x.strip()) for x in self.bottom_rods_edit.text().split(',') if x.strip()]
                        config['KEY']['BOTTOM_RODS'] = bottom_rods if bottom_rods else [1, 2, 3]
                    except ValueError:
                        config['KEY']['BOTTOM_RODS'] = [1, 2, 3]
                        
                    config['KEY']['QUIT'] = self.quit_key_edit.text() or 'CTRL-C'
                        
                    # Player stats
                    if 'STAT' not in config:
                        config['STAT'] = {}
                        
                    config['STAT']['ENERGY_THRESHOLD'] = self.energy_threshold_spin.value()
                    config['STAT']['HUNGER_THRESHOLD'] = self.hunger_threshold_spin.value()
                    config['STAT']['COMFORT_THRESHOLD'] = self.comfort_threshold_spin.value()
                    config['STAT']['TEA_DELAY'] = self.tea_delay_spin.value()
                    config['STAT']['COFFEE_LIMIT'] = self.coffee_limit_spin.value()
                    config['STAT']['COFFEE_PER_DRINK'] = self.coffee_per_drink_spin.value()
                    config['STAT']['ALCOHOL_DELAY'] = self.alcohol_delay_spin.value()
                    config['STAT']['ALCOHOL_PER_DRINK'] = self.alcohol_per_drink_spin.value()
                    
                    # Friction brake
                    if 'FRICTION_BRAKE' not in config:
                        config['FRICTION_BRAKE'] = {}
                        
                    config['FRICTION_BRAKE']['INITIAL'] = self.friction_initial_spin.value()
                    config['FRICTION_BRAKE']['MAX'] = self.friction_max_spin.value()
                    config['FRICTION_BRAKE']['START_DELAY'] = self.friction_start_delay_spin.value()
                    config['FRICTION_BRAKE']['INCREASE_DELAY'] = self.friction_increase_delay_spin.value()
                    config['FRICTION_BRAKE']['SENSITIVITY'] = self.friction_sensitivity_combo.currentText()
                    
                    # Keepnet
                    if 'KEEPNET' not in config:
                        config['KEEPNET'] = {}
                        
                    config['KEEPNET']['CAPACITY'] = self.keepnet_capacity_spin.value()
                    config['KEEPNET']['FULL_ACTION'] = self.keepnet_full_action_combo.currentText()
                    config['KEEPNET']['FISH_DELAY'] = self.fish_delay_spin.value()
                    config['KEEPNET']['GIFT_DELAY'] = self.gift_delay_spin.value()
                    
                    # Parse comma-separated lists
                    tags_text = self.keepnet_tags_edit.text()
                    config['KEEPNET']['TAGS'] = [tag.strip() for tag in tags_text.split(',') if tag.strip()] if tags_text else []
                    
                    whitelist_text = self.keepnet_whitelist_edit.text()
                    config['KEEPNET']['WHITELIST'] = [item.strip() for item in whitelist_text.split(',') if item.strip()] if whitelist_text else []
                    
                    blacklist_text = self.keepnet_blacklist_edit.text()
                    config['KEEPNET']['BLACKLIST'] = [item.strip() for item in blacklist_text.split(',') if item.strip()] if blacklist_text else []
                    
                    # Notifications
                    if 'NOTIFICATION' not in config:
                        config['NOTIFICATION'] = {}
                        
                    config['NOTIFICATION']['EMAIL'] = self.email_edit.text()
                    config['NOTIFICATION']['PASSWORD'] = self.password_edit.text()
                    config['NOTIFICATION']['SMTP_SERVER'] = self.smtp_server_edit.text()
                    config['NOTIFICATION']['DISCORD_WEBHOOK_URL'] = self.discord_webhook_edit.text()
                    config['NOTIFICATION']['MIAO_CODE'] = self.miao_code_edit.text()
                    
                    # Update current profile
                    self.save_current_profile()
                    
                def save_current_profile(self):
                    """Save current profile settings."""
                    profile_name = self.profile_combo.currentText()
                    if not profile_name or profile_name not in self.config_manager.config.get('PROFILE', {}):
                        return
                        
                    profile_config = {}
                    
                    for key, widget in self.profile_widgets.items():
                        try:
                            if isinstance(widget, QComboBox):
                                profile_config[key] = widget.currentText()
                            elif isinstance(widget, QDoubleSpinBox):
                                profile_config[key] = widget.value()
                            elif isinstance(widget, QSpinBox):
                                profile_config[key] = widget.value()
                            elif isinstance(widget, QCheckBox):
                                profile_config[key] = widget.isChecked()
                            elif isinstance(widget, QLineEdit):
                                profile_config[key] = widget.text()
                        except Exception as e:
                            print(f"Error saving profile setting {key}: {e}")
                            
                    self.config_manager.set_profile_config(profile_name, profile_config)
                    
                def load_config_file(self):
                    """Load configuration from selected file."""
                    file_path, _ = QFileDialog.getOpenFileName(
                        self, "Load Configuration", "", "YAML files (*.yaml *.yml);;All files (*.*)"
                    )
                    if file_path:
                        try:
                            self.config_manager.load_config(file_path)
                            self.update_ui_from_config()
                            self.config_indicator.setText(os.path.basename(file_path))
                            self.config_indicator.setStyleSheet("color: green;")
                            self.update_status(f"Configuration loaded from {file_path}")
                        except Exception as e:
                            QMessageBox.critical(self, "Error", f"Failed to load configuration: {str(e)}")
                            
                def reset_config(self):
                    """Reset configuration to defaults."""
                    reply = QMessageBox.question(
                        self, "Reset Configuration", 
                        "Are you sure you want to reset all settings to default values?\n\n"
                        "This will overwrite all current settings.",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                        QMessageBox.StandardButton.No
                    )
                    
                    if reply == QMessageBox.StandardButton.Yes:
                        self.config_manager.reset_to_defaults()
                        self.update_ui_from_config()
                        self.config_indicator.setText("Defaults")
                        self.config_indicator.setStyleSheet("color: blue;")
                        self.update_status("Configuration reset to defaults")
                        
                def select_profile(self, profile_name):
                    """Select and load a fishing profile."""
                    self.profile_combo.setCurrentText(profile_name)
                    self.load_profile_settings(profile_name)
                    self.update_status(f"Profile selected: {profile_name}")
                    
                def load_profile_settings(self, profile_name):
                    """Load settings for selected profile."""
                    if not profile_name:
                        return
                        
                    profile_config = self.config_manager.get_profile_config(profile_name)
                    if not profile_config:
                        return
                        
                    # Load values into widgets
                    for key, value in profile_config.items():
                        if key in self.profile_widgets:
                            widget = self.profile_widgets[key]
                            try:
                                if isinstance(widget, QComboBox):
                                    index = widget.findText(str(value))
                                    if index >= 0:
                                        widget.setCurrentIndex(index)
                                elif isinstance(widget, (QDoubleSpinBox, QSpinBox)):
                                    widget.setValue(float(value) if isinstance(widget, QDoubleSpinBox) else int(value))
                                elif isinstance(widget, QCheckBox):
                                    widget.setChecked(bool(value))
                                elif isinstance(widget, QLineEdit):
                                    widget.setText(str(value))
                            except Exception as e:
                                print(f"Error loading profile setting {key}: {e}")
                                
                def copy_current_profile(self):
                    """Copy current profile with new name."""
                    current_profile = self.profile_combo.currentText()
                    if not current_profile:
                        return
                        
                    new_name, ok = QInputDialog.getText(
                        self, "Copy Profile", 
                        f"Enter name for copy of '{current_profile}':",
                        text=f"{current_profile}_copy"
                    )
                    
                    if ok and new_name.strip():
                        new_name = new_name.strip()
                        
                        # Check if name already exists
                        if new_name in self.config_manager.get_profile_list():
                            QMessageBox.warning(self, "Error", f"Profile '{new_name}' already exists!")
                            return
                            
                        # Copy current profile
                        current_config = self.config_manager.get_profile_config(current_profile)
                        self.config_manager.set_profile_config(new_name, current_config.copy())
                        
                        # Add to combo box
                        self.profile_combo.addItem(new_name)
                        self.profile_combo.setCurrentText(new_name)
                        
                        self.update_status(f"Profile '{new_name}' created")
                        
                def delete_current_profile(self):
                    """Delete current profile."""
                    current_profile = self.profile_combo.currentText()
                    if not current_profile:
                        return
                        
                    # Don't allow deleting default profiles
                    default_profiles = ["SPIN", "BOTTOM", "PIRK", "TELESCOPIC", "BOLOGNESE"]
                    if current_profile in default_profiles:
                        QMessageBox.warning(self, "Error", f"Cannot delete default profile '{current_profile}'!")
                        return
                        
                    reply = QMessageBox.question(
                        self, "Delete Profile",
                        f"Are you sure you want to delete profile '{current_profile}'?\n\n"
                        "This action cannot be undone.",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                        QMessageBox.StandardButton.No
                    )
                    
                    if reply == QMessageBox.StandardButton.Yes:
                        # Remove from config
                        if 'PROFILE' in self.config_manager.config:
                            self.config_manager.config['PROFILE'].pop(current_profile, None)
                            
                        # Remove from combo box
                        index = self.profile_combo.findText(current_profile)
                        if index >= 0:
                            self.profile_combo.removeItem(index)
                            
                        self.update_status(f"Profile '{current_profile}' deleted")
                        
                def update_launch_options(self):
                    """Update launch options based on checkboxes."""
                    options = []
                    for option, checkbox in self.option_checkboxes.items():
                        if checkbox.isChecked():
                            options.append(option)
                            
                    current_text = self.current_launch_options.text()
                    
                    # Parse existing manual options (not in checkboxes)
                    existing_options = current_text.split()
                    manual_options = [opt for opt in existing_options if opt not in self.option_checkboxes.keys()]
                    
                    # Combine manual options with checkbox options
                    all_options = manual_options + options
                    
                    self.current_launch_options.setText(' '.join(all_options))
                    
                def start_script(self):
                    """Start the fishing script with pre-validation."""
                    if self.is_script_running:
                        QMessageBox.information(self, "Info", "Script is already running!")
                        return
                        
                    # Pre-validate environment
                    try:
                        validation_issues = self.script_runner.validate_script_environment()
                        if validation_issues:
                            issue_text = "\n".join(f"‚Ä¢ {issue}" for issue in validation_issues)
                            reply = QMessageBox.question(
                                self, "Environment Issues",
                                f"Found environment issues:\n\n{issue_text}\n\n"
                                "Do you want to:\n"
                                "‚Ä¢ Continue anyway (may fail)\n"
                                "‚Ä¢ Run diagnostic script first\n\n"
                                "Choose 'Yes' to continue, 'No' to cancel",
                            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                QMessageBox.StandardButton.No
                            )
                            
                            if reply == QMessageBox.StandardButton.No:
                                # Show diagnostic info
                                info_text = "\n".join(self.script_runner.get_script_info())
                                QMessageBox.information(
                                    self, "Diagnostic Information",
                                    f"Environment Information:\n\n{info_text}\n\n"
                                    "Run 'python diagnose_environment.py' for detailed diagnosis."
                                    )
                                return
                    except Exception as e:
                        QMessageBox.critical(self, "Validation Error", f"Environment validation failed: {str(e)}")
                        return
                        
                    # Continue with normal start logic...
                    launch_options = self.current_launch_options.text().strip()
                    profile = self.profile_combo.currentText()
                    fish_count = self.fish_count_spin.value()
                    
                    if fish_count > 0:
                        launch_options += f" -n {fish_count}"
                        
                    # Save current configuration
                    try:
                        self.update_config_from_ui()
                        self.config_manager.save_config("config.yaml")
                        self.update_status("Configuration saved before starting")
                    except Exception as e:
                        QMessageBox.warning(self, "Warning", f"Failed to save configuration: {str(e)}")
                        
                    # Start script
                    try:
                        self.script_runner.start_script(launch_options, profile)
                        self.is_script_running = True
                        self.start_button.setEnabled(False)
                        self.stop_button.setEnabled(True)
                        self.progress_bar.setVisible(True)
                        self.progress_bar.setRange(0, 0)
                        self.script_status.setText("Script: Running")
                        self.script_status.setStyleSheet("color: green;")
                        self.update_status("Script started successfully")
                        self.append_log(f"üöÄ Starting script with profile: {profile}")
                        if launch_options:
                            self.append_log(f"üìã Launch options: {launch_options}")
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to start script:\n\n{str(e)}")
                        self.script_status.setText("Script: Error")
                        self.script_status.setStyleSheet("color: red;")
                            
                def validate_current_config(self):
                    """Validate current configuration and return list of issues."""
                    errors = []
                    
                    # Check script path
                    if not self.script_runner._find_script_path():
                        errors.append("Main script not found (looking for tools/main.py or main.py)")
                        
                    # Check launch options
                    launch_options = self.current_launch_options.text().strip()
                    if launch_options:
                        valid, invalid_options = self.config_manager.validate_launch_options(launch_options)
                        if not valid:
                            errors.append(f"Invalid launch options: {', '.join(invalid_options)}")
                            
                    # Check email settings if email option is used
                    if '-E' in launch_options or '--email' in launch_options:
                        if not self.email_edit.text().strip():
                            errors.append("Email address required for email notifications")
                        if not self.password_edit.text().strip():
                            errors.append("Email password required for email notifications")
                            
                    # Check Discord webhook if Discord option is used
                    if '-D' in launch_options or '--discord' in launch_options:
                        if not self.discord_webhook_edit.text().strip():
                            errors.append("Discord webhook URL required for Discord notifications")
                            
                    return errors
                        
                def stop_script(self):
                    """Stop the running script."""
                    if not self.is_script_running:
                        return
                        
                    try:
                        self.script_runner.stop_script()
                        self.append_log("üõë Stop signal sent to script")
                        self.update_status("Stopping script...")
                    except Exception as e:
                        QMessageBox.warning(self, "Warning", f"Error stopping script: {str(e)}")
                        
                def script_finished(self, exit_code):
                    """Handle script completion."""
                    self.is_script_running = False
                    self.start_button.setEnabled(True)
                    self.stop_button.setEnabled(False)
                    self.progress_bar.setVisible(False)
                    
                    if exit_code == 0:
                        self.script_status.setText("Script: Completed")
                        self.script_status.setStyleSheet("color: blue;")
                        self.update_status("Script finished successfully")
                        self.append_log("‚úÖ Script completed successfully")
                    else:
                        self.script_status.setText("Script: Error")
                        self.script_status.setStyleSheet("color: red;")
                        self.update_status(f"Script finished with errors (exit code: {exit_code})")
                        self.append_log(f"‚ùå Script finished with exit code: {exit_code}")
                        
                def append_log(self, text):
                    """Append text to log viewer."""
                    timestamp = datetime.now().strftime('%H:%M:%S')
                    formatted_text = f"[{timestamp}] {text}"
                    
                    self.log_viewer.append(formatted_text)
                    
                    # Limit log lines to prevent memory issues
                    cursor = self.log_viewer.textCursor()
                    cursor.movePosition(QTextCursor.MoveOperation.Start)
                    
                    full_text = self.log_viewer.toPlainText()
                    lines = full_text.split('\n')
                    if len(lines) > 1000:  # Keep last 1000 lines
                        limited_text = '\n'.join(lines[-1000:])
                        self.log_viewer.clear()
                        self.log_viewer.setPlainText(limited_text)
                    
                    # Auto-scroll if enabled
                    if self.auto_scroll_cb.isChecked():
                        scrollbar = self.log_viewer.verticalScrollBar()
                        scrollbar.setValue(scrollbar.maximum())
                    
                def append_error_log(self, text):
                    """Append error text to log viewer."""
                    timestamp = datetime.now().strftime('%H:%M:%S')
                    formatted_text = f"[{timestamp}] ‚ùå ERROR: {text}"
                    
                    # Use red color for errors
                    self.log_viewer.setTextColor(Qt.GlobalColor.red)
                    self.log_viewer.append(formatted_text)
                    self.log_viewer.setTextColor(Qt.GlobalColor.white)  # Reset to white
                    
                    # Auto-scroll if enabled
                    if self.auto_scroll_cb.isChecked():
                        scrollbar = self.log_viewer.verticalScrollBar()
                        scrollbar.setValue(scrollbar.maximum())
                    
                def clear_log(self):
                    """Clear the log viewer."""
                    self.log_viewer.clear()
                    self.update_status("Log cleared")
                    
                def save_log(self):
                    """Save log to file."""
                    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                    default_filename = f"rf4s_log_{timestamp}.txt"
                    
                    file_path, _ = QFileDialog.getSaveFileName(
                        self, "Save Log", default_filename, "Text files (*.txt);;All files (*.*)"
                    )
                    if file_path:
                        try:
                            with open(file_path, 'w', encoding='utf-8') as f:
                                f.write(f"Russian Fishing 4 Script GUI Log\n")
                                f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                                f.write("=" * 50 + "\n\n")
                                f.write(self.log_viewer.toPlainText())
                            self.update_status(f"Log saved to {file_path}")
                        except Exception as e:
                            QMessageBox.critical(self, "Error", f"Failed to save log: {str(e)}")
                            
                def load_window_state(self):
                    """Load window geometry and state."""
                    try:
                        geometry = self.settings.value("geometry")
                        if geometry:
                            self.restoreGeometry(geometry)
                            
                        window_state = self.settings.value("windowState")
                        if window_state:
                            self.restoreState(window_state)
                            
                        # Load last selected profile
                        last_profile = self.settings.value("lastProfile")
                        if last_profile and last_profile in [self.profile_combo.itemText(i) for i in range(self.profile_combo.count())]:
                            self.profile_combo.setCurrentText(last_profile)
                            
                    except Exception as e:
                        print(f"Error loading window state: {e}")
                        
                def save_window_state(self):
                    """Save window geometry and state."""
                    try:
                        self.settings.setValue("geometry", self.saveGeometry())
                        self.settings.setValue("windowState", self.saveState())
                        self.settings.setValue("lastProfile", self.profile_combo.currentText())
                    except Exception as e:
                        print(f"Error saving window state: {e}")
                        
                def closeEvent(self, event):
                    """Handle window close event."""
                    # Stop script if running
                    if self.is_script_running:
                        reply = QMessageBox.question(
                            self, "Script Running",
                            "The script is currently running. Do you want to stop it and exit?",
                            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                            QMessageBox.StandardButton.No
                        )
                        
                        if reply == QMessageBox.StandardButton.Yes:
                            self.stop_script()
                            # Give script time to stop
                            QTimer.singleShot(2000, self.close)
                            event.ignore()
                            return
                        else:
                            event.ignore()
                            return
                    
                    # Save window state
                    self.save_window_state()
                    
                    # Accept the close event
                    event.accept()
            
            
            def main():
                """Main application entry point."""
                app = QApplication(sys.argv)
                app.setApplicationName("Russian Fishing 4 Script GUI")
                app.setApplicationVersion("1.0")
                app.setOrganizationName("RF4S")
                app.setOrganizationDomain("rf4s.local")
                
                # Set application icon if available
                try:
                    app.setWindowIcon(QIcon("gui/assets/icon.png"))
                except:
                    pass  # Icon file not found, continue without it
                
                window = MainWindow()
                window.show()
                
                # Add import to fix the missing import
                from PyQt6.QtWidgets import QInputDialog
                
                sys.exit(app.exec())
            
            
            if __name__ == "__main__":
                main()
        üìÑ requirements_gui.txt
            # GUI Framework
            PyQt6>=6.4.0
            
            # Configuration management
            PyYAML>=6.0
            pyyaml>=6.0
            
            # Process monitoring and system information
            psutil>=5.8.0
            
            # Additional utilities (optional but recommended)
            pathlib2>=2.3.0; python_version < "3.4"
        üìÑ run_gui.py
            #!/usr/bin/env python3
            """
            Entry point for Russian Fishing 4 Script GUI
            """
            
            import sys
            import os
            
            # Add the current directory to Python path
            sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
            
            from main_window import main
            
            if __name__ == "__main__":
                main()
        üìÑ script_runner.py
            """
            Script execution management for Russian Fishing 4 Script GUI
            Fixed version with better error handling and import validation
            """
            
            import subprocess
            import sys
            import os
            import signal
            import threading
            import time
            from pathlib import Path
            from PyQt6.QtCore import QObject, QThread, pyqtSignal, QProcess, QTimer
            from PyQt6.QtWidgets import QApplication
            
            
            class ScriptRunner(QObject):
                """Manages script execution with pre-validation and better error handling."""
                
                output_received = pyqtSignal(str)
                error_received = pyqtSignal(str)
                finished = pyqtSignal(int)
                
                def __init__(self):
                    super().__init__()
                    self.process = None
                    self.is_running = False
                    self.script_path = None
                    
                    # Timer for process monitoring
                    self.monitor_timer = QTimer()
                    self.monitor_timer.timeout.connect(self._monitor_process)
                    
                def validate_script_environment(self):
                    """Validate script environment before starting."""
                    issues = []
                    
                    # Find script
                    self.script_path = self._find_script_path()
                    if not self.script_path:
                        issues.append("Main script not found (tools/main.py, main.py, rf4s/main.py)")
                        return issues
                        
                    # Check script directory structure
                    script_dir = os.path.dirname(self.script_path)
                    required_modules = ['rf4s', 'tools']
                    
                    # Check if rf4s module exists
                    rf4s_path = None
                    possible_rf4s_paths = [
                        os.path.join(script_dir, 'rf4s'),
                        os.path.join(os.getcwd(), 'rf4s'),
                        os.path.join(os.path.dirname(script_dir), 'rf4s')
                    ]
                    
                    for path in possible_rf4s_paths:
                        if os.path.exists(path) and os.path.isdir(path):
                            rf4s_path = path
                            break
                            
                    if not rf4s_path:
                        issues.append("rf4s module directory not found")
                    else:
                        # Check required rf4s files
                        required_rf4s_files = [
                            'exceptions.py',
                            'player.py', 
                            'controller/__init__.py',
                            'component/__init__.py'
                        ]
                        
                        for file_path in required_rf4s_files:
                            full_path = os.path.join(rf4s_path, file_path)
                            if not os.path.exists(full_path):
                                issues.append(f"Missing rf4s file: {file_path}")
                                
                    # Check Python dependencies
                    try:
                        import yaml
                    except ImportError:
                        issues.append("PyYAML not installed (pip install pyyaml)")
                        
                    try:
                        import pyautogui
                    except ImportError:
                        issues.append("PyAutoGUI not installed (pip install pyautogui)")
                        
                    # Check config file
                    config_path = os.path.join(os.getcwd(), 'config.yaml')
                    if not os.path.exists(config_path):
                        issues.append("config.yaml not found in current directory")
                        
                    return issues
                    
                def start_script(self, launch_options: str = "", profile: str = ""):
                    """Start the fishing script with validation."""
                    if self.is_running:
                        raise Exception("Script is already running")
                        
                    # Validate environment first
                    validation_issues = self.validate_script_environment()
                    if validation_issues:
                        error_msg = "Environment validation failed:\n" + "\n".join(f"‚Ä¢ {issue}" for issue in validation_issues)
                        raise Exception(error_msg)
                        
                    # Build command
                    cmd = [sys.executable, self.script_path]
                    
                    # Add profile selection if specified
                    if profile and profile.strip():
                        cmd.extend(['-N', profile])
                        
                    # Add launch options
                    if launch_options and launch_options.strip():
                        options = self._parse_launch_options(launch_options)
                        cmd.extend(options)
                        
                    # Set working directory
                    working_dir = os.getcwd()  # Use current working directory
                    
                    # Start process
                    try:
                        self.output_received.emit(f"üîß Command: {' '.join(cmd)}")
                        self.output_received.emit(f"üìÅ Working directory: {working_dir}")
                        self.output_received.emit(f"üêç Python: {sys.executable}")
                        
                        # Use subprocess.Popen with better error handling
                        self.process = subprocess.Popen(
                            cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            cwd=working_dir,
                            text=True,
                            bufsize=1,
                            universal_newlines=True,
                            env=self._get_enhanced_environment()
                        )
                        
                        self.is_running = True
                        self.monitor_timer.start(2000)  # Monitor every 2 seconds
                        self.output_received.emit(f"‚úÖ Script started successfully (PID: {self.process.pid})")
                        
                        # Start output monitoring threads
                        self._start_output_monitoring()
                        
                    except Exception as e:
                        if self.process:
                            try:
                                self.process.terminate()
                            except:
                                pass
                            self.process = None
                        raise Exception(f"Failed to start script: {str(e)}")
                        
                def _get_enhanced_environment(self):
                    """Get enhanced environment variables for the script."""
                    env = os.environ.copy()
                    
                    # Add current directory to PYTHONPATH
                    current_dir = os.getcwd()
                    python_path = env.get('PYTHONPATH', '')
                    if python_path:
                        env['PYTHONPATH'] = f"{current_dir}{os.pathsep}{python_path}"
                    else:
                        env['PYTHONPATH'] = current_dir
                        
                    # Ensure rf4s is in path if it exists
                    rf4s_parent = None
                    for possible_path in [current_dir, os.path.dirname(current_dir)]:
                        if os.path.exists(os.path.join(possible_path, 'rf4s')):
                            rf4s_parent = possible_path
                            break
                            
                    if rf4s_parent and rf4s_parent not in env['PYTHONPATH']:
                        env['PYTHONPATH'] = f"{rf4s_parent}{os.pathsep}{env['PYTHONPATH']}"
                        
                    # Set console encoding for Windows
                    if os.name == 'nt':
                        env['PYTHONIOENCODING'] = 'utf-8'
                        
                    return env
                    
                def _start_output_monitoring(self):
                    """Start threads to monitor subprocess output."""
                    def read_stdout():
                        try:
                            for line in iter(self.process.stdout.readline, ''):
                                if line.strip():
                                    self.output_received.emit(line.rstrip())
                            self.process.stdout.close()
                        except Exception as e:
                            self.error_received.emit(f"stdout monitoring error: {e}")
                            
                    def read_stderr():
                        try:
                            for line in iter(self.process.stderr.readline, ''):
                                if line.strip():
                                    # Filter out some common harmless warnings
                                    line_clean = line.rstrip()
                                    if not self._is_harmless_error(line_clean):
                                        self.error_received.emit(line_clean)
                            self.process.stderr.close()
                        except Exception as e:
                            self.error_received.emit(f"stderr monitoring error: {e}")
                    
                    stdout_thread = threading.Thread(target=read_stdout, daemon=True)
                    stderr_thread = threading.Thread(target=read_stderr, daemon=True)
                    
                    stdout_thread.start()
                    stderr_thread.start()
                    
                def _is_harmless_error(self, error_line):
                    """Check if error line is harmless and can be filtered."""
                    harmless_patterns = [
                        "UserWarning:",
                        "FutureWarning:",
                        "DeprecationWarning:",
                        "DEBUG:",
                        "INFO:",
                    ]
                    
                    return any(pattern in error_line for pattern in harmless_patterns)
                    
                def _parse_launch_options(self, options_string):
                    """Parse launch options string into list of arguments."""
                    import shlex
                    try:
                        return shlex.split(options_string)
                    except ValueError:
                        return options_string.split()
                        
                def stop_script(self):
                    """Stop the running script gracefully."""
                    if not self.is_running:
                        return
                        
                    try:
                        self.monitor_timer.stop()
                        
                        if self.process:
                            self.output_received.emit("üîÑ Attempting graceful shutdown...")
                            
                            try:
                                # Try graceful termination first
                                self.process.terminate()
                                
                                # Wait for graceful termination
                                try:
                                    exit_code = self.process.wait(timeout=10)
                                    self.output_received.emit("‚úÖ Script stopped gracefully")
                                except subprocess.TimeoutExpired:
                                    self.output_received.emit("‚ö†Ô∏è Graceful shutdown failed, forcing termination...")
                                    self.process.kill()
                                    exit_code = self.process.wait(timeout=5)
                                    
                                self.finished.emit(exit_code)
                                
                            except Exception as e:
                                self.error_received.emit(f"Error terminating process: {e}")
                                
                    except Exception as e:
                        self.error_received.emit(f"Error stopping script: {str(e)}")
                    finally:
                        self.is_running = False
                        self.process = None
                        
                def _find_script_path(self):
                    """Find the main script file with enhanced search."""
                    possible_paths = [
                        "tools/main.py",
                        "main.py",
                        "rf4s/main.py",
                        "src/main.py"
                    ]
                    
                    # Check in current directory and common subdirectories
                    search_dirs = [
                        os.getcwd(),
                        os.path.dirname(os.getcwd()),
                        os.path.join(os.getcwd(), 'RussianFishing4Script'),
                        os.path.join(os.getcwd(), 'russian-fishing-4-script')
                    ]
                    
                    for base_dir in search_dirs:
                        for relative_path in possible_paths:
                            full_path = os.path.join(base_dir, relative_path)
                            if os.path.exists(full_path) and os.path.isfile(full_path):
                                return os.path.abspath(full_path)
                    
                    return None
                    
                def _monitor_process(self):
                    """Monitor the running process."""
                    if not self.is_running or not self.process:
                        self.monitor_timer.stop()
                        return
                        
                    try:
                        poll = self.process.poll()
                        if poll is not None:  # Process has finished
                            self.monitor_timer.stop()
                            self.is_running = False
                            self.finished.emit(poll)
                            self.process = None
                            
                    except Exception as e:
                        self.error_received.emit(f"Process monitoring error: {str(e)}")
                        
                def get_script_info(self):
                    """Get detailed information about the script environment."""
                    info = []
                    
                    # Script path
                    script_path = self._find_script_path()
                    if script_path:
                        info.append(f"‚úÖ Script found: {script_path}")
                        try:
                            size = os.path.getsize(script_path)
                            info.append(f"üìä Script size: {size} bytes")
                            mtime = os.path.getmtime(script_path)
                            import datetime
                            mod_time = datetime.datetime.fromtimestamp(mtime).strftime('%Y-%m-%d %H:%M:%S')
                            info.append(f"üìÖ Last modified: {mod_time}")
                        except Exception:
                            pass
                    else:
                        info.append("‚ùå Script not found")
                        
                    # Python info
                    info.append(f"üêç Python: {sys.executable}")
                    info.append(f"üìã Python version: {sys.version}")
                    info.append(f"üìÅ Working directory: {os.getcwd()}")
                    
                    # Environment check
                    validation_issues = self.validate_script_environment()
                    if validation_issues:
                        info.append("‚ö†Ô∏è Environment issues:")
                        for issue in validation_issues:
                            info.append(f"  ‚Ä¢ {issue}")
                    else:
                        info.append("‚úÖ Environment validation passed")
                    
                    return info
        üìÑ setup_gui.py
            #!/usr/bin/env python3
            """
            Setup script for Russian Fishing 4 Script GUI
            –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è GUI
            """
            
            import subprocess
            import sys
            import os
            from pathlib import Path
            
            def check_python_version():
                """–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ Python."""
                if sys.version_info < (3, 8):
                    print("‚ùå –¢—Ä–µ–±—É–µ—Ç—Å—è Python 3.8 –∏–ª–∏ –≤—ã—à–µ")
                    print(f"   –¢–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è: {sys.version}")
                    return False
                print(f"‚úÖ Python –≤–µ—Ä—Å–∏—è: {sys.version}")
                return True
            
            def install_requirements():
                """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π."""
                requirements_file = "gui/requirements_gui.txt"
                
                if not os.path.exists(requirements_file):
                    requirements_file = "requirements_gui.txt"
                
                if not os.path.exists(requirements_file):
                    print("‚ùå –§–∞–π–ª requirements_gui.txt –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return False
                
                try:
                    print("üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π...")
                    subprocess.check_call([
                        sys.executable, "-m", "pip", "install", 
                        "--upgrade", "pip"
                    ])
                    
                    subprocess.check_call([
                        sys.executable, "-m", "pip", "install", 
                        "-r", requirements_file
                    ])
                    
                    print("‚úÖ –í—Å–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
                    return True
                except subprocess.CalledProcessError as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: {e}")
                    return False
            
            def check_main_script():
                """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞."""
                possible_paths = [
                    "tools/main.py",
                    "main.py", 
                    "rf4s/main.py"
                ]
                
                for path in possible_paths:
                    if os.path.exists(path):
                        print(f"‚úÖ –û—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç –Ω–∞–π–¥–µ–Ω: {path}")
                        return True
                
                print("‚ö†Ô∏è  –û—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
                print("   –û–∂–∏–¥–∞–µ–º—ã–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è:")
                for path in possible_paths:
                    print(f"   - {path}")
                return False
            
            def create_directories():
                """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π."""
                dirs = ["screenshots", "logs", "gui/assets"]
                
                for dir_path in dirs:
                    try:
                        os.makedirs(dir_path, exist_ok=True)
                        print(f"‚úÖ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å–æ–∑–¥–∞–Ω–∞: {dir_path}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å {dir_path}: {e}")
            
            def test_imports():
                """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–ø–æ—Ä—Ç–æ–≤."""
                imports_to_test = [
                    ("PyQt6.QtWidgets", "PyQt6"),
                    ("yaml", "PyYAML"),
                    ("psutil", "psutil"),
                ]
                
                print("üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–ø–æ—Ä—Ç–æ–≤...")
                
                for module, package in imports_to_test:
                    try:
                        __import__(module)
                        print(f"‚úÖ {package} –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ")
                    except ImportError as e:
                        print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ {package}: {e}")
                        return False
                
                return True
            
            def main():
                """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏."""
                print("üöÄ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Russian Fishing 4 Script GUI")
                print("=" * 50)
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ Python
                if not check_python_version():
                    sys.exit(1)
                
                # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
                if not install_requirements():
                    print("\n‚ùå –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏–∑-–∑–∞ –æ—à–∏–±–æ–∫")
                    sys.exit(1)
                
                # –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–ø–æ—Ä—Ç–æ–≤
                if not test_imports():
                    print("\n‚ùå –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –º–æ–¥—É–ª–∏ –Ω–µ –∏–º–ø–æ—Ä—Ç–∏—Ä—É—é—Ç—Å—è")
                    sys.exit(1)
                
                # –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
                create_directories()
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞
                check_main_script()
                
                print("\n" + "=" * 50)
                print("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!")
                print("\nüìã –î–ª—è –∑–∞–ø—É—Å–∫–∞ GUI –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:")
                print("   python gui/run_gui.py")
                print("   –∏–ª–∏")
                print("   python run_gui.py  (–µ—Å–ª–∏ —Ñ–∞–π–ª—ã –≤ –∫–æ—Ä–Ω–µ)")
                
                print("\nüìö –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:")
                print("   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ tools/main.py")
                print("   - –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ config.yaml")
                print("   - –õ–æ–≥–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –ø–∞–ø–∫—É logs/")
                print("   - –°–∫—Ä–∏–Ω—à–æ—Ç—ã —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –ø–∞–ø–∫—É screenshots/")
            
            if __name__ == "__main__":
                main()
        üìÑ translations.py
            """
            Multi-language support for Russian Fishing 4 Script GUI
            Complete translations implementation
            """
            
            class Translations:
                """Manages interface translations with full Russian support."""
                
                def __init__(self):
                    self.translations = {
                        "en": {
                            # Main window
                            "window_title": "Russian Fishing 4 Script GUI v1.0",
                            "language": "Language:",
                            "load_config": "üìÅ Load Config",
                            "save_config": "üíæ Save Config", 
                            "reset_default": "üîÑ Reset to Default",
                            
                            # Tabs
                            "script_settings": "‚öôÔ∏è Script Settings",
                            "key_bindings": "üéÆ Key Bindings",
                            "player_stats": "üìä Player Stats",
                            "fishing_profiles": "üé£ Fishing Profiles",
                            "friction_brake": "üîß Friction Brake",
                            "keepnet": "üóÉÔ∏è Keepnet",
                            "notifications": "üìß Notifications",
                            
                            # Script settings
                            "general_settings": "General Settings",
                            "detection_settings": "Detection Settings",
                            "advanced_settings": "Advanced Settings",
                            "script_language": "Script Language:",
                            "default_launch_options": "Default Launch Options:",
                            "smtp_verification": "SMTP Verification",
                            "image_verification": "Image Verification",
                            "snag_detection": "Snag Detection",
                            "spooling_detection": "Spooling Detection",
                            "random_rod_selection": "Random Rod Selection",
                            "spool_confidence": "Spool Confidence:",
                            
                            # Control panel
                            "quick_profile_selection": "Quick Profile Selection",
                            "launch_options": "Launch Options",
                            "script_control": "Script Control",
                            "start_script": "‚ñ∂Ô∏è Start Script",
                            "stop_script": "‚èπÔ∏è Stop Script",
                            "script_output": "Script Output",
                            "clear": "üóëÔ∏è Clear",
                            "save": "üíæ Save",
                            "auto_scroll": "Auto-scroll",
                            
                            # Messages
                            "ready": "Ready",
                            "config_loaded": "Configuration loaded successfully",
                            "config_saved": "Configuration saved successfully",
                            "script_running": "Script is running...",
                            "script_stopped": "Script stopped",
                            "script_completed": "Script completed successfully",
                            
                            # Status
                            "no_config": "No config",
                            "script_status_stopped": "Script: Stopped",
                            "script_status_running": "Script: Running",
                            "script_status_error": "Script: Error",
                        },
                        "ru": {
                            # Main window
                            "window_title": "Russian Fishing 4 Script GUI v1.0",
                            "language": "–Ø–∑—ã–∫:",
                            "load_config": "üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥",
                            "save_config": "üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥",
                            "reset_default": "üîÑ –°–±—Ä–æ—Å–∏—Ç—å –∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–º",
                            
                            # Tabs
                            "script_settings": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞",
                            "key_bindings": "üéÆ –ü—Ä–∏–≤—è–∑–∫–∏ –∫–ª–∞–≤–∏—à",
                            "player_stats": "üìä –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞",
                            "fishing_profiles": "üé£ –ü—Ä–æ—Ñ–∏–ª–∏ —Ä—ã–±–∞–ª–∫–∏",
                            "friction_brake": "üîß –§—Ä–∏–∫—Ü–∏–æ–Ω–Ω—ã–π —Ç–æ—Ä–º–æ–∑",
                            "keepnet": "üóÉÔ∏è –°–∞–¥–æ–∫",
                            "notifications": "üìß –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è",
                            
                            # Script settings
                            "general_settings": "–û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
                            "detection_settings": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è",
                            "advanced_settings": "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
                            "script_language": "–Ø–∑—ã–∫ —Å–∫—Ä–∏–ø—Ç–∞:",
                            "default_launch_options": "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –æ–ø—Ü–∏–∏ –∑–∞–ø—É—Å–∫–∞:",
                            "smtp_verification": "SMTP –ø—Ä–æ–≤–µ—Ä–∫–∞",
                            "image_verification": "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π",
                            "snag_detection": "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∑–∞—Ü–µ–ø–æ–≤",
                            "spooling_detection": "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Å–º–∞—Ç—ã–≤–∞–Ω–∏—è",
                            "random_rod_selection": "–°–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä —É–¥–æ—á–∫–∏",
                            "spool_confidence": "–¢–æ—á–Ω–æ—Å—Ç—å –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å–º–∞—Ç—ã–≤–∞–Ω–∏—è:",
                            
                            # Control panel
                            "quick_profile_selection": "–ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä –ø—Ä–æ—Ñ–∏–ª—è",
                            "launch_options": "–û–ø—Ü–∏–∏ –∑–∞–ø—É—Å–∫–∞",
                            "script_control": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–æ–º",
                            "start_script": "‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–∫—Ä–∏–ø—Ç",
                            "stop_script": "‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–∫—Ä–∏–ø—Ç",
                            "script_output": "–í—ã–≤–æ–¥ —Å–∫—Ä–∏–ø—Ç–∞",
                            "clear": "üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å",
                            "save": "üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
                            "auto_scroll": "–ê–≤—Ç–æ-–ø—Ä–æ–∫—Ä—É—Ç–∫–∞",
                            
                            # Messages
                            "ready": "–ì–æ—Ç–æ–≤",
                            "config_loaded": "–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ",
                            "config_saved": "–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ", 
                            "script_running": "–°–∫—Ä–∏–ø—Ç –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è...",
                            "script_stopped": "–°–∫—Ä–∏–ø—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                            "script_completed": "–°–∫—Ä–∏–ø—Ç –∑–∞–≤–µ—Ä—à—ë–Ω —É—Å–ø–µ—à–Ω–æ",
                            
                            # Status
                            "no_config": "–ù–µ—Ç –∫–æ–Ω—Ñ–∏–≥–∞",
                            "script_status_stopped": "–°–∫—Ä–∏–ø—Ç: –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                            "script_status_running": "–°–∫—Ä–∏–ø—Ç: –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è",
                            "script_status_error": "–°–∫—Ä–∏–ø—Ç: –û—à–∏–±–∫–∞",
                        }
                    }
                    
                def get_text(self, key: str, language: str = "en") -> str:
                    """Get translated text for key."""
                    return self.translations.get(language, {}).get(key, key)
                    
                def get_all_keys(self, language: str = "en") -> dict:
                    """Get all translations for a language."""
                    return self.translations.get(language, {})
        üìÑ ui_theme.py
            """
            UI Theme and styling for Russian Fishing 4 Script GUI
            Improved colors and readability
            """
            
            def get_light_theme():
                """Light theme with good contrast."""
                return """
                QMainWindow {
                    background-color: #f5f5f5;
                    color: #333333;
                }
                
                QTabWidget::pane {
                    border: 1px solid #cccccc;
                    background-color: #ffffff;
                }
                
                QTabWidget::tab-bar {
                    alignment: left;
                }
                
                QTabBar::tab {
                    background-color: #e1e1e1;
                    color: #333333;
                    border: 1px solid #cccccc;
                    border-bottom: none;
                    padding: 8px 16px;
                    margin-right: 2px;
                }
                
                QTabBar::tab:selected {
                    background-color: #ffffff;
                    color: #000000;
                    font-weight: bold;
                }
                
                QTabBar::tab:hover {
                    background-color: #d4edda;
                }
                
                QGroupBox {
                    font-weight: bold;
                    color: #2c3e50;
                    border: 2px solid #bdc3c7;
                    border-radius: 5px;
                    margin-top: 10px;
                    padding-top: 5px;
                    background-color: #ffffff;
                }
                
                QGroupBox::title {
                    subcontrol-origin: margin;
                    left: 10px;
                    padding: 0 10px 0 10px;
                    color: #2c3e50;
                    background-color: #ffffff;
                }
                
                QLabel {
                    color: #2c3e50;
                    background-color: transparent;
                }
                
                QLineEdit {
                    border: 1px solid #bdc3c7;
                    border-radius: 3px;
                    padding: 5px;
                    background-color: #ffffff;
                    color: #2c3e50;
                }
                
                QLineEdit:focus {
                    border: 2px solid #3498db;
                }
                
                QComboBox {
                    border: 1px solid #bdc3c7;
                    border-radius: 3px;
                    padding: 5px;
                    background-color: #ffffff;
                    color: #2c3e50;
                    min-width: 100px;
                }
                
                QComboBox:hover {
                    border: 1px solid #3498db;
                }
                
                QComboBox::drop-down {
                    border: none;
                    width: 20px;
                }
                
                QComboBox::down-arrow {
                    image: none;
                    border: 1px solid #bdc3c7;
                    width: 0;
                    height: 0;
                    border-left: 5px solid transparent;
                    border-right: 5px solid transparent;
                    border-top: 5px solid #2c3e50;
                }
                
                QSpinBox, QDoubleSpinBox {
                    border: 1px solid #bdc3c7;
                    border-radius: 3px;
                    padding: 5px;
                    background-color: #ffffff;
                    color: #2c3e50;
                }
                
                QSpinBox:focus, QDoubleSpinBox:focus {
                    border: 2px solid #3498db;
                }
                
                QPushButton {
                    background-color: #3498db;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    font-weight: bold;
                    min-width: 80px;
                }
                
                QPushButton:hover {
                    background-color: #2980b9;
                }
                
                QPushButton:pressed {
                    background-color: #21618c;
                }
                
                QPushButton:disabled {
                    background-color: #bdc3c7;
                    color: #7f8c8d;
                }
                
                QCheckBox {
                    color: #2c3e50;
                    spacing: 5px;
                }
                
                QCheckBox::indicator {
                    width: 16px;
                    height: 16px;
                    border: 1px solid #bdc3c7;
                    border-radius: 3px;
                    background-color: #ffffff;
                }
                
                QCheckBox::indicator:checked {
                    background-color: #27ae60;
                    border: 1px solid #27ae60;
                }
                
                QCheckBox::indicator:checked::after {
                    content: "‚úì";
                    color: white;
                    font-weight: bold;
                }
                
                QTextEdit {
                    border: 1px solid #bdc3c7;
                    border-radius: 3px;
                    background-color: #2c3e50;
                    color: #ecf0f1;
                    font-family: 'Consolas', 'Monaco', monospace;
                    font-size: 9pt;
                    selection-background-color: #3498db;
                }
                
                QScrollArea {
                    border: 1px solid #bdc3c7;
                    border-radius: 3px;
                    background-color: #ffffff;
                }
                
                QScrollBar:vertical {
                    background-color: #ecf0f1;
                    width: 15px;
                    border-radius: 7px;
                }
                
                QScrollBar::handle:vertical {
                    background-color: #bdc3c7;
                    min-height: 20px;
                    border-radius: 7px;
                }
                
                QScrollBar::handle:vertical:hover {
                    background-color: #95a5a6;
                }
                
                QProgressBar {
                    border: 1px solid #bdc3c7;
                    border-radius: 3px;
                    text-align: center;
                    background-color: #ecf0f1;
                }
                
                QProgressBar::chunk {
                    background-color: #27ae60;
                    border-radius: 3px;
                }
                
                QStatusBar {
                    background-color: #34495e;
                    color: #ecf0f1;
                    border-top: 1px solid #bdc3c7;
                }
                
                QStatusBar QLabel {
                    color: #ecf0f1;
                    padding: 2px 5px;
                }
                """
            
            def get_dark_theme():
                """Dark theme with good contrast."""
                return """
                QMainWindow {
                    background-color: #2b2b2b;
                    color: #ffffff;
                }
                
                QTabWidget::pane {
                    border: 1px solid #555555;
                    background-color: #3c3c3c;
                }
                
                QTabBar::tab {
                    background-color: #404040;
                    color: #ffffff;
                    border: 1px solid #555555;
                    border-bottom: none;
                    padding: 8px 16px;
                    margin-right: 2px;
                }
                
                QTabBar::tab:selected {
                    background-color: #3c3c3c;
                    color: #ffffff;
                    font-weight: bold;
                }
                
                QTabBar::tab:hover {
                    background-color: #4a4a4a;
                }
                
                QGroupBox {
                    font-weight: bold;
                    color: #ffffff;
                    border: 2px solid #555555;
                    border-radius: 5px;
                    margin-top: 10px;
                    padding-top: 5px;
                    background-color: #3c3c3c;
                }
                
                QGroupBox::title {
                    subcontrol-origin: margin;
                    left: 10px;
                    padding: 0 10px 0 10px;
                    color: #ffffff;
                    background-color: #3c3c3c;
                }
                
                QLabel {
                    color: #ffffff;
                    background-color: transparent;
                }
                
                QLineEdit {
                    border: 1px solid #555555;
                    border-radius: 3px;
                    padding: 5px;
                    background-color: #404040;
                    color: #ffffff;
                }
                
                QLineEdit:focus {
                    border: 2px solid #0078d4;
                }
                
                QComboBox {
                    border: 1px solid #555555;
                    border-radius: 3px;
                    padding: 5px;
                    background-color: #404040;
                    color: #ffffff;
                    min-width: 100px;
                }
                
                QComboBox:hover {
                    border: 1px solid #0078d4;
                }
                
                QComboBox QAbstractItemView {
                    background-color: #404040;
                    color: #ffffff;
                    border: 1px solid #555555;
                    selection-background-color: #0078d4;
                }
                
                QPushButton {
                    background-color: #0078d4;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    font-weight: bold;
                    min-width: 80px;
                }
                
                QPushButton:hover {
                    background-color: #106ebe;
                }
                
                QPushButton:pressed {
                    background-color: #005a9e;
                }
                
                QPushButton:disabled {
                    background-color: #555555;
                    color: #888888;
                }
                
                QCheckBox {
                    color: #ffffff;
                    spacing: 5px;
                }
                
                QCheckBox::indicator {
                    width: 16px;
                    height: 16px;
                    border: 1px solid #555555;
                    border-radius: 3px;
                    background-color: #404040;
                }
                
                QCheckBox::indicator:checked {
                    background-color: #0078d4;
                    border: 1px solid #0078d4;
                }
                
                QTextEdit {
                    border: 1px solid #555555;
                    border-radius: 3px;
                    background-color: #1e1e1e;
                    color: #ffffff;
                    font-family: 'Consolas', 'Monaco', monospace;
                    font-size: 9pt;
                    selection-background-color: #0078d4;
                }
                
                QSpinBox, QDoubleSpinBox {
                    border: 1px solid #555555;
                    border-radius: 3px;
                    padding: 5px;
                    background-color: #404040;
                    color: #ffffff;
                }
                
                QScrollArea {
                    border: 1px solid #555555;
                    border-radius: 3px;
                    background-color: #3c3c3c;
                }
                
                QStatusBar {
                    background-color: #2b2b2b;
                    color: #ffffff;
                    border-top: 1px solid #555555;
                }
                
                QStatusBar QLabel {
                    color: #ffffff;
                    padding: 2px 5px;
                }
                """
        üìÅ gui/
            üìÅ assets/
        üìÅ logs/
        üìÅ screenshots/
        üìÅ __pycache__/
            üìÑ config_manager.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ main_window.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ script_runner.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ translations.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ ui_theme.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
    üìÅ logs/
    üìÅ rf4s/
        üìÑ exceptions.py
            """
            A module reserved for exception classes.
            """
            
            
            class FishHookedError(Exception):
                """A fish is hooked during a wrong routine."""
            
            
            class FishCapturedError(Exception):
                """A fish is captured during a wrong routine."""
            
            
            class LineAtEndError(Exception):
                """Fishing line is at the end during retrieval."""
            
            
            class LineSnaggedError(Exception):
                """Fishing line is snagged."""
            
            
            class ItemNotFoundError(Exception):
                """Failed to find an available item for replacement."""
            
            
            class LureBrokenError(Exception):
                """Lure is broken."""
            
            
            class TackleBrokenError(Exception):
                """Tackle is broken."""
            
            
            class DisconnectedError(Exception):
                """Disconnected from the game."""
            
            
            class TicketExpiredError(Exception):
                """Ticket expired."""
        üìÑ player.py
            """Module for Player class.
            
            This module provides the main interface for automating fishing activities in a game.
            It includes functionality for managing fishing loops, handling player stats, and
            automating various fishing techniques.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import logging
            import msvcrt
            import os
            import random
            import sys
            from contextlib import contextmanager
            from datetime import datetime
            from multiprocessing import Lock
            
            # from email.mime.image import MIMEImage
            from pathlib import Path
            from time import sleep
            
            import pyautogui as pag
            from playsound import playsound
            from pynput import keyboard
            from rich import box, print
            from rich.table import Table
            
            from rf4s import exceptions, utils
            from rf4s.component.friction_brake import FrictionBrake
            from rf4s.component.tackle import Tackle
            from rf4s.controller.detection import Detection, TagColor
            from rf4s.controller.notification import (
                DiscordColor,
                DiscordNotification,
                EmailNotification,
                MiaotixingNotification,
            )
            from rf4s.controller.timer import Timer
            from rf4s.controller.window import Window
            from rf4s.result.result import RF4SResult
            
            logger = logging.getLogger("rich")
            random.seed(datetime.now().timestamp())
            
            PRE_RETRIEVAL_DURATION = 0.5
            PULL_OUT_DELAY = 3
            DIG_DELAY = 5
            DIG_TIMEOUT = 32
            ANIMATION_DELAY = 1
            TICKET_EXPIRE_DELAY = 16
            DISCONNECTED_DELAY = 8
            WEAR_TEXT_UPDATE_DELAY = 2
            PUT_DOWN_DELAY = 4
            
            SCREENSHOT_DELAY = 2
            
            TROLLING_KEY = "j"
            
            FORWARD = "w"
            LEFT_KEY = "a"
            RIGHT_KEY = "d"
            
            
            class Player:
                """Main interface of fishing loops and stages.
            
                This class manages the automation of fishing activities, including casting,
                retrieving, and handling fish. It also handles player stats, equipment, and
                various in-game mechanics.
            
                :param cfg: Configuration object containing settings for the fishing process.
                :type cfg: Config
                :param window: Window object for managing the game window.
                :type window: Window
                """
            
                def __init__(self, cfg, window: Window):
                    """Initialize monitor, timer, and some trivial counters.
            
                    :param cfg: Configuration object containing settings for the fishing process.
                    :type cfg: Config
                    :param window: Window object for managing the game window.
                    :type window: Window
                    """
                    self.cfg = cfg
                    self.window = window
                    self.timer = Timer(cfg)
                    self.detection = Detection(cfg, window)
            
                    self.tackle_idx = 0
                    if self.cfg.SELECTED.MODE == "bottom":
                        self.num_tackle = len(self.cfg.KEY.BOTTOM_RODS)
                    else:
                        self.num_tackle = 1
                    self.tackles = [
                        Tackle(cfg, self.timer, self.detection) for _ in range(self.num_tackle)
                    ]
                    self.tackle = self.tackles[self.tackle_idx]
            
                    self.friction_brake_lock = Lock()
                    self.friction_brake = FrictionBrake(
                        cfg, self.friction_brake_lock, self.detection
                    )
            
                    self.cur_coffee = 0
                    self.have_new_lure = True
                    self.have_new_groundbait = True
                    self.have_new_dry_mix = True
                    self.have_new_pva = True
                    self.result = RF4SResult()
            
                    self.clicklock_enabled = False
            
                def start_fishing(self) -> None:
                    """Start the main fishing loop with the specified fishing strategy."""
                    if self.cfg.ARGS.FRICTION_BRAKE:
                        logger.info("Spawing new process, do not quit the script")
                        self.friction_brake.monitor_process.start()
            
                    if (
                        self.cfg.SELECTED.MODE not in ("telescopic", "bottom")
                        and not self.cfg.ARGS.SKIP_CAST
                        and not self.detection.is_retrieval_finished()
                    ):
                        logger.critical(
                            "The spool is not fully loaded, "
                            "try moving your camera, "
                            "changing your game window size or fishing line"
                        )
                        utils.safe_exit()
            
                    logger.info("Starting fishing mode: '%s'", self.cfg.SELECTED.MODE)
                    self._start_trolling()
                    getattr(self, f"start_{self.cfg.SELECTED.MODE}_mode")()
            
                # ---------------------------------------------------------------------------- #
                #                              main fishing loops                              #
                # ---------------------------------------------------------------------------- #
                def start_spin_mode(self) -> None:
                    """Main spin fishing loop for 'spin' and 'spin_with_pause' modes."""
                    skip_cast = self.cfg.ARGS.SKIP_CAST
                    while True:
                        if not skip_cast:
                            self._refill_stats()
                            self._harvest_baits(pickup=True)
                            self.reset_tackle()
                            self._change_tackle_lure()
                            self._cast_tackle()
                        skip_cast = False
            
                        if self.cfg.SELECTED.TYPE != "normal":
                            utils.hold_mouse_button(self.cfg.SELECTED.TIGHTEN_DURATION)
                            getattr(self, f"retrieve_with_{self.cfg.SELECTED.TYPE}")()
                        self.retrieve_line()
            
                        if self.detection.is_fish_hooked():
                            self.pull_fish()
            
                def retrieve_with_pause(self) -> None:
                    """Retrieve the line, pausing periodically."""
                    logger.info("Retrieving fishing line with pause")
                    self.tackle._special_retrieve(button="left")
            
                def retrieve_with_lift(self) -> None:
                    """Retrieve the line, lifting periodically."""
                    logger.info("Retrieving fishing line with lift")
                    with self.toggle_clicklock():
                        self.tackle._special_retrieve(button="right")
            
                def start_bottom_mode(self) -> None:
                    """Main bottom fishing loop."""
                    check_miss_counts = [0] * self.num_tackle
            
                    while True:
                        if self.cfg.ARGS.SPOD_ROD and self.timer.is_spod_rod_castable():
                            self._cast_spod_rod()
                        self._refill_stats()
                        self._harvest_baits()
            
                        logger.info("Checking rod %s", self.tackle_idx + 1)
                        pag.press(str(self.cfg.KEY.BOTTOM_RODS[self.tackle_idx]))
                        sleep(ANIMATION_DELAY)
                        if self.detection.is_fish_hooked():
                            check_miss_counts[self.tackle_idx] = 0
                            self.retrieve_and_recast()
                        else:
                            sleep(self.cfg.SELECTED.PUT_DOWN_DELAY)
                            if self.detection.is_fish_hooked():
                                check_miss_counts[self.tackle_idx] = 0
                                self.retrieve_and_recast()
                            else:
                                self._put_down_tackle(check_miss_counts)
                        self._update_tackle()
            
                def retrieve_and_recast(self) -> None:
                    self.retrieve_line()
                    self.pull_fish()
                    self.reset_tackle()
                    self._refill_groundbait()
                    self._refill_pva()
                    self._cast_tackle(lock=True)
            
                def start_pirk_mode(self) -> None:
                    """Main marine fishing loop for pirk mode."""
                    self._start_sink_mode(pirk=True)
            
                def start_elevator_mode(self) -> None:
                    """Main marine fishing loop for elevator mode."""
                    self._start_sink_mode(pirk=False)
            
                def _start_sink_mode(self, pirk: bool) -> None:
                    """Main marine fishing loop for pirk or elevator mode.
            
                    :param pirk: Whether to perform pirking or elevating.
                    :type pirk: bool
                    """
                    perform_technique = self.do_pirking if pirk else self.do_elevating
                    skip_cast = self.cfg.ARGS.SKIP_CAST
                    while True:
                        if not skip_cast:
                            self._refill_stats()
                            self.reset_tackle()
                            self._cast_tackle()
                            self.tackle.sink()
                        skip_cast = False
            
                        perform_technique()
                        self.retrieve_line()
                        self.pull_fish()
            
                def start_telescopic_mode(self) -> None:
                    """Main telescopic fishing loop."""
                    self._start_float_mode(telescopic=True)
            
                def start_bolognese_mode(self) -> None:
                    """Main bolognese fishing loop."""
                    self._start_float_mode(telescopic=False)
            
                def _start_float_mode(self, telescopic: bool) -> None:
                    """Main float fishing loop.
            
                    :param telescopic: Whether the fishing mode is telescopic.
                    :type telescopic: bool
                    """
                    monitor, hold_mouse_button = self._get_controllers(telescopic)
            
                    while True:
                        self._refill_stats()
                        self._harvest_baits(pickup=True)
                        self.reset_tackle()
                        self._cast_tackle()
            
                        try:
                            with self.error_handler():
                                monitor()
                            sleep(self.cfg.SELECTED.PULL_DELAY)
                            hold_mouse_button(PRE_RETRIEVAL_DURATION)
                            self.pull_fish()
                        except TimeoutError:
                            pass
            
                def _harvest_baits(self, pickup: bool = False) -> None:
                    """Harvest baits if energy is high.
            
                    :param pickup: Whether to pick up the main rod after harvesting.
                    :type pickup: bool
                    """
                    if not self.cfg.ARGS.HARVEST or not self.detection.is_energy_high():
                        return
                    logger.info("Harvesting baits")
                    self._use_item("digging_tool")
                    sleep(PULL_OUT_DELAY)
                    pag.click()
            
                    i = DIG_TIMEOUT
                    while i > 0:
                        i = utils.sleep_and_decrease(i, DIG_DELAY)
                        if self.detection.is_harvest_success():
                            logger.info("Baits harvested successfully")
                            pag.press("space")
                            pag.press("backspace")
                            sleep(ANIMATION_DELAY)
                            self.result.bait += 1
                            break
            
                    if pickup:
                        self._use_item("main_rod")
                        sleep(PULL_OUT_DELAY)
            
                    # When timed out, do not raise a TimeoutError but defer it to resetting stage
            
                def _refill_stats(self) -> None:
                    """Refill player stats using tea and carrot."""
                    if not self.cfg.ARGS.REFILL:
                        return
            
                    logger.info("Refilling player stats")
                    # Comfort is affected by weather, add a check to avoid over drink
                    if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
                        self._use_item("tea")
                        self.result.tea += 1
            
                    if self.detection.is_hunger_low():
                        self._use_item("carrot")
                        self.result.carrot += 1
            
                def _drink_alcohol(self) -> None:
                    """Drink alcohol with the given quantity."""
                    if not self.cfg.ARGS.ALCOHOL or not self.timer.is_alcohol_drinkable():
                        return
            
                    logger.info("Drinking alcohol")
                    for _ in range(self.cfg.STAT.ALCOHOL_PER_DRINK):
                        self._use_item("alcohol")
                    self.result.alcohol += self.cfg.STAT.ALCOHOL_PER_DRINK
            
                def _drink_coffee(self) -> None:
                    """Drink coffee to refill energy if energy is low."""
                    if not self.cfg.ARGS.COFFEE or self.detection.is_energy_high():
                        return
            
                    if self.cur_coffee > self.cfg.STAT.COFFEE_LIMIT:
                        pag.press("esc")  # Just back to control panel to reduce power usage
                        self._handle_termination("Coffee limit reached", shutdown=False)
            
                    logger.info("Drinking coffee")
                    for _ in range(self.cfg.STAT.COFFEE_PER_DRINK):
                        self._use_item("coffee")
                    self.cur_coffee += self.cfg.STAT.COFFEE_PER_DRINK
                    self.result.coffee += self.cfg.STAT.COFFEE_PER_DRINK
            
                def _use_item(self, item: str) -> None:
                    """Access an item by name using quick selection shortcut or menu.
            
                    :param item: The name of the item to access.
                    :type item: str
                    """
                    logger.info("Using %s", item)
                    key = str(self.cfg.KEY[item.upper()])
                    if key != "-1":  # Use shortcut
                        pag.press(key)
                    else:  # Open food menu
                        with pag.hold("t"):
                            sleep(ANIMATION_DELAY)
                            food_position = self.detection.get_food_position(item)
                            pag.moveTo(food_position)
                            pag.click()
                    sleep(ANIMATION_DELAY)
            
                def enable_clicklock(self):
                    pag.mouseDown()
                    sleep(2.2)
                    self.clicklock_enabled = True
            
                def disable_clicklock(self):
                    pag.click()
                    self.clicklock_enabled = False
            
                @contextmanager
                def toggle_clicklock(self):
                    self.enable_clicklock()
                    yield
                    self.disable_clicklock()
            
                @utils.reset_friction_brake_after
                def reset_tackle(self) -> None:
                    """Reset the tackle until it is ready."""
                    sleep(ANIMATION_DELAY)
                    if self.detection.is_tackle_ready():
                        return
            
                    if self.detection.is_lure_broken():
                        self._handle_broken_lure()
                        return
            
                    if self.cfg.ARGS.SPOD_ROD and not self.detection.is_groundbait_chosen():
                        self._refill_dry_mix()
                        return
            
                    if not self.detection.is_bait_chosen():
                        if len(self.tackles) == 1:
                            self.general_quit("Run out of bait")
                        self.tackle.available = False
                        return
            
                    with self.toggle_clicklock():
                        while True:
                            try:
                                # Outer -> inner
                                with (
                                    self.error_handler(),
                                    self.clicklock_disable_handler(),
                                    pag.hold("shift"),
                                ):
                                    self.tackle.reset()
                                break
                            except TimeoutError:
                                # If it's a TimeoutError or an exception was transformed into a
                                # TimeoutError, enable clicklock again if necessary.
                                if not self.clicklock_enabled:
                                    self.enable_clicklock()
            
                @contextmanager
                def error_handler(self):
                    try:
                        yield
                    except exceptions.FishHookedError:
                        self.pull_fish()
                    except exceptions.FishCapturedError:
                        self.handle_fish()
                    except exceptions.LineAtEndError:
                        if self.cfg.ARGS.FRICTION_BRAKE:
                            with self.friction_brake.lock:
                                self.friction_brake.change(increase=False)
                        self.general_quit("Fishing line is at its end")
                    except exceptions.LineSnaggedError:
                        self._handle_snagged_line()
                    except exceptions.LureBrokenError:
                        self._handle_broken_lure()
                        raise TimeoutError  # Transform into TimeoutError to continue
                    except exceptions.TackleBrokenError:
                        self.general_quit("Tackle is broken")
                    except exceptions.DisconnectedError:
                        self.disconnected_quit()
                    except exceptions.TicketExpiredError:
                        self._handle_expired_ticket()
                        raise TimeoutError  # Transform into TimeoutError to continue
                    except TimeoutError:
                        raise
            
                @contextmanager
                def clicklock_disable_handler(self):
                    try:
                        yield
                    except (
                        exceptions.FishHookedError,
                        exceptions.FishCapturedError,
                        exceptions.LineAtEndError,
                        exceptions.LineSnaggedError,
                        exceptions.LureBrokenError,
                        exceptions.TackleBrokenError,
                        exceptions.DisconnectedError,
                        exceptions.TicketExpiredError,
                    ):
                        if self.clicklock_enabled:
                            self.disable_clicklock()
                        raise
            
                def _cast_spod_rod(self) -> None:
                    """Cast the spod rod if dry mix is available."""
                    self._use_item("spod_rod")
                    self.reset_tackle()
            
                    # If no dry mix is available, skip casting
                    if not self.tackle.available:
                        self.tackle.available = True
                        return
                    self._cast_tackle(lock=True, update=False)
                    pag.press("0")
                    sleep(ANIMATION_DELAY)
            
                def _cast_tackle(self, lock: bool = False, update: bool = True) -> None:
                    """Cast the current tackle.
            
                    :param lock: Whether to lock the tackle after casting.
                    :type lock: bool
                    :param update: Whether to update the cast time.
                    :type update: bool
                    """
                    if self.cfg.ARGS.PAUSE and self.timer.is_script_pausable():
                        self._pause_script()
            
                    if self.cfg.ARGS.BITE:
                        self.window.save_screenshot(self.timer.get_cur_timestamp())
            
                    if (
                        self.cfg.ARGS.RANDOM_CAST
                        and random.random() <= self.cfg.SCRIPT.RANDOM_CAST_PROBABILITY
                    ):
                        logger.info("Casting rod redundantly")
                        pag.click()
                        sleep(2)
                        self.reset_tackle()
            
                    self.tackle.cast(lock)
                    if update:
                        self.timer.update_cast_time()
            
                def retrieve_line(self) -> None:
                    """Retrieve the fishing line until it is fully retrieved."""
                    if self.detection.is_retrieval_finished():
                        return
            
                    first = True
                    gr_switched = False
                    if self.cfg.ARGS.ELECTRO:
                        self.tackle.switch_gear_ratio()  # Use electro mode
            
                    self.cur_coffee = 0
            
                    with self.toggle_clicklock():
                        while True:
                            try:
                                with (
                                    self.error_handler(),
                                    self.clicklock_disable_handler(),
                                ):
                                    self.tackle.retrieve(first)
                                break
                            except TimeoutError:
                                if not self.clicklock_enabled:
                                    self.enable_clicklock()
                                first = False
                                if self.cfg.ARGS.GEAR_RATIO and not gr_switched:
                                    self.tackle.switch_gear_ratio()
                                    gr_switched = True
                                pag.keyUp("shift")
                                self._drink_coffee()
            
                        pag.keyUp("shift")
                        if gr_switched:
                            self.tackle.switch_gear_ratio()
            
                def do_pirking(self) -> None:
                    """Perform pirking until a fish is hooked."""
                    if self.cfg.SELECTED.PIRK_RETRIEVAL:
                        with self.toggle_clicklock():
                            self._do_pirking()
                    else:
                        self._do_pirking()
            
                def _do_pirking(self) -> None:
                    while True:
                        try:
                            with self.error_handler(), self.clicklock_disable_handler():
                                self.tackle.pirk()
                            break
                        except TimeoutError:
                            if self.cfg.SELECTED.PIRK_RETRIEVAL:
                                if not self.clicklock_enabled:
                                    self.enable_clicklock()
                                continue
            
                            if self.cfg.SELECTED.DEPTH_ADJUST_DELAY > 0:
                                logger.info("Adjusting lure depth")
                                pag.press("enter")  # Open reel
                                sleep(self.cfg.SELECTED.DEPTH_ADJUST_DELAY)
                                utils.hold_mouse_button(self.cfg.SELECTED.DEPTH_ADJUST_DURATION)
                            else:
                                self.reset_tackle()
                                self._cast_tackle()
                                self.tackle.sink()
            
                def do_elevating(self) -> None:
                    """Perform elevating until a fish is hooked."""
                    dropped = False
                    while True:
                        try:
                            dropped = not dropped
                            with self.error_handler():
                                self.tackle.elevate(dropped)
                            break
                        except TimeoutError:
                            pass
            
                def pull_fish(self) -> None:
                    """Pull the fish up and handle it."""
                    if not self.detection.is_fish_hooked():
                        return
            
                    self._drink_alcohol()
                    with self.toggle_clicklock():
                        while True:
                            try:
                                with self.error_handler(), self.clicklock_disable_handler():
                                    self.tackle.pull()
                                self.handle_fish()
                                break
                            except TimeoutError:
                                self.disable_clicklock()
                                sleep(PUT_DOWN_DELAY)
                                if not self.clicklock_enabled:
                                    self.enable_clicklock()
            
                def _put_down_tackle(self, check_miss_counts: list[int]) -> None:
                    """Put down the tackle and wait for a while.
            
                    :param check_miss_counts: List of miss counts for all rods.
                    :type check_miss_counts: list[int]
                    """
                    check_miss_counts[self.tackle_idx] += 1
                    if check_miss_counts[self.tackle_idx] >= self.cfg.SELECTED.CHECK_MISS_LIMIT:
                        check_miss_counts[self.tackle_idx] = 0
                        self.reset_tackle()
                        self._refill_groundbait()
                        self._refill_pva()
                        self._cast_tackle(lock=True)
            
                    pag.press("0")
                    bound = self.cfg.SELECTED.CHECK_DELAY // 5
                    random_offset = random.uniform(-bound, bound)
                    sleep(self.cfg.SELECTED.CHECK_DELAY + random_offset)
            
                def _start_trolling(self) -> None:
                    """Start trolling and change moving direction based on the trolling setting."""
                    if self.cfg.ARGS.TROLLING is None:
                        return
                    logger.info("Starting trolling")
                    pag.press(TROLLING_KEY)
                    if self.cfg.ARGS.TROLLING not in ("left", "right"):  # Forward
                        return
                    pag.keyDown(LEFT_KEY if self.cfg.ARGS.TROLLING == "left" else RIGHT_KEY)
            
                def _update_tackle(self) -> None:
                    """Update the current tackle (rod) being used."""
                    candidates = self._get_available_rods()
                    if not candidates:
                        self.general_quit("All rods are unavailable")
                    if self.cfg.SCRIPT.RANDOM_ROD_SELECTION:
                        self.tackle_idx = random.choice(candidates)
                    else:
                        self.tackle_idx = candidates[0]
                    self.tackle = self.tackles[self.tackle_idx]
            
                def _get_available_rods(self) -> list[int]:
                    """
                    Get a list of available rods.
            
                    :return: List of indices of available rods.
                    :rtype: list[int]
                    """
                    if self.num_tackle == 1 and self.tackle.available:
                        return [self.tackle]
            
                    candidates = list(range(len(self.tackles)))
                    # Rotate the candidates for sequential polling
                    start = candidates.index(self.tackle_idx)
                    candidates = candidates[start:] + candidates[:start]
                    candidates = [i for i in candidates if self.tackles[i].available]
            
                    #  Exclude current rod only if there's another available tackle
                    if len(candidates) > 1 and self.tackle_idx in candidates:
                        candidates.remove(self.tackle_idx)
                    return candidates
            
                def _change_tackle_lure(self) -> None:
                    """Change the lure on the current tackle if possible."""
                    if not self.cfg.ARGS.LURE or not self.have_new_lure:
                        return
            
                    if self.timer.is_lure_changeable():
                        logger.info("Changing lure randomly")
                        try:
                            self.tackle.equip_item("lure")
                        except exceptions.ItemNotFoundError:
                            logger.error("New lure not found")
                            self.have_new_lure = False
            
                def _refill_pva(self) -> None:
                    """Refill the PVA bag if it has been used up."""
                    if not self.cfg.ARGS.PVA or not self.have_new_pva:
                        return
            
                    if not self.detection.is_pva_chosen():
                        try:
                            self.tackle.equip_item("pva")
                        except exceptions.ItemNotFoundError:
                            logger.error("New pva not found")
                            self.have_new_pva = False
            
                def _refill_dry_mix(self) -> None:
                    """Refill the dry mix if it has been used up."""
                    if not self.cfg.ARGS.DRY_MIX or not self.have_new_dry_mix:
                        return
                    try:
                        self.tackle.equip_item("dry_mix")
                    except exceptions.ItemNotFoundError:
                        logger.error("New dry mix not found")
                        self.tackle.available = False  # Skip following stages
                        self.have_new_dry_mix = False
            
                def _refill_groundbait(self) -> None:
                    """Refill the groundbait if it has been used up."""
                    if not self.cfg.ARGS.GROUNDBAIT or not self.have_new_groundbait:
                        return
            
                    if self.detection.is_groundbait_chosen():
                        logger.info("Groundbait is not used up yet")
                    else:
                        try:
                            self.tackle.equip_item("groundbait")
                        except exceptions.ItemNotFoundError:
                            logger.error("New groundbait not found")
                            self.have_new_groundbait = False
            
                def test(self):
                    """Boo!"""
                    self.retrieve_line()
            
                # TBD: Menu, Plotter, Result, Handler
                def _get_controllers(self, telescopic: bool) -> tuple[callable, callable]:
                    """Get the monitor and hold_mouse_button functions based on the fishing mode.
            
                    :param telescopic: Whether the fishing mode is telescopic.
                    :type telescopic: bool
                    :return: Tuple containing the monitor and hold_mouse_button functions.
                    :rtype: tuple[callable, callable]
                    """
                    if telescopic:
                        hold_mouse_button = utils.hold_mouse_button
                        monitor = self.tackle._monitor_float_state
                    else:
                        if self.detection.is_clip_open():
                            logger.warning("Clip is not set, fall back to camera mode")
                            monitor = self.tackle._monitor_float_state
                        else:
                            monitor = self.tackle._monitor_clip_state
                        hold_mouse_button = utils.hold_mouse_buttons
            
                    return monitor, hold_mouse_button
            
                def _pause_script(self) -> None:
                    """Pause the script for a specified duration."""
                    logger.info("Pausing script")
                    pag.press("esc")
                    bound = self.cfg.PAUSE.DURATION // 5
                    offset = random.randint(-bound, bound)
                    sleep(self.cfg.PAUSE.DURATION + offset)
                    pag.press("esc")
            
                def _handle_timeout(self) -> None:
                    """Handle common timeout events."""
                    if self.detection.is_tackle_broken():
                        self.general_quit("Tackle is broken")
            
                    if self.detection.is_disconnected():
                        self.disconnected_quit()
            
                    if self.detection.is_ticket_expired():
                        self._handle_expired_ticket()
            
                def _handle_broken_lure(self) -> None:
                    """Handle the broken lure event according to the settings."""
                    match self.cfg.ARGS.BROKEN_LURE:
                        case "replace":
                            self._replace_broken_lures()
                        case "alarm":
                            playsound(str(Path(self.cfg.SCRIPT.ALARM_SOUND).resolve()))
                            self.window.activate_script_window()
                            print("Please replace your lure.")
                            print("Press any key to continue...")
                            msvcrt.getch()
                            self.window.activate_game_window()
                        case _:
                            self.general_quit("Lure is broken")
            
                @utils.release_keys_after(arrow_keys=True)
                def _handle_termination(self, msg: str, shutdown: bool) -> None:
                    """Handle script termination.
            
                    :param msg: The reason for termination.
                    :type msg: str
                    :param shutdown: Whether to shutdown the computer after termination.
                    :type shutdown: bool
                    """
                    result = self.build_result_dict(msg)
                    table = self.build_result_table(result)
                    if self.cfg.ARGS.DISCORD:
                        # TODO: dynamic color
                        DiscordNotification(self.cfg, result).send(DiscordColor.BLURPLE)
                    if self.cfg.ARGS.EMAIL:
                        EmailNotification(self.cfg, result).send()
                    if self.cfg.ARGS.MIAOTIXING:
                        MiaotixingNotification(self.cfg, result).send()
                    if self.cfg.ARGS.DATA and self.result.kept != 0:
                        self.timer.plot_and_save()
                    if shutdown and self.cfg.ARGS.SHUTDOWN:
                        os.system("shutdown /s /t 5")
                    print(table)
                    utils.safe_exit()
            
                def _handle_snagged_line(self) -> None:
                    """Handle a snagged line event."""
                    if len(self.tackles) == 1:
                        self.general_quit("Line is snagged")
                    self.tackle.available = False
            
                def handle_fish(self) -> None:
                    if not self.detection.is_fish_captured():
                        return
                    logger.info("Handling fish")
                    self._handle_fish()
                    sleep(ANIMATION_DELAY)
                    while self.detection.is_gift_receieved():
                        sleep(self.cfg.KEEPNET.GIFT_DELAY)
                        pag.press("space")
            
                def _handle_fish(self) -> None:
                    """Keep or release the fish and record the fish count."""
                    tagged = False
                    for tag in self.cfg.SCRIPT.SCREENSHOT_TAGS:
                        if self.detection.is_tag_exist(TagColor[tag.upper()]):
                            tagged = True
                    tagged = not self.cfg.SCRIPT.SCREENSHOT_TAGS or tagged
                    if self.cfg.ARGS.SCREENSHOT and tagged:
                        self.window.save_screenshot(self.timer.get_cur_timestamp())
            
                    self.result.total += 1
                    if self.detection.is_fish_blacklisted():
                        pag.press("backspace")
                        return
            
                    tagged = False
                    for tag in TagColor:
                        if self.detection.is_tag_exist(tag):
                            tag_color = tag.name.lower()
                            setattr(self.result, tag_color, getattr(self.result, tag_color) + 1)
                            if tag_color in self.cfg.KEEPNET.TAGS:
                                tagged = True
            
                    if (
                        self.cfg.ARGS.TAG
                        and not tagged
                        and not self.detection.is_fish_whitelisted()
                    ):
                        pag.press("backspace")
                        return
            
                    # Fish is tagged, ARGS.TAG is disabled, or fish is in whitelist
                    sleep(self.cfg.KEEPNET.FISH_DELAY)
                    pag.press("space")
            
                    self.result.kept += 1
                    limit = self.cfg.KEEPNET.CAPACITY - self.cfg.ARGS.FISHES_IN_KEEPNET
                    if self.result.kept == limit:
                        self._handle_full_keepnet()
            
                    # Avoid wrong cast hour
                    if self.cfg.SELECTED.MODE in ["bottom", "pirk", "elevator"]:
                        self.timer.update_cast_time()
                    self.timer.add_cast_time()
            
                def _handle_full_keepnet(self) -> None:
                    """Handle a full keepnet event."""
                    match self.cfg.KEEPNET.FULL_ACTION:
                        case "alarm":
                            playsound(str(Path(self.cfg.SCRIPT.ALARM_SOUND).resolve()))
                            self.window.activate_script_window()
                            print("Press any key to continue...")
                            msvcrt.getch()
                            self.window.activate_game_window()
                            with keyboard.Listener(on_release=self._on_release) as listner:
                                listner.join()
                            logger.info("Continue running script")
                        case "quit":
                            self.general_quit("Keepnet is full")
                        case _:
                            raise ValueError
            
                def _on_release(self, _: keyboard.KeyCode) -> None:
                    """Handle key release events."""
                    sys.exit()
            
                def general_quit(self, msg: str) -> None:
                    """Quit the game through the control panel.
            
                    :param msg: reason for termination
                    :type msg: str
                    """
                    logger.critical(msg)
                    sleep(ANIMATION_DELAY)
                    pag.press("esc")
                    sleep(ANIMATION_DELAY)
            
                    if self.cfg.ARGS.SIGNOUT:
                        pag.keyDown("shift")
                    pag.moveTo(self.detection.get_quit_position())
                    pag.click()
                    pag.keyUp("shift")
                    sleep(ANIMATION_DELAY)
                    pag.moveTo(self.detection.get_yes_position())
                    pag.click()
            
                    self._handle_termination(msg, shutdown=True)
            
                def disconnected_quit(self) -> None:
                    """Quit the game through the main menu."""
                    pag.press("space")
                    # Sleep to bypass the black screen (experimental)
                    sleep(DISCONNECTED_DELAY)
                    pag.press("space")
                    sleep(ANIMATION_DELAY)
                    if not self.cfg.ARGS.SIGNOUT:
                        pag.moveTo(self.detection.get_exit_icon_position())
                        pag.click()
                        sleep(ANIMATION_DELAY)
                        pag.moveTo(self.detection.get_confirm_button_position())
                        pag.click()
            
                    self._handle_termination("Game disconnected", shutdown=True)
            
                def build_result_dict(self, msg: str):
                    return self.result.as_dict(msg, self.timer)
            
                def build_result_table(self, result) -> Table:
                    """Create a Rich table from running result.
            
                    :return: formatted running result table
                    :rtype: Table
                    """
                    table = Table(
                        "Field", "Value", title="Running Result", box=box.DOUBLE, show_header=False
                    )
            
                    for k, v in result.items():
                        table.add_row(k, str(v))
                    return table
            
                def _handle_expired_ticket(self) -> None:
                    """Handle an expired boat ticket event."""
                    if self.cfg.ARGS.BOAT_TICKET is None:
                        pag.press("esc")
                        sleep(TICKET_EXPIRE_DELAY)
                        self.general_quit("Boat ticket expired")
            
                    logger.info("Renewing boat ticket")
                    ticket_loc = self.detection.get_ticket_position(self.cfg.ARGS.BOAT_TICKET)
                    if ticket_loc is None:
                        pag.press("esc")  # Close ticket menu
                        sleep(ANIMATION_DELAY)
                        self.general_quit("New boat ticket not found")
                    pag.moveTo(ticket_loc)
                    pag.click(clicks=2, interval=0.1)  # pag.doubleClick() not implemented
                    sleep(ANIMATION_DELAY)
            
                @utils.press_before_and_after("v")
                def _replace_broken_lures(self) -> None:
                    """Replace multiple broken lures."""
                    logger.info("Replacing broken lures")
            
                    scrollbar_position = self.detection.get_scrollbar_position()
                    if scrollbar_position is None:
                        logger.info("Scroll bar not found, changing lures for normal rig")
                        while self._open_broken_lure_menu():
                            self._replace_item()
                        pag.press("v")
                        return
            
                    logger.info("Scroll bar found, changing lures for dropshot rig")
                    pag.moveTo(scrollbar_position)
                    for _ in range(5):
                        sleep(ANIMATION_DELAY)
                        pag.drag(xOffset=0, yOffset=125, duration=0.5, button="left")
            
                        replaced = False
                        while self._open_broken_lure_menu():
                            self._replace_item()
                            replaced = True
            
                        if replaced:
                            pag.moveTo(self.detection.get_scrollbar_position())
            
                def _open_broken_lure_menu(self) -> bool:
                    """Open the broken lure menu.
            
                    :return: True if the broken lure is found, False otherwise.
                    :rtype: bool
                    """
                    logger.info("Looking for broken lure")
                    broken_item_position = self.detection.get_100wear_position()
                    if broken_item_position is None:
                        logger.warning("Broken lure not found")
                        return False
            
                    # click item to open selection menu
                    pag.moveTo(broken_item_position)
                    sleep(ANIMATION_DELAY)
                    pag.click()
                    sleep(ANIMATION_DELAY)
                    return True
            
                def _replace_item(self) -> None:
                    """Replace a broken item with a favorite item."""
                    logger.info("Looking for favorite items")
                    favorite_item_positions = self.detection.get_favorite_item_positions()
                    while True:
                        favorite_item_position = next(favorite_item_positions, None)
                        if favorite_item_position is None:
                            pag.press("esc")
                            sleep(ANIMATION_DELAY)
                            pag.press("esc")
                            sleep(ANIMATION_DELAY)
                            self.general_quit("Favorite item not found")
            
                        # Check if the lure for replacement is already broken
                        x, y = utils.get_box_center(favorite_item_position)
                        if pag.pixel(x - 60, y + 190) != (178, 59, 30):  # Magic value #TODO
                            logger.info("Lure replaced successfully")
                            pag.moveTo(x - 60, y + 190)
                            pag.click(clicks=2, interval=0.1)
                            sleep(WEAR_TEXT_UPDATE_DELAY)
                            break
        üìÑ utils.py
            """Helper functions for automation scripts.
            
            This module provides utility functions for common tasks such as mouse control,
            keyboard input, and result display. It also includes decorators for managing
            key and mouse states during automation.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import ctypes
            import logging
            import msvcrt
            import shlex
            import sys
            from time import sleep
            
            import pyautogui as pag
            from pyscreeze import Box
            from rich.console import Console
            from rich.logging import RichHandler
            from rich.text import Text
            
            # BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
            BASE_DELAY = 1.2
            LOOP_DELAY = 1
            
            ANIMATION_DELAY = 1
            
            logger = logging.getLogger("rich")
            
            # ---------------------------------------------------------------------------- #
            #                            common functionalities                            #
            # ---------------------------------------------------------------------------- #
            
            
            def hold_mouse_button(duration: float = 1, button: str = "left") -> None:
                """Hold left or right mouse button.
            
                :param duration: Hold time, defaults to 1.
                :type duration: float, optional
                :param button: Button to click, defaults to "left".
                :type button: str, optional
                """
                if duration == 0:
                    return
            
                pag.mouseDown(button=button)
                sleep(duration)
                pag.mouseUp(button=button)
                if button == "left" and duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
                    pag.click()
            
            
            def hold_mouse_buttons(duration: float = 1) -> None:
                """Hold left and right mouse buttons simultaneously.
            
                :param duration: Hold time, defaults to 1.
                :type duration: float, optional
                """
                pag.mouseDown()
                pag.mouseDown(button="right")
                sleep(duration)
                pag.mouseUp()
                pag.mouseUp(button="right")
                if duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
                    pag.click()
            
            
            def sleep_and_decrease(num: int, delay: int) -> int:
                """Self-decrement with a delay.
            
                :param num: The variable to decrease.
                :type num: int
                :param delay: Sleep time.
                :type delay: int
                :return: Decreased num.
                :rtype: int
                """
                sleep(delay)
                return num - delay
            
            
            def ask_for_confirmation(msg: str = "Ready to start") -> None:
                """Ask for confirmation of user settings if it's enabled.
            
                :param msg: Confirmation message, defaults to "Ready to start".
                :type msg: str
                """
                while True:
                    ans = input(f"{msg}? [Y/n] ").strip().lower()
                    if ans in ("y", ""):
                        break
                    if ans == "n":
                        sys.exit()
            
            
            def get_box_center(box: Box) -> tuple[int, int]:
                """Get the center coordinate (x, y) of the given box.
            
                # (x, y, w, h) -> (x, y), np.int64 -> int
            
                :param box: Box coordinates (x, y, w, h).
                :type box: Box
                :return: x and y coordinates of the center point.
                :rtype: tuple[int, int]
                """
                return int(box.left + box.width // 2), int(box.top + box.height // 2)
            
            
            def create_rich_logger() -> RichHandler:
                """Create a default RichHandler for logging.
            
                :return: Logging handler from rich.
                :rtype: RichHandler
                """
                # Ignore %(name)s because it's too verbose
                # https://rich.readthedocs.io/en/latest/logging.html
                logging.basicConfig(
                    level=logging.INFO,
                    format="%(message)s",
                    datefmt="%Y-%m-%d %H:%M:%S",
                    handlers=[RichHandler(rich_tracebacks=True)],
                )
                return logging.getLogger("rich")
            
            
            # ---------------------------------------------------------------------------- #
            #                                  decorators                                  #
            # ---------------------------------------------------------------------------- #
            
            
            # def toggle_clicklock(func):
            #     """Toggle clicklock before and after calling the function."""
            
            #     def wrapper(self, *args, **kwargs):
            #         # ELECTRO must be enabled, always use electric mode if GEAR_RATIO is disabled
            #         # otherwise, only use electric mode when it's the first time
            #         if self.cfg.ARGS.ELECTRO and (
            #             not self.cfg.ARGS.GEAR_RATIO or (not args or args[0])
            #         ):
            #             pag.click(clicks=2, interval=0.1)
            #         else:
            #             pag.mouseDown()
            #         sleep(BASE_DELAY + LOOP_DELAY)
            #         try:
            #             func(self, *args, **kwargs)
            #         finally:
            #             if self.cfg.ARGS.ELECTRO:
            #                 pag.click(clicks=2, interval=0.1)
            #             else:
            #                 pag.click()
            
            #     return wrapper
            
            
            def toggle_right_mouse_button(func):
                """Toggle right mouse button before and after calling the function."""
            
                def wrapper(*args, **kwargs):
                    pag.mouseDown(button="right")
                    try:
                        func(*args, **kwargs)
                    finally:
                        pag.mouseUp(button="right")
            
                return wrapper
            
            
            def press_before_and_after(key):
                def func_wrapper(func):
                    def args_wrapper(*args, **kwargs):
                        pag.press(key)
                        sleep(ANIMATION_DELAY)
                        try:
                            func(*args, **kwargs)
                        finally:
                            pag.press(key)
                            sleep(ANIMATION_DELAY)
            
                    return args_wrapper
            
                return func_wrapper
            
            
            def release_keys_after(arrow_keys: bool = False):
                """Release keys that might have been holding down
            
                :param arrow_keys: whether to toggle arrow keys, defaults to False
                :type arrow_keys: bool, optional
                """
            
                def release_keys(arrow_keys):
                    pag.keyUp("ctrl")
                    pag.keyUp("shift")
                    if arrow_keys:
                        pag.keyUp("w")
                        pag.keyUp("a")
                        pag.keyUp("d")
            
                def func_wrapper(func):  # Capture arrow_keys as default arg
                    def args_wrapper(*args, **kwargs):
                        try:
                            return func(*args, **kwargs)
                        finally:
                            release_keys(arrow_keys)  # Uses the captured value
            
                    return args_wrapper
            
                return func_wrapper
            
            
            def print_error(msg):
                text = Text(msg)
                text.stylize("red")
                Console().print(text)
            
            
            # There's lots of early return in player._resetting_stage(),
            # so use a decorator here to simplify the code
            def reset_friction_brake_after(func):
                """Reset friction brake after calling the function."""
            
                def wrapper(self, *args, **kwargs):
                    func(self, *args, **kwargs)
                    if not self.cfg.ARGS.FRICTION_BRAKE:
                        return
            
                    with self.friction_brake_lock:
                        self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)
            
                return wrapper
            
            
            def is_compiled():
                return "__compiled__" in globals()  # Nuitka style
            
            
            def is_run_by_clicking():
                # Load kernel32.dll
                kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
                # Create an array to store the processes in.  This doesn't actually need to
                # be large enough to store the whole process list since GetConsoleProcessList()
                # just returns the number of processes if the array is too small.
                process_array = (ctypes.c_uint * 1)()
                num_processes = kernel32.GetConsoleProcessList(process_array, 1)
                # num_processes may be 1 if your compiled program doesn't have a launcher/wrapper.
                # If run from Python interpreter, num_processes would also be 2
                # We also need to check if it's an executable to make it work
                return is_compiled() and num_processes == 2
            
            
            def update_argv():
                if is_run_by_clicking():
                    logger.info("No launch options used")
                    sys.argv = ["foo"] + shlex.split(
                        input("Enter launch options (press Enter to skip): ")
                    )
            
            
            def safe_exit():
                if is_run_by_clicking():
                    print("Press any key to quit.")
                    # KeyboardInterrupt will mess with stdin, input will crash silently
                    # Use msvcrt.getch() because it doesn't depends on stdin
                    msvcrt.getch()
                sys.exit()
        üìÑ __init__.py
            [EMPTY FILE]
        üìÅ app/
            üìÑ app.py
                """Base application class for other tools.
                
                Provides core functionality for:
                - Configuration management
                - Window control
                - Result display
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                import os
                import signal
                import sys
                from abc import ABC, abstractmethod
                from pathlib import Path
                
                from pynput import keyboard
                from rich import print
                from rich.table import Table
                from yacs.config import CfgNode as CN
                
                from rf4s.config import config
                from rf4s.controller.detection import Detection
                from rf4s.controller.window import Window
                from rf4s.result.result import Result
                from rf4s.utils import is_compiled, safe_exit
                
                # Get the base path depending on runtime environment
                if is_compiled():
                    ROOT = Path(sys.executable).parent  # Running as .exe (Nuitka/PyInstaller)
                else:
                    ROOT = Path(__file__).resolve().parents[2]
                
                logger = logging.getLogger("rich")
                
                
                class App(ABC):
                    """A base application class.
                
                    Attributes:
                        cfg (yacs.config.CfgNode): Default + user's configuration file
                        window (Window): Window controller
                    """
                
                    def __init__(self):
                        """Initialize a mutable cfg node for further modification."""
                        self.cfg = config.setup_cfg()
                
                        config_path = ROOT / "config.yaml"
                        if not config_path.exists():
                            logger.critical("config.yaml not found at %s", config_path)
                            safe_exit()
                
                        self.cfg.merge_from_file(ROOT / "config.yaml")
                        self.window = Window()
                
                    def _on_release(self, key: keyboard.KeyCode) -> None:
                        """Monitor user's keystrokes and convert a key press to a CTRL_C_EVENT.
                
                        :param key: The key that was released.
                        :type key: keyboard.KeyCode
                
                        Exits the application when the configured quit key is pressed.
                        """
                        # Trigger CTRL_C_EVENT, which will be caught in start() to simulate pressing
                        # CTRL-C to terminate the script.
                        if key == keyboard.KeyCode.from_char(self.cfg.KEY.QUIT):
                            os.kill(os.getpid(), signal.CTRL_C_EVENT)
                            sys.exit()
                
                    @abstractmethod
                    def _start(self):
                        raise NotImplementedError("_start() must be implemented in subclass")
                
                    @abstractmethod
                    def start(self):
                        raise NotImplementedError("start() must be implemented in subclass")
                
                    @abstractmethod
                    def create_parser(self):
                        raise NotImplementedError("create_parser() must be implemented in subclass")
                
                    @abstractmethod
                    def display_result(self) -> None:
                        raise NotImplementedError("display_result() must be implemented in subclass")
                
                
                class ToolApp(App):
                    """General application class for other tools.
                
                    Attributes:
                        detection (Detection): Detection controller
                    """
                
                    def __init__(self):
                        """Set up an immutable cfg node for further modification.
                
                        1. Parse command-line arguments and merge them with the existing cfg node.
                        2. Create a Window instance and a Detection instance.
                        3. Create an empty dictionary for result
                        """
                        super().__init__()
                        args = self.create_parser().parse_args()
                        args_cfg = CN({"ARGS": config.dict_to_cfg(vars(args))})
                        self.cfg.merge_from_other_cfg(args_cfg)
                        self.cfg.merge_from_list(args.opts)
                
                        # Dummy node
                        dummy = CN({"SELECTED": config.dict_to_cfg({"MODE": "spin"})})
                        self.cfg.merge_from_other_cfg(dummy)
                        self.cfg.freeze()
                
                        self.detection = Detection(self.cfg, self.window)
                        self.result = Result()  # This will be used in display_result()
                
                    def display_result(self) -> None:
                        """Display the running result in a table format."""
                        result_dict = self.result.as_dict()
                        if not result_dict:
                            return
                
                        table = Table("Result", title="Running Result", show_header=False)
                        for name, value in self.result.as_dict().items():
                            table.add_row(name, str(value))
                        print(table)
                
                    def start(self) -> None:
                        """Wrapper method that handle window activation and result display."""
                        if self.cfg.KEY.QUIT != "CTRL-C":
                            listener = keyboard.Listener(on_release=self._on_release)
                            listener.start()
                
                        self.window.activate_game_window()
                        try:
                            self._start()
                        except KeyboardInterrupt:
                            pass
                        self.display_result()
                        self.window.activate_script_window()
            üìÅ __pycache__/
                üìÑ app.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ component/
            üìÑ friction_brake.py
                """Module for friction brake related methods.
                
                This module provides functionality for managing the friction brake in Russian Fishing 4,
                including resetting, adjusting, and monitoring the friction brake.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                from multiprocessing import Process, Value
                from time import sleep, time
                
                import pyautogui as pag
                
                from rf4s.controller.detection import Detection
                
                MAX_FRICTION_BRAKE = 30
                MIN_FRICTION_BRAKE = 0
                UP = 1
                DOWN = -1
                FRICTION_BRAKE_MONITOR_DELAY = 2
                LOOP_DELAY = 0.04
                
                logger = logging.getLogger("rich")
                
                
                class FrictionBrake:
                    """Friction brake controller.
                
                    This class handles the adjustment and monitoring of the friction brake during gameplay.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for friction brake settings.
                        detection (Detection): Detection instance for in-game state checks.
                        cur (Value): Current value of the friction brake.
                        lock (Lock): Lock for thread synchronization.
                        monitor_process (Process): Process for monitoring the friction brake.
                    """
                
                    def __init__(self, cfg, lock, detection: Detection) -> None:
                        """Initialize the FrictionBrake class with configuration, lock, and detection.
                
                        :param cfg: Configuration node for friction brake settings.
                        :type cfg: CfgNode
                        :param lock: Lock for thread synchronization.
                        :type lock: Lock
                        :param detection: Detection instance for in-game state checks.
                        :type detection: Detection
                        """
                        self.cfg = cfg
                        self.lock = lock
                        self.detection = detection
                        self.cur = Value("i", cfg.FRICTION_BRAKE.INITIAL)
                        self.monitor_process = Process(target=monitor_friction_brake, args=(self,))
                
                    def reset(self, target: int) -> None:
                        """Reset the friction brake to the target value.
                
                        :param target: Target friction brake value.
                        :type target: int
                        """
                        logger.info("Resetting friction brake")
                        for _ in range(MAX_FRICTION_BRAKE):
                            pag.scroll(UP)
                
                        diff = MAX_FRICTION_BRAKE - target
                        for _ in range(abs(diff)):
                            pag.scroll(DOWN)
                        self.cur.value = target
                
                    def change(self, increase: bool) -> None:
                        """Increase or decrease the friction brake.
                
                        :param increase: Whether to increase the friction brake.
                        :type increase: bool
                        """
                        if increase:
                            if self.cur.value < self.cfg.FRICTION_BRAKE.MAX:
                                pag.scroll(UP, _pause=False)
                                self.cur.value = min(self.cur.value + 1, MAX_FRICTION_BRAKE)
                        else:
                            if self.cur.value > 0:
                                pag.scroll(DOWN, _pause=False)
                                self.cur.value = max(self.cur.value - 1, MIN_FRICTION_BRAKE)
                        sleep(LOOP_DELAY)
                
                
                def monitor_friction_brake(friction_brake: FrictionBrake) -> None:
                    """Monitor friction brake bar and change it accordingly.
                
                    This is used as the target function in multiprocess.Process and must be pickable,
                    thus it must be declared as a global function instead of an instance method.
                
                    :param friction_brake: Friction brake controller.
                    :type friction_brake: FrictionBrake
                    """
                    logger.info("Monitoring friction brake")
                
                    pre_time = time()
                    fish_hooked = False
                
                    try:
                        while True:
                            if not friction_brake.detection.is_fish_hooked_pixel():
                                sleep(FRICTION_BRAKE_MONITOR_DELAY)
                                fish_hooked = False
                                continue
                            if not fish_hooked:
                                sleep(friction_brake.cfg.FRICTION_BRAKE.START_DELAY)
                                fish_hooked = True
                            with friction_brake.lock:
                                if friction_brake.detection.is_friction_brake_high():
                                    friction_brake.change(increase=False)
                                if friction_brake.detection.is_reel_burning():
                                    logger.info("Reel burning detected, decreasing friction brake")
                                    friction_brake.change(increase=False)
                                else:
                                    cur_time = time()
                                    if (
                                        cur_time - pre_time
                                        < friction_brake.cfg.FRICTION_BRAKE.INCREASE_DELAY
                                    ):
                                        continue
                                    pre_time = cur_time
                                    friction_brake.change(increase=True)
                    except KeyboardInterrupt:
                        pass
            üìÑ tackle.py
                """Module for Tackle class and some decorators.
                
                This module provides functionality for managing tackle-related actions in Russian Fishing 4,
                such as casting, retrieving, and pulling fish. It also includes decorators for handling
                common tasks like clicklock and key releases.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                import random
                from time import sleep
                from typing import Literal
                
                import pyautogui as pag
                import win32api
                import win32con
                from pyscreeze import Box
                
                from rf4s import exceptions, utils
                from rf4s.controller.detection import Detection
                from rf4s.controller.timer import Timer
                
                logger = logging.getLogger("rich")
                
                RESET_TIMEOUT = 16
                CAST_SCALE = 0.4  # 25% / 0.4s
                
                # BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
                BASE_DELAY = 1.2
                LOOP_DELAY = 1
                
                ANIMATION_DELAY = 1
                
                RETRIEVAL_TIMEOUT = 32
                PULL_TIMEOUT = 16
                RETRIEVAL_WITH_PAUSE_TIMEOUT = 128
                LIFT_DURATION = 3
                TELESCOPIC_PULL_TIMEOUT = 8
                LANDING_NET_DURATION = 6
                LANDING_NET_DELAY = 0.5
                SINK_DELAY = 2
                
                
                OFFSET = 100
                NUM_OF_MOVEMENT = 4
                
                
                class Tackle:
                    """Class for all tackle-dependent methods.
                
                    This class handles actions related to the fishing tackle, such as casting,
                    retrieving, and pulling fish. It also manages tackle resetting and gear ratio switching.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for tackle settings.
                        timer (Timer): Timer instance for timing actions.
                        detection (Detection): Detection instance for in-game state checks.
                        landing_net_out (bool): Whether the landing net is deployed.
                        available (bool): Whether the tackle is available for use.
                    """
                
                    def __init__(self, cfg, timer: Timer, detection: Detection):
                        """Initialize the Tackle class with configuration, timer, and detection.
                
                        :param cfg: Configuration node for tackle settings.
                        :type cfg: CfgNode
                        :param timer: Timer instance for timing actions.
                        :type timer: Timer
                        :param detection: Detection instance for in-game state checks.
                        :type detection: Detection
                        """
                        self.cfg = cfg
                        self.timer = timer
                        self.detection = detection
                        self.landing_net_out = False  # For telescopic pull
                        self.available = True
                
                    @staticmethod
                    def _check_status(func):
                        def wrapper(self, *args, **kwargs):
                            if not self.available:
                                return
                            try:
                                func(self, *args)
                            except Exception as e:
                                raise e
                
                        return wrapper
                
                    def is_disconnected_or_ticketed_expired(self) -> None:
                        """Check if the game disconnected or the boat ticket expired."""
                        if self.detection.is_disconnected():
                            raise exceptions.DisconnectedError
                        if self.detection.is_ticket_expired():
                            raise exceptions.TicketExpiredError
                
                    @_check_status
                    def reset(self) -> None:
                        """Reset the tackle until ready and detect unexpected events.
                
                        :raises exceptions.FishHookedError: A fish is hooked.
                        :raises exceptions.FishCapturedError: A fish is captured.
                        :raises exceptions.LineAtEndError: The line is at its end.
                        :raises exceptions.LineSnaggedError: The line is snagged.
                        :raises TimeoutError: The loop timed out.
                        """
                        logger.info("Resetting tackle")
                        i = RESET_TIMEOUT
                        while i > 0:
                            if self.detection.is_tackle_ready():
                                return
                            if self.detection.is_fish_hooked():
                                raise exceptions.FishHookedError
                            if self.detection.is_fish_captured():
                                raise exceptions.FishCapturedError
                            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                                raise exceptions.LineAtEndError
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                            if self.detection.is_lure_broken():
                                raise exceptions.LureBrokenError
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @_check_status
                    def cast(self, lock: bool) -> None:
                        """Cast the rod, then wait for the lure/bait to fly and sink.
                
                        :param lock: Whether to lock the reel after casting.
                        :type lock: bool
                        """
                        logger.info("Casting rod")
                        if self.cfg.ARGS.MOUSE:
                            self.move_mouse_randomly()
                        match self.cfg.SELECTED.CAST_POWER_LEVEL:
                            case 1:  # 0%
                                pag.click()
                            case 5:  # power cast
                                with pag.hold("shift"):
                                    utils.hold_mouse_button(1)
                            case _:
                                # -1 for backward compatibility
                                duration = CAST_SCALE * (self.cfg.SELECTED.CAST_POWER_LEVEL - 1)
                                utils.hold_mouse_button(duration)
                
                        sleep(self.cfg.SELECTED.CAST_DELAY)
                        if lock:
                            pag.click()
                
                    def sink(self) -> None:
                        """Sink the lure until an event happens, designed for marine and wakey rig."""
                        logger.info("Sinking lure")
                        i = self.cfg.SELECTED.SINK_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_moving_in_bottom_layer():
                                logger.info("Lure has reached bottom layer")
                                sleep(SINK_DELAY)
                                break
                
                            if self.detection.is_fish_hooked_twice():
                                pag.click()  # Lock reel
                                return
                
                        utils.hold_mouse_button(self.cfg.SELECTED.TIGHTEN_DURATION)
                
                    @_check_status
                    @utils.release_keys_after()
                    def retrieve(self, first: bool = True) -> None:
                        """Retrieve the line until the end is reached and detect unexpected events.
                
                        :param first: Whether it's invoked for the first time, defaults to True.
                        :type first: bool, optional
                
                        :raises exceptions.FishCapturedError: A fish is captured.
                        :raises exceptions.LineAtEndError: The line is at its end.
                        :raises exceptions.LineSnaggedError: The line is snagged.
                        :raises TimeoutError: The loop timed out.
                        """
                        logger.info("Retrieving fishing line")
                
                        i = RETRIEVAL_TIMEOUT
                        while i > 0:
                            if self.detection.is_fish_hooked():
                                if self.cfg.SELECTED.POST_ACCELERATION == "on":
                                    pag.keyDown("shift")
                                elif self.cfg.SELECTED.POST_ACCELERATION == "auto" and first:
                                    pag.keyDown("shift")
                
                                if self.cfg.ARGS.LIFT:
                                    utils.hold_mouse_button(LIFT_DURATION, button="right")
                
                            if self.detection.is_retrieval_finished():
                                sleep(0 if self.cfg.ARGS.RAINBOW else 2)
                                return
                
                            if self.detection.is_fish_captured():
                                raise exceptions.FishCapturedError
                            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                                raise exceptions.LineAtEndError
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @utils.release_keys_after()
                    def _special_retrieve(self, button: str) -> None:
                        """Retrieve the line with special conditions (pause or lift).
                
                        :param button: The mouse button to use for retrieval.
                        :type button: str
                        """
                        if self.cfg.SELECTED.PRE_ACCELERATION:
                            pag.keyDown("shift")
                        i = RETRIEVAL_WITH_PAUSE_TIMEOUT
                        while i > 0:
                            utils.hold_mouse_button(self.cfg.SELECTED.RETRIEVAL_DURATION, button)
                            i -= self.cfg.SELECTED.RETRIEVAL_DURATION
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.RETRIEVAL_DELAY)
                            if (
                                self.detection.is_fish_hooked()
                                or self.detection.is_retrieval_finished()
                            ):
                                return
                
                    @utils.release_keys_after()
                    def pirk(self) -> None:
                        """Start pirking until a fish is hooked.
                
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        logger.info("Pirking")
                
                        i = self.cfg.SELECTED.PIRK_TIMEOUT
                        while i > 0:
                            if self.detection.is_tackle_ready():
                                return
                
                            if self.detection.is_fish_hooked_twice():
                                pag.click()
                                return
                
                            if self.cfg.SELECTED.PIRK_DURATION > 0:
                                if self.cfg.SELECTED.CTRL:
                                    pag.keyDown("ctrl")
                                if self.cfg.SELECTED.SHIFT:
                                    pag.keyDown("shift")
                                utils.hold_mouse_button(self.cfg.SELECTED.PIRK_DURATION, button="right")
                                i -= self.cfg.SELECTED.PIRK_DURATION
                                i = utils.sleep_and_decrease(i, self.cfg.SELECTED.PIRK_DELAY)
                            else:
                                i = utils.sleep_and_decrease(i, LOOP_DELAY)
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def elevate(self, dropped: bool) -> None:
                        """Perform elevator tactic (drop/rise) until a fish is hooked.
                
                        :param dropped: Whether the lure is dropped.
                        :type dropped: bool
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        locked = True  # Reel is locked after tackle.sink()
                        i = self.cfg.SELECTED.ELEVATE_TIMEOUT
                        while i > 0:
                            if self.detection.is_fish_hooked_twice():
                                pag.click()
                                return
                
                            if self.cfg.SELECTED.DROP and not dropped:
                                pag.press("enter")
                                if locked:
                                    delay = self.cfg.SELECTED.ELEVATE_DELAY
                                else:
                                    delay = self.cfg.SELECTED.ELEVATE_DURATION
                                i = utils.sleep_and_decrease(i, delay)
                            else:
                                if locked:
                                    i = utils.sleep_and_decrease(i, self.cfg.SELECTED.ELEVATE_DELAY)
                                else:
                                    utils.hold_mouse_button(self.cfg.SELECTED.ELEVATE_DURATION)
                                    i -= self.cfg.SELECTED.ELEVATE_DURATION
                            locked = not locked
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    @_check_status
                    def pull(self) -> None:
                        """Pull the fish until it's captured."""
                        logger.info("Pulling fish")
                        if self.cfg.SELECTED.MODE == "telescopic":
                            self._telescopic_pull()
                        else:
                            self._pull()
                
                    @utils.toggle_right_mouse_button
                    def _pull(self) -> None:
                        """Pull the fish until it's captured."""
                        i = PULL_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_fish_captured():
                                return
                            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                                raise exceptions.LineSnaggedError
                
                        if not self.detection.is_fish_hooked():
                            return
                        if self.detection.is_retrieval_finished():
                            pag.press("space")
                            sleep(LANDING_NET_DURATION)
                            if self.detection.is_fish_captured():
                                return
                            pag.press("space")
                            sleep(LANDING_NET_DELAY)
                        if self.detection.is_tackle_broken():
                            raise exceptions.TackleBrokenError
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def _telescopic_pull(self) -> None:
                        """Pull the fish until it's captured, designed for telescopic rod.
                
                        :raises exceptions.TimeoutError: The loop timed out.
                        """
                        # Check false postive first because it happens often
                        if not self.detection.is_fish_hooked():
                            return
                
                        # Toggle landing net when pull() is called for the first time
                        if not self.landing_net_out:
                            pag.press("space")
                            self.landing_net_out = True
                        i = TELESCOPIC_PULL_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, LOOP_DELAY)
                            if self.detection.is_fish_captured():
                                self.landing_net_out = False
                                return
                            if self.detection.is_tackle_broken():
                                raise exceptions.TackleBrokenError
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def switch_gear_ratio(self) -> None:
                        """Switch the gear ratio of a conventional reel."""
                        logger.info("Switching gear ratio")
                        with pag.hold("ctrl"):
                            pag.press("space")
                
                    def move_mouse_randomly(self) -> None:
                        """Randomly move the mouse for four times."""
                        logger.info("Moving mouse randomly")
                        coords = []
                        for _ in range(NUM_OF_MOVEMENT - 1):
                            x, y = random.randint(-OFFSET, OFFSET), random.randint(-OFFSET, OFFSET)
                            coords.append((x, y))
                        coords.append((-sum(x for x, _ in coords), -sum(y for _, y in coords)))
                        for x, y in coords:
                            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, x, y, 0, 0)
                            sleep(ANIMATION_DELAY)
                
                    def equip_item(self, item) -> None:
                        """Equip an item from the menu or inventory.
                
                        :param item: The item to equip (e.g., lure, pva, dry_mix, groundbait).
                        :type item: str
                        """
                        if item == "lure":
                            self._equip_item_from_menu(item)
                        self._equip_item_from_inventory(item)  # groundbait, dry_mix, pva
                
                    def _equip_item_from_menu(self, item: str) -> None:
                        """Equip an item from the menu.
                
                        :param item: The item to equip (e.g., lure).
                        :type item: str
                        """
                        logger.info("Equiping new %s from menu", item)
                        with pag.hold("b"):
                            self._equip_favorite_item(item)
                        sleep(ANIMATION_DELAY)
                
                    @utils.press_before_and_after("v")
                    def _equip_item_from_inventory(
                        self, item: Literal["dry_mix", "groundbait"]
                    ) -> None:
                        """Equip an item from the inventory.
                
                        :param item: The item to equip (e.g., dry_mix, groundbait).
                        :type item: Literal["dry_mix", "groundbait"]
                        """
                        logger.info("Equiping new %s from inventory", item)
                        scrollbar_position = self.detection.get_scrollbar_position()
                        if scrollbar_position is None:
                            pag.click(utils.get_box_center(self.get_item_position(item)))
                            self._equip_favorite_item(item)
                            return
                
                        pag.moveTo(scrollbar_position)
                        for _ in range(5):
                            sleep(ANIMATION_DELAY)
                            pag.drag(xOffset=0, yOffset=125, duration=0.5, button="left")
                            position = self.get_item_position(item)
                            if position is not None:
                                pag.click(utils.get_box_center(position))
                                self._equip_favorite_item(item)
                                break
                
                    def get_item_position(self, item: str) -> Box | None:
                        """Get the position of an item.
                        :param item: The item to get the position for (e.g., pva, dry_mix, groundbait)
                        :type item: str
                        :return: position of the item
                        :rtype: Box | None
                        """
                        if item == "groundbait":
                            return self.detection.get_groundbait_position()
                        elif item == "dry_mix":
                            return self.detection.get_dry_mix_position()
                        else:  # pva
                            return self.detection.get_pva_position()
                
                    def _equip_favorite_item(self, item: bool):
                        """Select a favorite item for replacement and replace the broken one.
                
                        :param item: The item to equip (e.g., lure, pva, dry_mix, groundbait).
                        :type item: str
                        :raises exceptions.ItemNotFoundError: The item was not found.
                        """
                        sleep(ANIMATION_DELAY)
                        logger.info("Looking for favorite items")
                        favorite_item_positions = list(self.detection.get_favorite_item_positions())
                        if item == "lure":
                            random.shuffle(favorite_item_positions)
                
                        for favorite_item_position in favorite_item_positions:
                            x, y = utils.get_box_center(favorite_item_position)
                            if item == "lure" and pag.pixel(x - 70, y + 190) == (178, 59, 30):
                                continue
                            pag.click(x - 70, y + 190, clicks=2, interval=0.1)
                            logger.info("New %s equiped successfully", item)
                            return
                
                        # Close selection window when equiping from inventory
                        if item in ("dry_mix", "groundbait"):
                            pag.press("esc")
                        raise exceptions.ItemNotFoundError
                
                    def _monitor_float_state(self) -> None:
                        """Monitor the state of the float."""
                        logger.info("Monitoring float state")
                        reference_img = pag.screenshot(region=self.detection.float_camera_rect)
                        i = self.cfg.SELECTED.DRIFT_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.CHECK_DELAY)
                            if self.detection.is_float_state_changed(reference_img):
                                logger.info("Float status changed")
                                return
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
                
                    def _monitor_clip_state(self) -> None:
                        """Monitor the state of the bolognese clip."""
                        i = self.cfg.SELECTED.DRIFT_TIMEOUT
                        while i > 0:
                            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.CHECK_DELAY)
                            if self.detection.is_clip_open():
                                logger.info("Clip status changed")
                                return
                
                        self.is_disconnected_or_ticketed_expired()
                        raise TimeoutError
            üìÑ __init__.py
                [EMPTY FILE]
            üìÅ __pycache__/
                üìÑ friction_brake.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ tackle.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ config/
            üìÑ config.py
                """
                Configuration module for managing and manipulating configuration settings.
                
                This module provides utilities for setting up, converting, and printing
                configuration nodes using the YACS library.
                """
                
                from yacs.config import CfgNode as CN
                
                from rf4s.config.defaults import get_cfg_defaults
                
                
                def setup_cfg() -> CN:
                    """
                    Set up and return a default configuration node.
                
                    This function initializes a default configuration node and allows new keys
                    to be added to the configuration.
                
                    :return: A cloned configuration node with default settings.
                    :rtype: CN
                    """
                    cfg = get_cfg_defaults()
                    cfg.set_new_allowed(True)
                    return cfg.clone()
                
                
                def dict_to_cfg(args: dict) -> CN:
                    """
                    Convert a dictionary to a configuration node.
                
                    This function recursively converts a dictionary into a configuration node,
                    allowing nested dictionaries to be converted into nested configuration nodes.
                
                    :param args: Dictionary to be converted into a configuration node.
                    :type args: dict
                    :return: Configuration node created from the dictionary.
                    :rtype: CN
                    """
                    cfg = CN()
                    for k, v in args.items():
                        k = k.upper()
                        if isinstance(v, dict):
                            cfg[k] = dict_to_cfg(v)
                        else:
                            cfg[k] = v
                    return cfg
                
                
                def print_cfg(cfg: CN, level: int = 0) -> None:
                    """
                    Print the configuration node in a readable format.
                
                    This function recursively prints the configuration node, with indentation
                    to represent nested levels.
                
                    :param cfg: Configuration node to be printed.
                    :type cfg: CN
                    :param level: Current indentation level (used for recursion).
                    :type level: int
                    """
                    cfg = dict(cfg)
                    indent = "  " * level if level > 0 else ""
                    for k, v in cfg.items():
                        if isinstance(v, CN):
                            print(f"{indent}{k}:")
                            print_cfg(v, level + 1)
                        else:
                            print(f"{indent}{k}: {v}")
                
                
                def to_list(profile: dict) -> list:
                    """
                    Convert a dictionary into a flat list of key-value pairs.
                
                    This function flattens a dictionary into a list where keys and values
                    are alternated.
                
                    :param profile: Dictionary to be converted into a list.
                    :type profile: dict
                    :return: List containing alternating keys and values from the dictionary.
                    :rtype: list
                    """
                    pairs = []
                    for k, v in profile.items():
                        pairs.extend([k, v])
                    return pairs
            üìÑ config.yaml
                VERSION: "0.5.2"
                
                SCRIPT:
                  LANGUAGE: "en"
                  LAUNCH_OPTIONS: ""
                  SMTP_VERIFICATION: true
                  IMAGE_VERIFICATION: true
                  SNAG_DETECTION: true
                  SPOOLING_DETECTION: true
                  RANDOM_ROD_SELECTION: true
                  SPOOL_CONFIDENCE: 0.98
                  SPOD_ROD_RECAST_DELAY: 1800
                  LURE_CHANGE_DELAY: 1800
                  ALARM_SOUND: "./static/sound/guitar.wav"
                  RANDOM_CAST_PROBABILITY: 0.25
                  SCREENSHOT_TAGS:
                    - "green"
                    - "yellow"
                    - "blue"
                    - "purple"
                    - "pink"
                
                KEY:
                  TEA: -1
                  CARROT: -1
                  BOTTOM_RODS: [1, 2, 3]
                  COFFEE: 4
                  DIGGING_TOOL: 5
                  ALCOHOL: 6
                  MAIN_ROD: 1
                  SPOD_ROD: 7
                  QUIT: "CTRL-C"
                
                STAT:
                  ENERGY_THRESHOLD: 0.74
                  HUNGER_THRESHOLD: 0.5
                  COMFORT_THRESHOLD: 0.51
                  TEA_DELAY: 300
                  COFFEE_LIMIT: 10
                  COFFEE_PER_DRINK: 1
                  ALCOHOL_DELAY: 900
                  ALCOHOL_PER_DRINK: 1
                
                FRICTION_BRAKE:
                  INITIAL: 29
                  MAX: 30
                  START_DELAY: 2.0
                  INCREASE_DELAY: 1.0
                  SENSITIVITY: "medium"
                
                KEEPNET:
                  CAPACITY: 100
                  FISH_DELAY: 0.0
                  GIFT_DELAY: 4.0
                  FULL_ACTION: "quit"
                  WHITELIST:
                    - "mackerel"
                    - "saithe"
                    - "herring"
                    - "squid"
                    - "scallop"
                    - "mussel"
                  BLACKLIST: []
                  TAGS:
                    - "green"
                    - "yellow"
                    - "blue"
                    - "purple"
                    - "pink"
                
                NOTIFICATION:
                  EMAIL: "email@example.com"
                  PASSWORD: "password"
                  SMTP_SERVER: "smtp.gmail.com"
                  MIAO_CODE: "example"
                  DISCORD_WEBHOOK_URL: ""
                
                PAUSE:
                  DELAY: 1800
                  DURATION: 600
                
                PROFILE:
                  SPIN:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 0.0
                    RETRIEVAL_DURATION: 0.0
                    RETRIEVAL_DELAY: 0.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "normal"
                  SPIN_WITH_PAUSE:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 1.0
                    RETRIEVAL_DURATION: 1.0
                    RETRIEVAL_DELAY: 3.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "pause"
                  SPIN_WITH_LIFT:
                    MODE: "spin"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 6.0
                    TIGHTEN_DURATION: 0.0
                    RETRIEVAL_DURATION: 1.0
                    RETRIEVAL_DELAY: 1.0
                    RETRIEVAL_TIMEOUT: 256.0
                    PRE_ACCELERATION: false
                    POST_ACCELERATION: "off"
                    TYPE: "lift"
                  BOTTOM:
                    MODE: "bottom"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    POST_ACCELERATION: "off"
                    CHECK_DELAY: 32.0
                    CHECK_MISS_LIMIT: 16
                    PUT_DOWN_DELAY: 0.0
                  PIRK:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 4.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: false
                    SHIFT: false
                    PIRK_DURATION: 0.5
                    PIRK_DELAY: 2.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  PIRK_WITH_RETRIEVAL:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 0.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: false
                    SHIFT: false
                    PIRK_DURATION: 0.5
                    PIRK_DELAY: 2.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: true
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  WAKEY_RIG:
                    MODE: "pirk"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 45.0
                    TIGHTEN_DURATION: 1.0
                    DEPTH_ADJUST_DELAY: 4.0
                    DEPTH_ADJUST_DURATION: 1.0
                    CTRL: true
                    SHIFT: false
                    PIRK_DURATION: 1.5
                    PIRK_DELAY: 4.0
                    PIRK_TIMEOUT: 32.0
                    PIRK_RETRIEVAL: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  ELEVATOR:
                    MODE: "elevator"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    ELEVATE_DURATION: 4.0
                    ELEVATE_DELAY: 4.0
                    ELEVATE_TIMEOUT: 40.0
                    DROP: false
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  ELEVATOR_WITH_DROP:
                    MODE: "elevator"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 1.0
                    CAST_DELAY: 4.0
                    SINK_TIMEOUT: 60.0
                    TIGHTEN_DURATION: 1.0
                    ELEVATE_DURATION: 4.0
                    ELEVATE_DELAY: 4.0
                    ELEVATE_TIMEOUT: 40.0
                    DROP: true
                    HOOK_DELAY: 0.5
                    POST_ACCELERATION: "auto"
                  TELESCOPIC:
                    MODE: "telescopic"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    FLOAT_SENSITIVITY: 0.68
                    CHECK_DELAY: 1.0
                    PULL_DELAY: 0.5
                    DRIFT_TIMEOUT: 16.0
                    CAMERA_SHAPE: "square"
                  BOLOGNESE:
                    MODE: "bolognese"
                    LAUNCH_OPTIONS: ""
                    CAST_POWER_LEVEL: 5.0
                    CAST_DELAY: 4.0
                    FLOAT_SENSITIVITY: 0.68
                    CHECK_DELAY: 1.0
                    PULL_DELAY: 0.5
                    DRIFT_TIMEOUT: 32.0
                    CAMERA_SHAPE: "square"
                    POST_ACCELERATION: "off"
            üìÑ defaults.py
                """Default yacs config node."""
                
                from yacs.config import CfgNode as CN
                
                _C = CN()
                _C.VERSION = "0.5.2"
                
                # ---------------------------------------------------------------------------- #
                #                                    General                                   #
                # ---------------------------------------------------------------------------- #
                _C.SCRIPT = CN()
                _C.SCRIPT.LANGUAGE = "en"  # Language for the script. Options: en, ru, zh-TW, zh-CN
                _C.SCRIPT.LAUNCH_OPTIONS = ""  # Default launch options for the script, e.g., -r -c -H
                _C.SCRIPT.SMTP_VERIFICATION = True
                _C.SCRIPT.IMAGE_VERIFICATION = True
                _C.SCRIPT.SNAG_DETECTION = True
                _C.SCRIPT.SPOOLING_DETECTION = True
                _C.SCRIPT.RANDOM_ROD_SELECTION = True  # For bottom mode
                # Confidence threshold for spooling detection (lower = more sensitive)
                _C.SCRIPT.SPOOL_CONFIDENCE = 0.98
                # Delay before recasting spod rod (in seconds)
                # Use bottom mode and -o to enable it.
                _C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800
                # Delay before changing lure randomly (in seconds)
                # Use spin mode and -L to enable it.
                _C.SCRIPT.LURE_CHANGE_DELAY = 1800
                _C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # Path to alarm sound file
                # Probability to add a redundant rod cast (0.0 to 1.0)
                _C.SCRIPT.RANDOM_CAST_PROBABILITY = 0.25
                # When using -s flag, only take screenshot of the fishes with tags below
                # If left empty, the script will take screenshot of every fish you caught
                _C.SCRIPT.SCREENSHOT_TAGS = ("green", "yellow", "blue", "purple", "pink")
                
                # ---------------------------------------------------------------------------- #
                #                                  Key Binding                                 #
                # ---------------------------------------------------------------------------- #
                _C.KEY = CN()
                _C.KEY.TEA = -1  # Key binding for tea. Set to -1 to use quick selection menu
                _C.KEY.CARROT = -1  # Key binding for carrot. Set to -1 to use quick selection menu
                _C.KEY.BOTTOM_RODS = (1, 2, 3)  # Key bindings for bottom rods
                _C.KEY.COFFEE = 4  # Key binding for coffee. Set to -1 to use quick selection menu
                _C.KEY.DIGGING_TOOL = 5  # Key binding for digging tool
                _C.KEY.ALCOHOL = 6  # Key binding for alcohol
                # Key binding for the main rod (used when harvesting baits with one rod)
                _C.KEY.MAIN_ROD = 1
                _C.KEY.SPOD_ROD = 7  # Key binding for the spod rod (used in bottom mode)
                # Key binding to stop the script (default is Ctrl-C)
                # If you want to use a special quitting shortcut, please refer to pynput's docs:
                # https://pynput.readthedocs.io/en/latest/keyboard.html#pynput.keyboard.Key .
                _C.KEY.QUIT = "CTRL-C"
                
                # ---------------------------------------------------------------------------- #
                #                                 Player Stats                                 #
                # ---------------------------------------------------------------------------- #
                _C.STAT = CN()
                # Minimum energy level before drinking coffee/harvesting baits
                _C.STAT.ENERGY_THRESHOLD = 0.74
                _C.STAT.HUNGER_THRESHOLD = 0.5  # Minimum hunger level before consuming carrot
                _C.STAT.COMFORT_THRESHOLD = 0.51  # Minimum comfort level before consuming tea
                _C.STAT.TEA_DELAY = 300  # Delay between tea drinks (in seconds)
                _C.STAT.COFFEE_LIMIT = 10  # Maximum coffee drinks per fish fight.
                _C.STAT.COFFEE_PER_DRINK = 1  # Amount of coffee consumed per drink
                _C.STAT.ALCOHOL_DELAY = 900  # Delay between alcohol drinks (in seconds)
                _C.STAT.ALCOHOL_PER_DRINK = 1  # Amount of alcohol consumed per drink
                
                # ---------------------------------------------------------------------------- #
                #                   Friction Brake (Use -f flag to enable it)                  #
                # ---------------------------------------------------------------------------- #
                _C.FRICTION_BRAKE = CN()
                _C.FRICTION_BRAKE.INITIAL = 29  # Initial friction brake value
                _C.FRICTION_BRAKE.MAX = 30  # Maximum friction brake value
                # Delay before starting to adjust friction brake after a fish is hooked
                _C.FRICTION_BRAKE.START_DELAY = 2.0
                _C.FRICTION_BRAKE.INCREASE_DELAY = 1.0  # Delay before increasing friction brake
                _C.FRICTION_BRAKE.SENSITIVITY = "medium"  # Sensitivity of friction brake detection
                
                # ---------------------------------------------------------------------------- #
                #                                    Keepnet                                   #
                # ---------------------------------------------------------------------------- #
                _C.KEEPNET = CN()
                _C.KEEPNET.CAPACITY = 100
                _C.KEEPNET.FISH_DELAY = 0.0  # Delay before keeping the fish (for screenshots)
                _C.KEEPNET.GIFT_DELAY = 4.0  # Delay before keeping the gift (for screenshots)
                _C.KEEPNET.FULL_ACTION = "quit"  # Action when keepnet is full. Options: quit, alarm
                # Whitelist for untagged fish releasing when using -t flag
                # Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
                _C.KEEPNET.WHITELIST = (
                    "mackerel",
                    "saithe",
                    "herring",
                    "squid",
                    "scallop",
                    "mussel",
                )
                # Fish in the blacklist will always be released
                # Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
                _C.KEEPNET.BLACKLIST = ()
                # When using -t flag, only the fish with tags below would be kept
                _C.KEEPNET.TAGS = ("green", "yellow", "blue", "purple", "pink")
                
                
                # ---------------------------------------------------------------------------- #
                #                                 Notification                                 #
                # ---------------------------------------------------------------------------- #
                _C.NOTIFICATION = CN()
                _C.NOTIFICATION.EMAIL = "email@example.com"
                _C.NOTIFICATION.PASSWORD = "password"
                _C.NOTIFICATION.SMTP_SERVER = "smtp.gmail.com"
                _C.NOTIFICATION.MIAO_CODE = "example"
                _C.NOTIFICATION.DISCORD_WEBHOOK_URL = ""
                
                # ---------------------------------------------------------------------------- #
                #                       Pause ( use -X flag to enable it)                      #
                # ---------------------------------------------------------------------------- #
                _C.PAUSE = CN()
                _C.PAUSE.DELAY = 1800  # Delay between pauses (in seconds)
                _C.PAUSE.DURATION = 600  # Duration of pause (in seconds)
                
                _C.PROFILE = CN()
                # ---------------------------------------------------------------------------- #
                #                             Spin Fishing Profile                             #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.SPIN = CN()
                _C.PROFILE.SPIN.MODE = "spin"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.SPIN.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.SPIN.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.SPIN.CAST_DELAY = 6.0
                # Duration to tighten the fishing line after casting
                _C.PROFILE.SPIN.TIGHTEN_DURATION = 0.0
                # Duration of retrieving the line or lifting the rod (right mosue button)
                _C.PROFILE.SPIN.RETRIEVAL_DURATION = 0.0
                # Delay after retrieving the line or lifting the rod (right mosue button)
                _C.PROFILE.SPIN.RETRIEVAL_DELAY = 0.0
                # Timeout for retrieving with pause/lift, followed by the normal retrieval
                _C.PROFILE.SPIN.RETRIEVAL_TIMEOUT = 256.0
                # Hold down the Shift key when performing special spin fishing techniques
                _C.PROFILE.SPIN.PRE_ACCELERATION = False
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.SPIN.POST_ACCELERATION = "off"
                # Type of special spin fishing technique to perform. Options: normal, pause, lift
                _C.PROFILE.SPIN.TYPE = "normal"
                
                _C.PROFILE.SPIN_WITH_PAUSE = CN()
                _C.PROFILE.SPIN_WITH_PAUSE.MODE = "spin"
                _C.PROFILE.SPIN_WITH_PAUSE.LAUNCH_OPTIONS = ""
                _C.PROFILE.SPIN_WITH_PAUSE.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.SPIN_WITH_PAUSE.CAST_DELAY = 6.0
                _C.PROFILE.SPIN_WITH_PAUSE.TIGHTEN_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DELAY = 3.0
                _C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_TIMEOUT = 256.0
                _C.PROFILE.SPIN_WITH_PAUSE.PRE_ACCELERATION = False
                _C.PROFILE.SPIN_WITH_PAUSE.POST_ACCELERATION = "off"
                _C.PROFILE.SPIN_WITH_PAUSE.TYPE = "pause"
                
                
                _C.PROFILE.SPIN_WITH_LIFT = CN()
                _C.PROFILE.SPIN_WITH_LIFT.MODE = "spin"
                _C.PROFILE.SPIN_WITH_LIFT.LAUNCH_OPTIONS = ""
                _C.PROFILE.SPIN_WITH_LIFT.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.SPIN_WITH_LIFT.CAST_DELAY = 6.0
                _C.PROFILE.SPIN_WITH_LIFT.TIGHTEN_DURATION = 0.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DURATION = 1.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DELAY = 1.0
                _C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_TIMEOUT = 256.0
                _C.PROFILE.SPIN_WITH_LIFT.PRE_ACCELERATION = False
                _C.PROFILE.SPIN_WITH_LIFT.POST_ACCELERATION = "off"
                _C.PROFILE.SPIN_WITH_LIFT.TYPE = "lift"
                
                
                # ---------------------------------------------------------------------------- #
                #                            Bottom Fishing Profile                            #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.BOTTOM = CN()
                _C.PROFILE.BOTTOM.MODE = "bottom"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.BOTTOM.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.BOTTOM.CAST_POWER_LEVEL = 5.0
                _C.PROFILE.BOTTOM.CAST_DELAY = 4.0  # Delay after casting before lure sinks
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.BOTTOM.POST_ACCELERATION = "off"
                # Delay before checking fish bite on next rod
                _C.PROFILE.BOTTOM.CHECK_DELAY = 32.0
                # Maximum allowed misses before recasting the rod
                _C.PROFILE.BOTTOM.CHECK_MISS_LIMIT = 16
                # Delay before checking if a fish is hooked again and putting down the rod
                _C.PROFILE.BOTTOM.PUT_DOWN_DELAY = 0.0
                
                
                # ---------------------------------------------------------------------------- #
                #                      Marine / Wakey Rig Pirking Profile                      #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.PIRK = CN()
                _C.PROFILE.PIRK.MODE = "pirk"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.PIRK.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.PIRK.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.PIRK.CAST_DELAY = 4.0  # Delay after casting before lure sinks
                _C.PROFILE.PIRK.SINK_TIMEOUT = 60.0  # Maximum time allowed for sinking
                # Duration to tighten the line after sinking lure/adjusting lure depth
                _C.PROFILE.PIRK.TIGHTEN_DURATION = 1.0
                # Delay after opening reel to adjust lure depth, set this to 0 to recast the rod instead
                _C.PROFILE.PIRK.DEPTH_ADJUST_DELAY = 4.0
                # Durtion to tighten the line after opening reel for DEPTH_ADJUST_DELAY seconds
                _C.PROFILE.PIRK.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.PIRK.CTRL = False  # Hold Ctrl key during pirking
                _C.PROFILE.PIRK.SHIFT = False  # Hold Shift key during pirking
                # Duration of lifting the rod, set this to 0 if you want to wait instead of pirking
                _C.PROFILE.PIRK.PIRK_DURATION = 0.5
                _C.PROFILE.PIRK.PIRK_DELAY = 2.0  # Delay after lifting the rod
                # Timeout for pirking session
                _C.PROFILE.PIRK.PIRK_TIMEOUT = 32.0
                # Retrieve the fishing line during pirking
                _C.PROFILE.PIRK.PIRK_RETRIEVAL = False
                # When a fish is hooked, check if the fish is still hooked
                # after HOOK_DELAY seconds, continue pirking if not
                _C.PROFILE.PIRK.HOOK_DELAY = 0.5
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.PIRK.POST_ACCELERATION = "auto"
                
                _C.PROFILE.PIRK_WITH_RETRIEVAL = CN()
                _C.PROFILE.PIRK_WITH_RETRIEVAL.MODE = "pirk"
                _C.PROFILE.PIRK_WITH_RETRIEVAL.LAUNCH_OPTIONS = ""
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_DELAY = 4.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.SINK_TIMEOUT = 60.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.TIGHTEN_DURATION = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DELAY = 0.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.CTRL = False
                _C.PROFILE.PIRK_WITH_RETRIEVAL.SHIFT = False
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DURATION = 0.5
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DELAY = 2.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_TIMEOUT = 32.0
                _C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_RETRIEVAL = True
                _C.PROFILE.PIRK_WITH_RETRIEVAL.HOOK_DELAY = 0.5
                _C.PROFILE.PIRK_WITH_RETRIEVAL.POST_ACCELERATION = "auto"
                
                # Spin fishing with wakey rig at Ladoga Archipelago
                _C.PROFILE.WAKEY_RIG = CN()
                _C.PROFILE.WAKEY_RIG.MODE = "pirk"
                _C.PROFILE.WAKEY_RIG.LAUNCH_OPTIONS = ""
                _C.PROFILE.WAKEY_RIG.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.WAKEY_RIG.CAST_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.SINK_TIMEOUT = 45.0
                _C.PROFILE.WAKEY_RIG.TIGHTEN_DURATION = 1.0
                _C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DURATION = 1.0
                _C.PROFILE.WAKEY_RIG.CTRL = True
                _C.PROFILE.WAKEY_RIG.CTRL = False
                _C.PROFILE.WAKEY_RIG.PIRK_DURATION = 1.5
                _C.PROFILE.WAKEY_RIG.PIRK_DELAY = 4.0
                _C.PROFILE.WAKEY_RIG.PIRK_TIMEOUT = 32.0
                _C.PROFILE.WAKEY_RIG.PIRK_RETRIEVAL = False
                _C.PROFILE.WAKEY_RIG.HOOK_DELAY = 0.5
                _C.PROFILE.WAKEY_RIG.POST_ACCELERATION = "auto"
                
                # ---------------------------------------------------------------------------- #
                #                            Marine Elevator Profile                           #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.ELEVATOR = CN()
                _C.PROFILE.ELEVATOR.MODE = "elevator"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.ELEVATOR.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.ELEVATOR.CAST_POWER_LEVEL = 1.0
                # Delay after casting before lure sinks
                _C.PROFILE.ELEVATOR.CAST_DELAY = 4.0
                # Maximum time allowed for sinking
                _C.PROFILE.ELEVATOR.SINK_TIMEOUT = 60.0
                # Duration to tighten the line after sinking lure
                _C.PROFILE.ELEVATOR.TIGHTEN_DURATION = 1.0
                # Duration of retrieving the fishing line/opening the reel
                _C.PROFILE.ELEVATOR.ELEVATE_DURATION = 4.0
                # Delay after retrieving the fishing line/opening the reel
                _C.PROFILE.ELEVATOR.ELEVATE_DELAY = 4.0
                # Timeout for pirking session
                _C.PROFILE.ELEVATOR.ELEVATE_TIMEOUT = 40.0
                # Lock / Unlocking the reel after elevating timed out to drop the lure level by level
                _C.PROFILE.ELEVATOR.DROP = False
                # When a fish is hooked, check if the fish is still hooked
                # after HOOK_DELAY seconds, continue elevating if not
                _C.PROFILE.ELEVATOR.HOOK_DELAY = 0.5
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.ELEVATOR.POST_ACCELERATION = "auto"
                
                _C.PROFILE.ELEVATOR_WITH_DROP = CN()
                _C.PROFILE.ELEVATOR_WITH_DROP.MODE = "elevator"
                _C.PROFILE.ELEVATOR_WITH_DROP.LAUNCH_OPTIONS = ""
                _C.PROFILE.ELEVATOR_WITH_DROP.CAST_POWER_LEVEL = 1.0
                _C.PROFILE.ELEVATOR_WITH_DROP.CAST_DELAY = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.SINK_TIMEOUT = 60.0
                _C.PROFILE.ELEVATOR_WITH_DROP.TIGHTEN_DURATION = 1.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DURATION = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DELAY = 4.0
                _C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_TIMEOUT = 40.0
                _C.PROFILE.ELEVATOR_WITH_DROP.DROP = True
                _C.PROFILE.ELEVATOR_WITH_DROP.HOOK_DELAY = 0.5
                _C.PROFILE.ELEVATOR_WITH_DROP.POST_ACCELERATION = "auto"
                
                # ---------------------------------------------------------------------------- #
                #                          Telescopic fishing Profile                          #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.TELESCOPIC = CN()
                _C.PROFILE.TELESCOPIC.MODE = "telescopic"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.TELESCOPIC.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.TELESCOPIC.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.TELESCOPIC.CAST_DELAY = 4.0
                # Sensitivity of float detection
                _C.PROFILE.TELESCOPIC.FLOAT_SENSITIVITY = 0.68
                _C.PROFILE.TELESCOPIC.CHECK_DELAY = 1.0  # Delay between fish bite checks
                _C.PROFILE.TELESCOPIC.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
                # Recast rod after timed out, designed for flowing water maps
                _C.PROFILE.TELESCOPIC.DRIFT_TIMEOUT = 16.0
                # Shape of the float camera, the script tracks the whole camrea window by default
                # Options: square, wide, tall
                _C.PROFILE.TELESCOPIC.CAMERA_SHAPE = "square"
                
                
                # ---------------------------------------------------------------------------- #
                #                           Bolognese Fishing Profile                          #
                # ---------------------------------------------------------------------------- #
                _C.PROFILE.BOLOGNESE = CN()
                _C.PROFILE.BOLOGNESE.MODE = "bolognese"
                # Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
                # Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
                _C.PROFILE.BOLOGNESE.LAUNCH_OPTIONS = ""
                # Power level for casting, 1 ~ 5
                # 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
                # For instance, 2.5 cast_power_level equals to 37.5% casting power
                _C.PROFILE.BOLOGNESE.CAST_POWER_LEVEL = 5.0
                # Delay after casting before lure sinks
                _C.PROFILE.BOLOGNESE.CAST_DELAY = 4.0
                # Sensitivity of float detection
                _C.PROFILE.BOLOGNESE.FLOAT_SENSITIVITY = 0.68
                _C.PROFILE.BOLOGNESE.CHECK_DELAY = 1.0  # Delay between fish bite checks
                _C.PROFILE.BOLOGNESE.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
                # Recast rod after timed out, designed for flowing water maps
                _C.PROFILE.BOLOGNESE.DRIFT_TIMEOUT = 32.0
                # Shape of the float camera, the script tracks the whole camrea window by default
                # Options: square, wide, tall
                # (Fallback to float camera detection mode if the window size is not supported)
                _C.PROFILE.BOLOGNESE.CAMERA_SHAPE = "square"
                # Hold Shift key during fish fight. Options: on, off, auto
                _C.PROFILE.BOLOGNESE.POST_ACCELERATION = "off"
                
                
                def get_cfg_defaults():
                    """Get a yacs CfgNode object with default values for my_project."""
                    # Return a clone so that the defaults will not be altered
                    # This is for the "local variable" use pattern
                    return _C.clone()
            üìÑ __init__.py
                [EMPTY FILE]
            üìÅ __pycache__/
                üìÑ config.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ defaults.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ controller/
            üìÑ detection.py
                """Module for pyautogui.locateOnScreen and pag.pixel wrappers.
                
                This module provides functionality for detecting in-game elements using image recognition
                and pixel color analysis. It is used for automating tasks in Russian Fishing 4.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import time
                from enum import Enum
                from functools import partial
                from pathlib import Path
                from typing import Generator
                
                import cv2
                import numpy as np
                import pyautogui as pag
                from PIL import Image
                from pyscreeze import Box
                
                from rf4s.controller.window import Window
                
                CRITICAL_COLOR = (206, 56, 21)
                WARNING_COLOR = (227, 149, 23)
                WHITE = (255, 255, 255)
                
                MIN_GRAY_SCALE_LEVEL = 150
                YELLOW_FRICTION_BRAKE = (200, 214, 63)
                ORANGE_FRICTION_BRAKE = (229, 188, 0)
                RED_FRICTION_BRAKE = (206, 56, 21)
                COLOR_TOLERANCE = 32
                CAMERA_OFFSET = 40
                SIDE_LENGTH = 160
                SIDE_LENGTH_HALF = 80
                ORANGE_REEL = (227, 149, 23)
                
                ROOT = Path(__file__).resolve().parents[2]
                
                
                class TagColor(Enum):
                    GREEN = "green_tag"
                    YELLOW = "yellow_tag"
                    PINK = "pink_tag"
                    BLUE = "blue_tag"
                    PURPLE = "purple_tag"
                
                
                COORD_OFFSETS = {
                    "1600x900": {
                        "friction_brake_very_high": (502, 872),  # Left point only
                        "friction_brake_high": (459, 872),
                        "friction_brake_medium": (417, 872),
                        "friction_brake_low": (396, 872),
                        "fish_icon": (389, 844),
                        "clip_icon": (1042, 844),
                        "spool_icon": (1077, 844),  # x + 15, y + 15
                        "reel_burning_icon": (1112, 842),
                        "snag_icon": (1147, 829),  # x + 15, y
                        "float_camera": (720, 654),
                        "bait_icon": (35, 31),
                    },
                    "1920x1080": {
                        "friction_brake_very_high": (662, 1052),
                        "friction_brake_high": (619, 1052),
                        "friction_brake_medium": (577, 1052),
                        "friction_brake_low": (556, 1052),
                        "fish_icon": (549, 1024),
                        "clip_icon": (1202, 1024),
                        "spool_icon": (1237, 1024),
                        "reel_burning_icon": (1271, 1023),
                        "snag_icon": (1307, 1009),
                        "float_camera": (880, 834),
                        "bait_icon": (35, 31),
                    },
                    "2560x1440": {
                        "friction_brake_very_high": (982, 1412),
                        "friction_brake_high": (939, 1412),
                        "friction_brake_medium": (897, 1412),
                        "friction_brake_low": (876, 1412),
                        "fish_icon": (869, 1384),
                        "clip_icon": (1522, 1384),
                        "spool_icon": (1557, 1384),
                        "reel_burning_icon": (1593, 1383),
                        "snag_icon": (1627, 1369),
                        "float_camera": (1200, 1194),
                        "bait_icon": (35, 31),
                    },
                }
                
                # ------------------------ Friction brake coordinates ------------------------ #
                # ----------------------------- 900p - 1080p - 2k ---------------------------- #
                # ------ left - red - yellow - center(left + 424) - yellow - red - right ----- #
                # "bases": ((480, 270), (320, 180), (0, 0))
                # "absolute": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702, "y": (1146, 1236, 1412)}
                # "1600x900": {"x": (375, 480, 586, 799, 1011, 1118, 1222), "y": 876},
                # "1920x1080": {"x": (535, 640, 746, 959, 1171, 1278, 1382), "y": 1056},
                # "2560x1440": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702), "y": 1412},
                
                
                class Detection:
                    """A class that holds different aliases of locateOnScreen(image).
                
                    This class provides methods for detecting various in-game elements such as fish,
                    icons, and UI components using image recognition and pixel color analysis.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for the detection settings.
                        window (Window): Game window controller instance.
                        image_dir (Path): Directory containing reference images for detection.
                        coord_offsets (dict): Dictionary of coordinate offsets for different window sizes.
                        bait_icon_reference_img (Image): Reference image for bait icon detection.
                    """
                
                    def __init__(self, cfg, window: Window):
                        """Initialize the Detection class with configuration and window settings.
                
                        :param cfg: Configuration node for detection settings.
                        :type cfg: CfgNode
                        :param window: Game window controller instance.
                        :type window: Window
                        """
                        self.cfg = cfg
                        self.window = window
                        self.image_dir = ROOT / "static" / cfg.SCRIPT.LANGUAGE
                
                        if window.is_size_supported():
                            self._set_absolute_coords()
                            self.is_fish_hooked = self.is_fish_hooked_pixel
                        else:
                            self.is_fish_hooked = partial(
                                self._get_image_box,
                                image="fish_icon",
                                confidence="0.9",
                            )
                
                        self.bait_icon_reference_img = Image.open(self.image_dir / "bait_icon.png")
                
                    def _get_image_box(
                        self, image: str, confidence: float, multiple: bool = False
                    ) -> Box | Generator[Box, None, None] | None:
                        """A wrapper for locateOnScreen method and path resolving.
                
                        :param image: Base name of the image.
                        :type image: str
                        :param confidence: Matching confidence for locateOnScreen.
                        :type confidence: float
                        :param multiple: Whether to locate all matching images, defaults to False.
                        :type multiple: bool, optional
                        :return: Image box, None if not found.
                        :rtype: Box | None
                        """
                        image_path = str(self.image_dir / f"{image}.png")
                        if multiple:
                            return pag.locateAllOnScreen(image_path, confidence=confidence)
                        return pag.locateOnScreen(image_path, confidence=confidence)
                
                    def _set_absolute_coords(self) -> None:
                        """Add offsets to the base coordinates to get absolute ones."""
                        self.coord_offsets = COORD_OFFSETS[self.window.get_resolution_str()]
                
                        for key in self.coord_offsets:
                            setattr(self, f"{key}_coord", self._get_absolute_coord(key))
                
                        self.bait_icon_coord = self._get_absolute_coord("bait_icon") + [44, 52]
                        friction_brake_key = f"friction_brake_{self.cfg.FRICTION_BRAKE.SENSITIVITY}"
                        self.friction_brake_coord = self._get_absolute_coord(friction_brake_key)
                
                        bases = self._get_absolute_coord("float_camera")
                        if self.cfg.SELECTED.MODE in ("telescopic", "bolognese"):
                            match self.cfg.SELECTED.CAMERA_SHAPE:
                                case "tall":
                                    bases[0] += CAMERA_OFFSET
                                    width, height = SIDE_LENGTH_HALF, SIDE_LENGTH
                                case "wide":
                                    bases[1] += CAMERA_OFFSET
                                    width, height = SIDE_LENGTH, SIDE_LENGTH_HALF
                                case "square":
                                    width, height = SIDE_LENGTH, SIDE_LENGTH
                                case _:
                                    raise ValueError(self.cfg.SELECTED.CAMERA_SHAPE)
                            self.float_camera_rect = (*bases, width, height)  # (left, top, w, h)
                
                    def _get_absolute_coord(self, offset_key: str) -> list[int]:
                        """Calculate absolute coordinate based on given key.
                
                        :param offset_key: A key in the offset dictionary.
                        :type offset_key: str
                        :return: Converted absolute coordinate.
                        :rtype: list[int]
                        """
                        box = self.window.get_box()
                        return [box[i] + self.coord_offsets[offset_key][i] for i in range(2)]
                
                    # ----------------------------- Untagged release ----------------------------- #
                    def is_tag_exist(self, color: TagColor):
                        match color:
                            case TagColor.GREEN:
                                lower = np.array([30, 128, 128])
                                upper = np.array([36, 255, 255])
                            case TagColor.YELLOW:
                                lower = np.array([22, 128, 128])
                                upper = np.array([28, 255, 255])
                            case TagColor.PINK:
                                lower = np.array([142, 64, 128])
                                upper = np.array([148, 255, 255])
                            case TagColor.BLUE:
                                lower = np.array([101, 64, 128])
                                upper = np.array([107, 255, 255])
                            case TagColor.PURPLE:
                                lower = np.array([127, 64, 128])
                                upper = np.array([133, 255, 255])
                            case _:
                                raise ValueError("Invalid tag color")
                        hsv_img = cv2.cvtColor(np.array(pag.screenshot()), cv2.COLOR_RGB2HSV)
                        mask = cv2.inRange(hsv_img, lower, upper)
                        haystack_img = Image.fromarray(mask)
                        needle_img = Image.open(self.image_dir / f"{color.value}.png")
                        return pag.locate(needle_img, haystack_img, grayscale=True, confidence=0.9)
                
                    def is_fish_species_matched(self, species: str):
                        return self._get_image_box(species, 0.9)
                
                    # -------------------------------- Fish status ------------------------------- #
                    def is_fish_hooked(self):
                        pass  # It's initialized in the constructor
                
                    def is_fish_hooked_pixel(self) -> bool:
                        return all(c > MIN_GRAY_SCALE_LEVEL for c in pag.pixel(*self.fish_icon_coord))
                
                    def is_fish_hooked_twice(self) -> bool:
                        if not self.is_fish_hooked():
                            return False
                
                        # check if the fish got away after a short delay
                        time.sleep(self.cfg.SELECTED.HOOK_DELAY)
                        if self.is_fish_hooked():
                            return True
                        return False
                
                    def is_fish_captured(self):
                        return self._get_image_box("keep", 0.9)
                
                    def is_fish_whitelisted(self) -> bool:
                        """Check if the fish is in the whitelist.
                
                        :return: True if the fish is in the whitelist, False otherwise.
                        :rtype: bool
                        """
                        return self._is_fish_in_list(self.cfg.KEEPNET.WHITELIST)
                
                    def is_fish_blacklisted(self) -> bool:
                        """Check if the fish is in the blacklist.
                
                        :return:  True if the fish is in the blacklist, False otherwise
                        :rtype: bool
                        """
                        return self._is_fish_in_list(self.cfg.KEEPNET.BLACKLIST)
                
                    def _is_fish_in_list(self, fish_species_list: tuple | list) -> bool:
                        """Check if the fish species matches any in the table.
                
                        :param fish_species_list: fish species list
                        :type fish_species_list: tuple | list
                        :return: True if the fish species matches, False otherwise
                        :rtype: bool
                        """
                        for species in fish_species_list:
                            if self.is_fish_species_matched(species):
                                return True
                        return False
                
                    # ---------------------------- Retrieval detection --------------------------- #
                    def is_retrieval_finished(self):
                        ready = self.is_tackle_ready()
                        if self.cfg.ARGS.RAINBOW:
                            return ready or self._is_rainbow_line_0or5m()
                        return ready or self._is_spool_full()
                
                    def _is_rainbow_line_0or5m(self):
                        return self._get_image_box(
                            "5m", self.cfg.SCRIPT.SPOOL_CONFIDENCE
                        ) or self._get_image_box("0m", self.cfg.SCRIPT.SPOOL_CONFIDENCE)
                
                    def _is_spool_full(self):
                        return self._get_image_box("wheel", self.cfg.SCRIPT.SPOOL_CONFIDENCE)
                
                    def is_line_snagged(self) -> bool:
                        return pag.pixel(*self.snag_icon_coord) == CRITICAL_COLOR
                
                    def is_line_at_end(self) -> bool:
                        return pag.pixel(*self.spool_icon_coord) in (WARNING_COLOR, CRITICAL_COLOR)
                
                    def is_clip_open(self) -> bool:
                        return not all(
                            c > MIN_GRAY_SCALE_LEVEL for c in pag.pixel(*self.clip_icon_coord)
                        )
                
                    # ------------------------------ Text detection ------------------------------ #
                    def is_tackle_ready(self):
                        return self._get_image_box("ready", 0.6)
                
                    def is_tackle_broken(self):
                        return self._get_image_box("broke", 0.8)
                
                    def is_lure_broken(self):
                        return self._get_image_box("lure_is_broken", 0.8)
                
                    def is_moving_in_bottom_layer(self):
                        return self._get_image_box("movement", 0.7)
                
                    # ------------------------------ Hint detection ------------------------------ #
                    def is_disconnected(self):
                        return self._get_image_box("disconnected", 0.9)
                
                    def is_ticket_expired(self):
                        return self._get_image_box("ticket", 0.9)
                
                    # ------------------------------- Item crafting ------------------------------ #
                    def is_operation_failed(self):
                        return self._get_image_box("warning", 0.8)
                
                    def is_operation_success(self):
                        return self._get_image_box("ok_black", 0.8) or self._get_image_box(
                            "ok_white", 0.8
                        )
                
                    def is_material_complete(self):
                        return not self._get_image_box("material_slot", 0.7)
                
                    # ---------------------- Quiting game from control panel --------------------- #
                    def get_quit_position(self):
                        return self._get_image_box("quit", 0.8)
                
                    def get_yes_position(self):
                        return self._get_image_box("yes", 0.8)
                
                    def get_make_button_position(self):
                        return self._get_image_box("make", 0.9)
                
                    # ------------------------ Quiting game from main menu ----------------------- #
                    def get_exit_icon_position(self):
                        return self._get_image_box("exit", 0.8)
                
                    def get_confirm_button_position(self):
                        return self._get_image_box("confirm", 0.8)
                
                    # ------------------------------- Player stats ------------------------------- #
                    def _get_energy_icon_position(self):
                        box = self._get_image_box("energy", 0.8)
                        return box if box is None else pag.center(box)
                
                    def _get_food_icon_position(self):
                        box = self._get_image_box("food", 0.8)
                        return box if box is None else pag.center(box)
                
                    def _get_comfort_icon_position(self):
                        box = self._get_image_box("comfort", 0.8)
                        return box if box is None else pag.center(box)
                
                    def get_food_position(self, food: str):
                        return self._get_image_box(food, 0.9)
                
                    def is_energy_high(self) -> bool:
                        pos = self._get_energy_icon_position()
                        if not pos:
                            return False
                        x, y = int(pos.x), int(pos.y)
                        # default threshold: 0.74,  well done FishSoft
                        last_point = int(19 + 152 * self.cfg.STAT.ENERGY_THRESHOLD) - 1
                        return pag.pixel(x + 19, y) == pag.pixel(x + last_point, y)
                
                    def is_hunger_low(self) -> bool:
                        pos = self._get_food_icon_position()
                        if not pos:
                            return False
                        x, y = int(pos.x), int(pos.y)
                        last_point = int(18 + 152 * self.cfg.STAT.HUNGER_THRESHOLD) - 1
                        return not pag.pixel(x + 18, y) == pag.pixel(x + last_point, y)
                
                    def is_comfort_low(self) -> bool:
                        pos = self._get_comfort_icon_position()
                        if not pos:
                            return False
                        x, y = int(pos.x), int(pos.y)
                        last_point = int(18 + 152 * self.cfg.STAT.COMFORT_THRESHOLD) - 1
                        return not pag.pixel(x + 18, y) == pag.pixel(x + last_point, y)
                
                    # ----------------------------- Item replacement ----------------------------- #
                    def get_scrollbar_position(self):
                        return self._get_image_box("scrollbar", 0.97)
                
                    def get_100wear_position(self):
                        return self._get_image_box("100wear", 0.98)
                
                    def get_favorite_item_positions(self):
                        return self._get_image_box("favorite", 0.95, multiple=True)
                
                    def is_pva_chosen(self):
                        return self._get_image_box("pva_icon", 0.6) is None
                
                    def is_bait_chosen(self):
                        if self.cfg.SELECTED.MODE in ("pirk", "elevator"):
                            return True
                
                        # Two bait slots, check only the first one
                        if self.cfg.SELECTED.MODE in ("telescopic", "bolognese"):
                            return (
                                pag.locate(
                                    pag.screenshot(region=self.bait_icon_coord),
                                    self.bait_icon_reference_img,
                                    confidence=0.6,
                                )
                                is None
                            )
                        return self._get_image_box("bait_icon", 0.6) is None
                
                    def is_groundbait_chosen(self):
                        return self._get_image_box("groundbait_icon", 0.6) is None
                
                    def get_groundbait_position(self):
                        return self._get_image_box("classic_feed_mix", 0.95)
                
                    def get_dry_mix_position(self):
                        return self._get_image_box("dry_feed_mix", 0.95)
                
                    def get_pva_position(self):
                        return self._get_image_box("pva_stick_or_pva_stringer", 0.95)
                
                    # ------------------------------ Friction brake ------------------------------ #
                    def is_friction_brake_high(self) -> bool:
                        return pag.pixelMatchesColor(
                            *self.friction_brake_coord, RED_FRICTION_BRAKE, COLOR_TOLERANCE
                        )
                
                    def is_reel_burning(self) -> bool:
                        return pag.pixel(*self.reel_burning_icon_coord) == ORANGE_REEL
                
                    def is_float_state_changed(self, reference_img):
                        current_img = pag.screenshot(region=self.float_camera_rect)
                        return not pag.locate(
                            current_img,
                            reference_img,
                            grayscale=True,
                            confidence=self.cfg.SELECTED.FLOAT_SENSITIVITY,
                        )
                
                    def get_ticket_position(self, duration: int):
                        return self._get_image_box(f"ticket_{duration}", 0.95)
                
                    def is_harvest_success(self):
                        return self._get_image_box("harvest_confirm", 0.8)
                
                    def is_gift_receieved(self):
                        return self._get_image_box("gift", 0.8)
            üìÑ notification.py
                import json
                import logging
                import smtplib
                from datetime import datetime, timezone
                from email.mime.multipart import MIMEMultipart
                from email.mime.text import MIMEText
                from enum import Enum
                from urllib import parse, request
                
                from discord_webhook import DiscordEmbed, DiscordWebhook
                from rich import box
                from rich.console import Console
                from rich.table import Table
                
                logger = logging.getLogger("rich")
                
                ICON_URL = "https://i.ibb.co/RpLYcdkm/icon.png"
                
                # Name                             | Int value | Hex code
                # ---------------------------------|-----------|----------
                # `BLURPLE`                        | 5793266   | `#5865F2`
                # `GREEN`                          | 5763719   | `#57F287`
                # `YELLOW`                         | 16705372  | `#FEE75C`
                # `FUSCHIA`                        | 15418782  | `#EB459E`
                # `RED`                            | 15548997  | `#ED4245`
                # `WHITE`                          | 16777215  | `#FFFFFF`
                # `BLACK`                          | 2303786   | `#23272A`
                
                
                class DiscordColor(Enum):
                    BLURPLE = 5793266
                    GREEN = 5763719
                    YELLOW = 16705372
                    FUSCHIA = 15418782
                    RED = 15548997
                    WHITE = 16777215
                    BLACK = 2303786
                
                
                class DiscordNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def build_raw_table(self) -> str:
                        console = Console(width=100, force_terminal=True, color_system=None)
                        table = Table("Field", "Value", box=box.DOUBLE, show_header=False)
                
                        for key, value in self.result.items():
                            table.add_row(key, str(value))
                
                        with console.capture() as capture:
                            console.print(table)
                
                        return capture.get().strip()
                
                    def send(self, color: DiscordColor):
                        logger.info("Sending Discord notification")
                        raw_table = self.build_raw_table()
                        webhook = DiscordWebhook(
                            url=self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL,
                            username="RF4S",
                            avatar_url=ICON_URL,
                        )
                
                        embed = DiscordEmbed(
                            title="Running Result",
                            color=color,
                            timestamp=datetime.now(timezone.utc).isoformat(),
                            footer={"text": "RF4S: Russian Fishing 4 Script", "icon_url": ICON_URL},
                        )
                        embed.description = f"```\n{raw_table}\n```"  # Wrap in code block
                
                        webhook.add_embed(embed)
                        response = webhook.execute()
                
                        if response.status_code == 200:
                            logger.info("Result successfully sent to Discord")
                        else:
                            logger.error(f"Failed to send result to Discord: {response.text}")
                
                
                class EmailNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def send(self) -> None:
                        """Send a notification email to the user's email address."""
                        logger.info("Sending email notification")
                
                        msg = MIMEMultipart()
                        msg["Subject"] = "RF4S: Notice of Program Termination"
                        msg["From"] = self.cfg.NOTIFICATION.EMAIL
                        recipients = [self.cfg.NOTIFICATION.EMAIL]
                        msg["To"] = ", ".join(recipients)
                
                        text = ""
                        for k, v in self.result.items():
                            text += f"{k}: {v}\n"
                        msg.attach(MIMEText(text))
                
                        try:
                            with smtplib.SMTP_SSL(self.cfg.NOTIFICATION.SMTP_SERVER, 465) as server:
                                # smtp_server.ehlo()
                                server.login(
                                    self.cfg.NOTIFICATION.EMAIL, self.cfg.NOTIFICATION.PASSWORD
                                )
                                server.sendmail(
                                    self.cfg.NOTIFICATION.EMAIL, recipients, msg.as_string()
                                )
                            logger.info("Email sent successfully")
                        except Exception as e:
                            logger.error(f"Failed to send email: {e}")
                
                
                class MiaotixingNotification:
                    def __init__(self, cfg, result):
                        self.cfg = cfg
                        self.result = result
                
                    def send(self) -> None:
                        """Send a notification to the user's miaotixing service.
                
                        :param result: running result
                        :type result: dict
                        """
                        logger.info("Sending miaotixing notification")
                
                        text = ""
                        for k, v in self.result.items():
                            text += f"{k}: {v}\n"
                
                        url = "http://miaotixing.com/trigger?" + parse.urlencode(
                            {"id": self.cfg.NOTIFICATION.MIAO_CODE, "text": text, "type": "json"}
                        )
                
                        with request.urlopen(url) as page:
                            result = page.read()
                            json_object = json.loads(result)
                            if json_object["code"] == 0:
                                logger.info("Miaotixing notification sent successfully")
                            else:
                                logger.error(
                                    "Miaotixing notification with error code: %s\nDescription: %s",
                                    str(json_object["code"]),
                                    json_object["msg"],
                                )
            üìÑ timer.py
                """Module for Timer class.
                
                This module provides functionality for managing timers and generating timestamps
                for logging and automation purposes in Russian Fishing 4.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import datetime
                import logging
                import sys
                import time
                from pathlib import Path
                
                from matplotlib import pyplot as plt
                from matplotlib.ticker import MaxNLocator
                
                from rf4s.utils import is_compiled
                
                logger = logging.getLogger("rich")
                
                
                if is_compiled():
                    ROOT = Path(sys.executable).parent  # Running as .exe (Nuitka/PyInstaller)
                else:
                    ROOT = Path(__file__).resolve().parents[2]
                
                
                class Timer:
                    """Class for calculating and generating timestamps for logs.
                
                    This class manages various timers and counters for tracking in-game events,
                    such as casting times, consumable cooldowns, and script pauses.
                
                    Attributes:
                        cfg (CfgNode): Configuration node for timer settings.
                        start_time (float): Timestamp when the timer was initialized.
                        start_datetime (str): Formatted start date and time.
                        cast_rhour (int | None): Real-time hour of the last cast.
                        cast_ghour (int | None): In-game hour of the last cast.
                        cast_rhour_list (list[int]): List of real-time hours for casts.
                        cast_ghour_list (list[int]): List of in-game hours for casts.
                        last_tea_drink (float): Timestamp of the last tea consumption.
                        last_alcohol_drink (float): Timestamp of the last alcohol consumption.
                        last_lure_change (float): Timestamp of the last lure change.
                        last_spod_rod_recast (float): Timestamp of the last spod rod recast.
                        last_pause (float): Timestamp of the last script pause.
                    """
                
                    def __init__(self, cfg):
                        """Initialize the Timer class with configuration settings.
                
                        :param cfg: Configuration node for timer settings.
                        :type cfg: CfgNode
                        """
                        self.cfg = cfg
                        self.start_time = time.time()
                        self.start_datetime = time.strftime("%m/%d %H:%M:%S", time.localtime())
                
                        self.cast_rhour = None
                        self.cast_ghour = None
                        self.cast_rhour_list = []
                        self.cast_ghour_list = []
                
                        self.last_tea_drink = 0
                        self.last_alcohol_drink = 0
                        self.last_lure_change = self.start_time
                        self.last_spod_rod_recast = self.start_time
                        self.last_pause = self.start_time
                
                    def get_running_time(self) -> str:
                        """Calculate the execution time of the program.
                
                        :return: Formatted execution time (hh:mm:ss).
                        :rtype: str
                        """
                        return time.time() - self.start_time
                
                    def get_running_time_str(self) -> str:
                        """Calculate the execution time of the program.
                
                        :return: Formatted execution time (hh:mm:ss).
                        :rtype: str
                        """
                        return str(
                            datetime.timedelta(seconds=int(time.time() - self.start_time))
                        )  # truncate to seconds
                
                    def get_cur_timestamp(self) -> str:
                        """Generate timestamp for images in screenshots/.
                
                        :return: Current timestamp.
                        :rtype: str
                        """
                        return time.strftime("%Y-%m-%d--%H-%M-%S", time.localtime())
                
                    def get_start_datetime(self) -> str:
                        """Generate a simplified timestamp for quit message.
                
                        :return: Start date and time.
                        :rtype: str
                        """
                        return self.start_datetime
                
                    def get_cur_datetime(self) -> str:
                        """Generate a simplified timestamp for quit message.
                
                        :return: Current date and time.
                        :rtype: str
                        """
                        return time.strftime("%m/%d %H:%M:%S", time.localtime())
                
                    def update_cast_time(self) -> None:
                        """Update the latest real and in-game hour of casting."""
                        dt = datetime.datetime.now()
                        self.cast_rhour = int((time.time() - self.start_time) // 3600)
                        self.cast_ghour = int((dt.minute / 60 + dt.second / 3600) * 24 % 24)
                
                    def add_cast_time(self) -> None:
                        """Record the latest real and in-game hour of casting."""
                        self.cast_rhour_list.append(self.cast_rhour)
                        self.cast_ghour_list.append(self.cast_ghour)
                
                    def get_cast_time_list(self) -> tuple[list[int]]:
                        """Get lists of real and in-game hours for casts.
                
                        :return: Lists of real and in-game hours.
                        :rtype: tuple[list[int]]
                        """
                        return self.cast_rhour_list, self.cast_ghour_list
                
                    def is_tea_drinkable(self) -> bool:
                        """Check if it has been a long time since the last tea consumption.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_tea_drink > self.cfg.STAT.TEA_DELAY:
                            self.last_tea_drink = cur_time
                            return True
                        return False
                
                    def is_alcohol_drinkable(self) -> bool:
                        """Check if it has been a long time since the last alcohol consumption.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_alcohol_drink > self.cfg.STAT.ALCOHOL_DELAY:
                            self.last_alcohol_drink = cur_time
                            self.last_tea_drink = cur_time  # Alcohol also refill comfort
                            return True
                        return False
                
                    def is_lure_changeable(self):
                        """Check if it has been a long time since the last lure change.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_lure_change > self.cfg.SCRIPT.LURE_CHANGE_DELAY:
                            self.last_lure_change = cur_time
                            return True
                        return False
                
                    def is_spod_rod_castable(self):
                        """Check if it has been a long time since the last spod rod recast.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_spod_rod_recast > self.cfg.SCRIPT.SPOD_ROD_RECAST_DELAY:
                            self.last_spod_rod_recast = cur_time
                            return True
                        return False
                
                    def is_script_pausable(self):
                        """Check if it has been a long time since the last script pause.
                
                        :return: True if long enough, False otherwise.
                        :rtype: bool
                        """
                        cur_time = time.time()
                        if cur_time - self.last_pause > self.cfg.PAUSE.DELAY:
                            self.last_pause = cur_time
                            return True
                        return False
                
                    def plot_and_save(self) -> None:
                        """Plot and save an image using rhour and ghour lists from the timer object."""
                        logger.info("Plotting line chart")
                
                        cast_rhour_list, cast_ghour_list = self.get_cast_time_list()
                        _, ax = plt.subplots(nrows=1, ncols=2)
                        # _.canvas.manager.set_window_title('Record')
                        ax[0].set_ylabel("Fish")
                
                        last_rhour = cast_rhour_list[-1]  # Hour: 0, 1, 2, 3, 4, "5"
                        fish_per_rhour = [0] * (last_rhour + 1)  # Idx: (0, 1, 2, 3, 4, 5) = 6
                        for hour in cast_rhour_list:
                            fish_per_rhour[hour] += 1
                        ax[0].plot(range(last_rhour + 1), fish_per_rhour)
                        ax[0].set_title("Fish Caughted per Real Hour")
                        ax[0].set_xticks(range(last_rhour + 2))
                        ax[0].set_xlabel("Hour (real running time)")
                        ax[0].yaxis.set_major_locator(MaxNLocator(integer=True))
                
                        fish_per_ghour = [0] * 24
                        for hour in cast_ghour_list:
                            fish_per_ghour[hour] += 1
                        ax[1].bar(range(0, 24), fish_per_ghour)
                        ax[1].set_title("Fish Caughted per Game Hour")
                        ax[1].set_xticks(range(0, 24, 2))
                        ax[1].set_xlabel("Hour (game time)")
                        ax[1].yaxis.set_major_locator(MaxNLocator(integer=True))
                
                        # plt.tight_layout()
                        plt.savefig(str(ROOT / f"logs/{self.get_cur_timestamp()}.png"))
                        logger.info("Chart has been saved under logs/")
            üìÑ window.py
                """Module for window controller.
                
                This module provides functionality for managing and interacting with the game window
                and terminal window in Russian Fishing 4.
                
                .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
                """
                
                import logging
                import sys
                from pathlib import Path
                from time import sleep
                
                # import win32api, win32con
                import pyautogui as pag
                import win32con
                import win32gui
                
                sys.path.append(".")  # python -m module -> python file
                from rf4s import utils
                
                logger = logging.getLogger("rich")
                
                ANIMATION_DELAY = 0.25
                
                if utils.is_compiled():
                    ROOT = Path(sys.executable).parent  # Running as .exe (Nuitka/PyInstaller)
                else:
                    ROOT = Path(__file__).resolve().parents[2]
                
                
                class Window:
                    """Controller for terminal and game windows management.
                
                    This class handles window focus, size detection, and screenshot functionality
                    for the game and terminal windows.
                
                    Attributes:
                        game_title (str): Title of the game window.
                        terminal_hwnd (int): Handle of the terminal window.
                    """
                
                    def __init__(self, game_title: str = "Russian Fishing 4"):
                        """Set the hwnd of the terminal where user run the script.
                
                        We didn't retrieve the game window's hwnd here because we don't want to check
                        if the window is open right away. Instead, we perform the check after the
                        configuration is set.
                
                        :param game_title: Title of the game, defaults to "Russian Fishing 4".
                        :type game_title: str, optional
                        """
                        self.game_title = game_title
                        self.terminal_hwnd = win32gui.GetForegroundWindow()
                
                    def _get_game_hwnd(self) -> int:
                        """Get the handle of the game window.
                
                        :return: Process handle of the game window.
                        :rtype: int
                        """
                        hwnd = win32gui.FindWindow(None, self.game_title)  # class name: UnityWndClass
                        if hwnd == 0:
                            logger.critical("Failed to locate the game window: %s", self.game_title)
                            utils.safe_exit()
                        return hwnd
                
                    def is_title_bar_exist(self) -> bool:
                        """Check if the game window is in windowed mode.
                
                        :return: True if the game window has a title bar, False otherwise.
                        :rtype: bool
                        """
                        style = win32gui.GetWindowLong(self._get_game_hwnd(), win32con.GWL_STYLE)
                        return style & win32con.WS_CAPTION
                
                    def get_box(self) -> tuple[int, int, int, int]:
                        """Get the coordinates and dimensions of the game window.
                
                        :return: Tuple containing (x, y, width, height) of the game window.
                        :rtype: tuple[int, int, int, int]
                        """
                        # Absolute coordinates
                        base_x, base_y, _, _ = win32gui.GetWindowRect(self._get_game_hwnd())
                        if self.is_title_bar_exist():
                            base_x += 8
                            base_y += 31
                        # Relative coordinates
                        left, top, right, bottom = win32gui.GetClientRect(self._get_game_hwnd())
                        return base_x, base_y, right - left, bottom - top
                
                    def get_base_coordinates(self) -> tuple[int, int]:
                        """Get the base coordinates of the game window.
                
                        :return: Tuple containing (x, y) of the base coordinates.
                        :rtype: tuple[int, int]
                        """
                        return self.get_box()[:2]
                
                    def get_resolution_str(self) -> tuple[int, int]:
                        """Get the resolution of the game window.
                
                        :return: Tuple containing (width, height) of the game window.
                        :rtype: tuple[int, int]
                        """
                        width, height = self.get_box()[2:]
                        return f"{width}x{height}"
                
                    def activate_script_window(self) -> None:
                        """Focus the terminal where user run the script."""
                        pag.press("alt")
                        win32gui.SetForegroundWindow(self.terminal_hwnd)
                        sleep(ANIMATION_DELAY)
                
                    def activate_game_window(self) -> None:
                        """Focus game window."""
                        pag.press("alt")
                        win32gui.SetForegroundWindow(self._get_game_hwnd())
                        sleep(ANIMATION_DELAY)
                
                    def is_size_supported(self) -> bool:
                        """Check if the game window size is supported.
                
                        :return: True if it's supported, False otherwise.
                        :rtype: bool
                        """
                        return self.get_resolution_str() in (
                            "2560x1440",
                            "1920x1080",
                            "1600x900",
                        )
                
                    def save_screenshot(self, time) -> None:
                        """Save a screenshot of the game window to the screenshots directory.
                
                        :param time: Timestamp for the filename.
                        :type time: str
                        """
                        pag.screenshot(
                            imageFilename=ROOT / "screenshots" / f"{time}.png",
                            region=self.get_box(),
                        )
                
                
                if __name__ == "__main__":
                    w = Window("Russian Fishing 4")
                    # w.activate_game_window()
                    print(w.get_box())
                    print(w.get_base_coordinates())
                    print(w.get_resolution_str())
                    print(w.is_size_supported())
                
                # SetForegroundWindow bug reference :
                # https://stackoverflow.com/questions/56857560/win32gui-setforegroundwindowhandle-not-working-in-loop
            üìÑ __init__.py
                [EMPTY FILE]
            üìÅ __pycache__/
                üìÑ detection.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ notification.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ timer.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ window.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
                üìÑ __init__.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ result/
            üìÑ result.py
                from dataclasses import dataclass
                
                from rf4s.controller.timer import Timer
                
                
                @dataclass
                class Result:
                    """Dummy result."""
                
                    def as_dict(self) -> dict:
                        return {}
                
                
                @dataclass
                class RF4SResult:
                    tea: int = 0
                    carrot: int = 0
                    alcohol: int = 0
                    coffee: int = 0
                    bait: int = 0
                    kept: int = 0
                    total: int = 0
                    green: int = 0
                    yellow: int = 0
                    blue: int = 0
                    purple: int = 0
                    pink: int = 0
                
                    def as_dict(self, msg: str, timer: Timer) -> dict:
                        # Will be 0 if total_fish_count = 0
                        kept_ratio = f"{int(self.kept / max(1, self.total) * 100)}%"
                        bite_rate = f"{int((self.total / (timer.get_running_time() / 3600)))}/hr"
                
                        return {
                            "Stop reason": msg,
                            "Start time": timer.get_start_datetime(),
                            "End time": timer.get_cur_datetime(),
                            "Running time": timer.get_running_time_str(),
                            "Bite rate": bite_rate,
                            "Total fish": self.total,
                            "Kept fish": self.kept,
                            "Kept ratio": kept_ratio,
                            "Green tag fish": self.green,
                            "Yellow tag fish": self.yellow,
                            "Blue tag fish": self.blue,
                            "Purple tag fish": self.purple,
                            "Pink tag fish": self.pink,
                            "Tea consumed": self.tea,
                            "Carrot consumed": self.carrot,
                            "Alcohol consumed": self.alcohol,
                            "Coffee consumed": self.coffee,
                            "Bait harvested": self.bait,
                        }
                
                
                @dataclass
                class CraftResult:
                    succes: int = 0
                    fail: int = 0
                    material: int = 0
                
                    def as_dict(self) -> dict:
                        return {
                            "Successful crafts": self.succes,
                            "Failed crafts": self.fail,
                            "Materials used": self.material,
                        }
                
                
                @dataclass
                class HarvestResult:
                    tea: int = 0
                    carrot: int = 0
                    bait: int = 0
                
                    def as_dict(self) -> dict:
                        return {
                            "Tea consumed": self.tea,
                            "Carrot consumed": self.carrot,
                            "Bait harvested": self.bait,
                        }
            üìÅ __pycache__/
                üìÑ result.cpython-312.pyc
                    [ERROR: Unable to decode as UTF-8 or read file]
        üìÅ __pycache__/
            üìÑ exceptions.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ player.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ utils.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ __init__.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
    üìÅ screenshots/
    üìÅ static/
        üìÅ en/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ classic_feed_mix.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ dry_feed_mix.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ ok_black.png [IMAGE FILE]
            üìÑ ok_white.png [IMAGE FILE]
            üìÑ perch.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ pva_stick_or_pva_stringer.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ shorthorn_sculpin.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ readme/
            üìÑ clicklock.png [IMAGE FILE]
            üìÑ favorite_food.png [IMAGE FILE]
            üìÑ favorite_lure.png [IMAGE FILE]
            üìÑ icon.png [IMAGE FILE]
            üìÑ mtx1.png [IMAGE FILE]
            üìÑ mtx2.png [IMAGE FILE]
            üìÑ mtx3.png [IMAGE FILE]
            üìÑ path.png [IMAGE FILE]
            üìÑ RF4S.png [IMAGE FILE]
            üìÑ RF4S_original.png [IMAGE FILE]
            üìÑ status.png [IMAGE FILE]
        üìÅ ru/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ classic_feed_mix.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ dry_feed_mix.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ ok_black.png [IMAGE FILE]
            üìÑ ok_white.png [IMAGE FILE]
            üìÑ perch.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ pva_stick_or_pva_stringer.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ shorthorn_sculpin.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ sound/
            üìÑ app_1.wav [AUDIO FILE]
            üìÑ app_2.wav [AUDIO FILE]
            üìÑ app_3.wav [AUDIO FILE]
            üìÑ bell_1.wav [AUDIO FILE]
            üìÑ bell_2.wav [AUDIO FILE]
            üìÑ bell_3.wav [AUDIO FILE]
            üìÑ digital.wav [AUDIO FILE]
            üìÑ door_bell.wav [AUDIO FILE]
            üìÑ elevator.wav [AUDIO FILE]
            üìÑ fast_alarm.wav [AUDIO FILE]
            üìÑ flute_1.wav [AUDIO FILE]
            üìÑ flute_2.wav [AUDIO FILE]
            üìÑ guitar.wav [AUDIO FILE]
            üìÑ marimba.wav [AUDIO FILE]
            üìÑ ripple.wav [AUDIO FILE]
        üìÅ zh-CN/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
        üìÅ zh-TW/
            üìÑ 0m.png [IMAGE FILE]
            üìÑ 100wear.png [IMAGE FILE]
            üìÑ 5m.png [IMAGE FILE]
            üìÑ bait_icon.png [IMAGE FILE]
            üìÑ blue_tag.png [IMAGE FILE]
            üìÑ broke.png [IMAGE FILE]
            üìÑ carrot.png [IMAGE FILE]
            üìÑ coffee.png [IMAGE FILE]
            üìÑ comfort.png [IMAGE FILE]
            üìÑ confirm.png [IMAGE FILE]
            üìÑ disconnected.png [IMAGE FILE]
            üìÑ energy.png [IMAGE FILE]
            üìÑ exit.png [IMAGE FILE]
            üìÑ favorite.png [IMAGE FILE]
            üìÑ fish_icon.png [IMAGE FILE]
            üìÑ food.png [IMAGE FILE]
            üìÑ gift.png [IMAGE FILE]
            üìÑ green_tag.png [IMAGE FILE]
            üìÑ groundbait_icon.png [IMAGE FILE]
            üìÑ harvest_confirm.png [IMAGE FILE]
            üìÑ herring.png [IMAGE FILE]
            üìÑ keep.png [IMAGE FILE]
            üìÑ lure_is_broken.png [IMAGE FILE]
            üìÑ mackerel.png [IMAGE FILE]
            üìÑ make.png [IMAGE FILE]
            üìÑ material_slot.png [IMAGE FILE]
            üìÑ movement.png [IMAGE FILE]
            üìÑ mussel.png [IMAGE FILE]
            üìÑ ok.png [IMAGE FILE]
            üìÑ pink_tag.png [IMAGE FILE]
            üìÑ purple_tag.png [IMAGE FILE]
            üìÑ pva_icon.png [IMAGE FILE]
            üìÑ quit.png [IMAGE FILE]
            üìÑ ready.png [IMAGE FILE]
            üìÑ saithe.png [IMAGE FILE]
            üìÑ scallop.png [IMAGE FILE]
            üìÑ scrollbar.png [IMAGE FILE]
            üìÑ squid.png [IMAGE FILE]
            üìÑ tea.png [IMAGE FILE]
            üìÑ ticket.png [IMAGE FILE]
            üìÑ ticket_1.png [IMAGE FILE]
            üìÑ ticket_2.png [IMAGE FILE]
            üìÑ ticket_3.png [IMAGE FILE]
            üìÑ ticket_5.png [IMAGE FILE]
            üìÑ warning.png [IMAGE FILE]
            üìÑ welcome.png [IMAGE FILE]
            üìÑ wheel.png [IMAGE FILE]
            üìÑ yellow_tag.png [IMAGE FILE]
            üìÑ yes.png [IMAGE FILE]
    üìÅ tools/
        üìÑ auto_friction_brake.py
            """Automate friction brake adjustments in Russian Fishing 4.
            
            This module provides functionality to automatically adjust the friction brake
            based on in-game conditions. It supports key bindings for exiting the script
            and resetting the friction brake.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from multiprocessing import Lock
            
            from pynput import keyboard
            from rich import print
            
            sys.path.append(".")
            from rf4s.app.app import ToolApp
            from rf4s.component.friction_brake import FrictionBrake
            from rf4s.config.config import print_cfg
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            logger = create_rich_logger()
            
            
            class FrictionBrakeApp(ToolApp):
                """Main application class for automating friction brake adjustments.
            
                This class manages the configuration, detection, and execution of the friction
                brake automation process. It also handles key bindings for exiting and resetting.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
                    friction_brake (FrictionBrake): Friction brake controller instance.
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    1. Check the game window state.
                    2. Format keybinds in cfg node.
                    3. Display cfg node.
                    4. Initialize a friction brake instance.
                    """
                    super().__init__()
                    if not self.is_game_window_valid():
                        safe_exit()
            
                    # Format keys
                    self.cfg.defrost()
                    self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
                    self.cfg.ARGS.RESET_KEY = f"'{self.cfg.ARGS.RESET_KEY}'"
                    self.cfg.freeze()
                    print_cfg(self.cfg.ARGS)
                    print_cfg(self.cfg.FRICTION_BRAKE)
            
                    self.friction_brake = FrictionBrake(self.cfg, Lock(), self.detection)
            
                def is_game_window_valid(self) -> bool:
                    """Check if the game window mode and size are valid.
            
                    :return: True if valid, False otherwise
                    :rtype: bool
                    """
                    if self.window.is_title_bar_exist():
                        logger.info("Window mode detected. Please don't move the game window")
                    if not self.window.is_size_supported():
                        logger.critical(
                            'Window mode must be "Borderless windowed" or "Window mode"'
                        )
                        logger.critical(
                            "Unsupported window size '%s', "
                            "use '2560x1440', '1920x1080' or '1600x900'",
                            self.window.get_resolution_str(),
                        )
                        return False
                    return True
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(description="Automate friction brake.")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-r",
                        "--reset-key",
                        default="g",
                        type=str,
                        help="key to reset friction brake, g by default",
                        metavar="KEY",
                    )
                    parser.add_argument(
                        "-q",
                        "--quit-key",
                        default="h",
                        type=str,
                        help="key to quit the script, h by default",
                        metavar="KEY",
                    )
                    return parser
            
                def _on_release(self, key: keyboard.KeyCode) -> None:
                    """Handle exit and quit events.
            
                    :param key: The key that was released.
                    :type key: keyboard.KeyCode
                    """
                    keystroke = str(key).lower()
                    if keystroke == self.cfg.ARGS.QUIT_KEY:
                        self.friction_brake.monitor_process.terminate()
                        sys.exit()
                    if keystroke == self.cfg.ARGS.RESET_KEY:
                        self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)
            
                def _start(self):
                    """Start the friction brake automation process.
            
                    Begins the friction brake monitoring process and starts a keyboard listener
                    to handle control keys.
                    """
                    print(
                        f"Press {self.cfg.ARGS.RESET_KEY[1:-1]} to reset friction brake, "
                        f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
                    )
                    self.friction_brake.monitor_process.start()
                    with keyboard.Listener(on_release=self._on_release) as listener:
                        listener.join()
            
            
            def run_app_from_main():
                try:
                    FrictionBrakeApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    FrictionBrakeApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ calculate.py
            """Calculate the maximum friction brake you can use on your tackle.
            
            This module provides functionality to calculate the maximum friction brake and tension
            based on the reel's max drag, friction brake wear, leader's load capacity, and wear.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import sys
            
            from rich import print
            from rich.prompt import Prompt
            from rich.table import Table
            
            sys.path.append(".")
            from rf4s import utils
            
            BIAS = 1e-6
            
            
            def get_tackle_stats():
                """Get actual stats of reel and leader based on their wears.
            
                Prompts the user for input and calculates the true max drag and load capacity
                after accounting for wear.
            
                :return: A tuple containing the true max drag and true load capacity.
                :rtype: tuple[float, float]
                """
                prompts = (
                    "Reel's max drag (kg)",
                    "Reel's friction brake wear (%)",
                    "Leader's load capacity (kg)",
                    "Leader's wear (%)",
                )
            
                while True:
                    restart = False
                    stats = []
                    for prompt in prompts:
                        validated_input = get_validated_input(prompt)
                        if validated_input is None:
                            restart = True
                            break
                        stats.append(validated_input)
            
                    if restart:
                        continue
            
                    max_drag, friction_brake_wear, leader_load_capacity, leader_wear = stats
                    true_max_drag = max_drag * (100 - friction_brake_wear) / 100
                    true_load_capacity = leader_load_capacity * (100 - leader_wear) / 100
                    return true_max_drag, true_load_capacity
            
            
            def get_validated_input(prompt: str) -> float | None:
                """Get validated input from the user.
            
                Prompts the user for input and validates it. Supports quitting and restarting.
            
                :param prompt: The prompt message to display to the user.
                :type prompt: str
                :return: The validated input as a float, or None if the user chooses to restart.
                :rtype: float or None
                """
                while True:
                    user_input = Prompt.ask(prompt)
                    if user_input == "q":
                        print("Bye.")
                        sys.exit()
                    if user_input == "r":
                        return None
            
                    try:
                        return float(user_input)
                    except ValueError:
                        utils.print_error("Invalid input. Please enter a number.")
            
            
            def main():
                """Main function to run the friction brake calculation.
            
                Prompts the user for input, calculates the result, and displays them in a table.
                """
                print("Please enter your tackle's stats, type q to quit, r to restart:")
                while True:
                    max_drag, load_capacity = get_tackle_stats()
                    max_friction_brake = int(min(load_capacity * 30 / (max_drag + BIAS) - 1, 29))
                    max_tension = max_drag * max_friction_brake / 30
            
                    table = Table(
                        "Result",
                        title="Your tackle's real stats üé£",
                        show_header=False,
                        min_width=36,
                    )
                    table.add_row("Reel's true max drag", f"{max_drag:.2f} kg")
                    table.add_row("Leader's true load capacity", f"{load_capacity:.2f} kg")
                    table.add_row("Friction brake tension", f"{max_tension:.2f} kg")
                    table.add_row("Maximum friction brake to use", f"{max_friction_brake}")
                    print(table)
            
            
            def run_app_from_main():
                main()
            
            
            if __name__ == "__main__":
                main()
        üìÑ craft.py
            """Activate game window and start crafting things until running out of materials.
            
            This module automates the crafting process in Russian Fishing 4. It supports
            discarding crafted items, fast crafting mode, and a configurable crafting limit.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import random
            import sys
            from datetime import datetime
            from pathlib import Path
            from time import sleep
            
            import pyautogui as pag
            from pynput import keyboard
            
            sys.path.append(".")
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.result.result import CraftResult
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            CRAFT_DELAY = 4.0
            CRAFT_DELAY_3X = CRAFT_DELAY * 3
            LOOP_DELAY = 0.5
            LOOP_DELAY_3X = LOOP_DELAY * 3
            ROOT = Path(__file__).resolve().parents[1]
            
            logger = create_rich_logger()
            
            
            class CraftApp(ToolApp):
                """Main application class for automating crafting.
            
                This class manages the configuration, detection, and execution of the crafting
                process. It tracks the number of successful and failed crafts, as well as the
                total number of materials used.
                """
            
                def __init__(self):
                    """Initialize the application."""
                    super().__init__()
                    print_cfg(self.cfg.ARGS)
                    self.result = CraftResult()
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(description="Craft items automatically.")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-d",
                        "--discard",
                        action="store_true",
                        help="discard all the crafted items (for groundbaits)",
                    )
                    parser.add_argument(
                        "-f",
                        "--fast",
                        action="store_true",
                        help="disable delay randomization to speed up crafting",
                    )
                    parser.add_argument(
                        "-n",
                        "--craft-limit",
                        type=int,
                        default=-1,
                        help="number of items to craft, no limit by default",
                        metavar="LIMIT",
                    )
                    return parser
            
                def get_action_delays(self) -> tuple[float, float]:
                    """Get crafting and checking delays.
            
                    :return: Two delays in seconds
                    :rtype: tuple[float, float]
                    """
                    if self.cfg.ARGS.FAST:
                        return CRAFT_DELAY, LOOP_DELAY
                    return (
                        random.uniform(CRAFT_DELAY, CRAFT_DELAY_3X),
                        random.uniform(LOOP_DELAY, LOOP_DELAY_3X),
                    )
            
                def move_cursor_to_make_button(self) -> None:
                    """Move the cursor to the make button position.
            
                    This method uses the Detection class to find the position of the make button
                    and moves the cursor to that position.
                    """
                    make_button_position = self.detection.get_make_button_position()
                    if make_button_position is None:
                        logger.critical(
                            "Make button not found, please set the interface scale to "
                            "1x or move your mouse around"
                        )
                        self.window.activate_script_window()
                        safe_exit()
                    pag.moveTo(make_button_position)
            
                def craft_item(
                    self, craft_delay: float, accept_delay: float, accept_key: str
                ) -> None:
                    """Craft an item.
            
                    :param craft_delay: Delay in seconds before accepting the crafted item.
                    :type craft_delay: float
                    :param accept_delay: Delay in seconds after accepting the crafted item.
                    :type accept_delay: float
                    :param accept_key: Key to press after accepting the crafted item.
                    :type accept_key: str
                    """
                    logger.info("Crafting item")
                    pag.click()
                    sleep(craft_delay)
                    self.result.material += 1
                    while True:
                        if self.detection.is_operation_success():
                            logger.info("Crafting successed")
                            self.result.succes += 1
                            break
            
                        if self.detection.is_operation_failed():
                            logger.warning("Crafting failed")
                            self.result.fail += 1
                            break
                        sleep(LOOP_DELAY)
                    pag.press(accept_key)
                    sleep(accept_delay)
            
                def _start(self) -> None:
                    """Main loop for crafting items.
            
                    Executes the primary loop for crafting items until materials are exhausted or
                    the crafting limit is reached. Supports fast crafting mode and discarding items.
                    """
                    logger.warning("This might get you banned, use at your own risk")
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
                    random.seed(datetime.now().timestamp())
                    accept_key = "backspace" if self.cfg.ARGS.DISCARD else "space"
                    self.move_cursor_to_make_button()
                    while True:
                        if not self.detection.is_material_complete():
                            logger.critical("Running out of materials")
                            return
                        if self.result.succes == self.cfg.ARGS.CRAFT_LIMIT:
                            logger.info("Crafting limit reached")
                            return
                        self.craft_item(*self.get_action_delays(), accept_key)
            
            
            def run_app_from_main():
                try:
                    CraftApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    CraftApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ harvest.py
            """Script for automatic baits harvesting and hunger/comfort refill.
            
            This module provides functionality to automate the harvesting of baits and refilling
            of hunger and comfort in Russian Fishing 4. It includes options for power-saving
            mode and configurable check delays.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from pathlib import Path
            from time import sleep
            
            import pyautogui as pag
            from pynput import keyboard
            
            sys.path.append(".")
            
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.controller.timer import Timer
            from rf4s.result.result import HarvestResult
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            ROOT = Path(__file__).resolve().parents[1]
            DIG_DELAY = 5  # 4 + 1 s
            CHECK_DELAY = 0.5
            ANIMATION_DELAY = 0.5
            
            logger = create_rich_logger()
            
            
            class HarvestApp(ToolApp):
                """Main application class for automating bait harvesting and hunger/comfort refill.
            
                This class manages the configuration, detection, and execution of the harvesting
                and refill processes. It also handles power-saving mode and check delays.
            
                Attributes:
                    timer (Timer): Timer instance for managing cooldowns.
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    Loads configuration, parses command-line arguments, and sets up the game window,
                    detection, and timer instances.
                    """
                    super().__init__()
                    print_cfg(self.cfg.ARGS)
            
                    self.timer = Timer(self.cfg)
                    self.result = HarvestResult()
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(
                        description="Harvest baits and refill hunger/comfort automatically.",
                    )
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-r",
                        "--refill",
                        action="store_true",
                        help="refill hunger and comfort by consuming tea and carrot",
                    )
                    parser.add_argument(
                        "-s",
                        "--power-saving",
                        action="store_true",
                        help="open control panel between checks to reduce power consumption",
                    )
                    parser.add_argument(
                        "-n",
                        "--check-delay",
                        type=int,
                        default=32,
                        help="delay time between each checks, 32s by default",
                    )
                    return parser
            
                def harvest_baits(self) -> None:
                    """Harvest baits using shovel/spoon.
            
                    The digging tool should be pulled out before calling this method. Waits for
                    harvest success and presses the spacebar to complete the process.
                    """
                    logger.info("Harvesting baits")
                    pag.click()
                    sleep(DIG_DELAY)
                    while not self.detection.is_harvest_success():
                        sleep(CHECK_DELAY)
                    pag.press("space")
                    logger.info("Baits harvested succussfully")
                    sleep(ANIMATION_DELAY)
            
                def refill_player_stats(self) -> None:
                    """Refill player stats using tea and carrot."""
                    if not self.cfg.ARGS.REFILL:
                        return
            
                    logger.info("Refilling player stats")
                    # Comfort is affected by weather, add a check to avoid over drink
                    if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
                        self._use_item("tea")
                        self.result.tea += 1
            
                    if self.detection.is_hunger_low():
                        self._use_item("carrot")
                        self.result.carrot += 1
            
                def _use_item(self, item: str) -> None:
                    """Access an item by name using quick selection shortcut or menu.
            
                    :param item: The name of the item to access.
                    :type item: str
                    """
                    logger.info("Using item: %s", item)
                    key = str(self.cfg.KEY[item.upper()])
                    if key != "-1":  # Use shortcut
                        pag.press(key)
                    else:  # Open food menu
                        with pag.hold("t"):
                            sleep(ANIMATION_DELAY)
                            food_position = self.detection.get_food_position(item)
                            pag.moveTo(food_position)
                            pag.click()
                    sleep(ANIMATION_DELAY)
            
                def _start(self) -> None:
                    """Main loop for eating and harvesting.
            
                    Executes the primary loop for checking hunger/comfort levels, consuming food,
                    and harvesting baits. Supports power-saving mode and configurable check delays.
                    """
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
            
                    pag.press(str(self.cfg.KEY.DIGGING_TOOL))
                    sleep(3)
                    while True:
                        self.refill_player_stats()
                        if self.detection.is_energy_high():
                            self.harvest_baits()
                            self.result.bait += 1
                        else:
                            logger.info("Energy is not high enough")
            
                        if self.cfg.ARGS.POWER_SAVING:
                            pag.press("esc")
                            sleep(self.cfg.ARGS.CHECK_DELAY)
                            pag.press("esc")
                        else:
                            sleep(self.cfg.ARGS.CHECK_DELAY)
                        sleep(ANIMATION_DELAY)
            
            
            def run_app_from_main():
                try:
                    HarvestApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    HarvestApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÑ main.py
            """Main CLI for Russian Fishing 4 Script.
            
            This module provides the command-line interface and main execution logic
            for automating fishing in Russian Fishing 4. It handles configuration,
            argument parsing, window management, and fishing automation.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import shlex
            import smtplib
            import sys
            from argparse import ArgumentParser, Namespace
            from pathlib import Path
            from socket import gaierror
            
            from pynput import keyboard
            from rich import box, print
            from rich.panel import Panel
            from rich.style import Style
            from rich.table import Column, Table
            from yacs.config import CfgNode as CN
            
            sys.path.append(".")  # python -m module -> python file
            import auto_friction_brake
            import calculate
            import craft
            import harvest
            import move
            
            from rf4s import utils
            from rf4s.app.app import App
            from rf4s.config import config
            from rf4s.player import Player
            from rf4s.utils import create_rich_logger
            
            logger = create_rich_logger()
            
            ARGUMENTS = (
                ("R", "rainbow", "rainbow line meter for retrieval detection"),
                ("t", "tag", "keep only tagged fishes"),
                ("c", "coffee", "drink coffee if stamina is low during a fish fight"),
                ("a", "alcohol", "drink alcohol before keeping the fish"),
                ("r", "refill", "consume tea and carrot if hunger or comfort is low"),
                ("H", "harvest", "harvest baits before casting the rod"),
                ("L", "lure", "change current lure with a random one, mode: spin"),
                ("m", "mouse", "move mouse randomly before casting the rod"),
                ("P", "pause", "pause the script before casting the rod occasionally"),
                ("RC", "random-cast", "do a redundant rod cast randomly"),
                ("SC", "skip-cast", "skip the first rod cast"),
                ("l", "lift", "lift the tackle constantly during a fish fight"),
                ("e", "electro", "enable electric mode for Electro Raptor series reel"),
                ("FB", "friction-brake", "adjust friction brake automatically"),
                ("GR", "gear-ratio", "switch the gear ratio after the retrieval timed out"),
                ("b", "bite", "save a screenshot in screenshots/ before rod cast (for bite spot)"),
                ("s", "screenshot", "save a screenshot in screenshots/ after you caught a fish"),
                ("d", "data", "save fishing data in /logs"),
                ("E", "email", "send email noticication after the script stop"),
                ("M", "miaotixing", "send miaotixing notification after the script stop"),
                ("D", "discord", "send Discord notification after the script stop"),
                ("S", "shutdown", "shutdown computer after the script stop"),
                ("SO", "signout", "sign out instead of closing the game"),
                ("SR", "spod-rod", "recast spod rod"),
                ("DM", "dry-mix", "enable dry mix refill, mode: bottom"),
                ("GB", "groundbait", "enable groundbait refill, mode: bottom"),
                ("PVA", "pva", "enable pva refill, mode: bottom"),
            )
            
            LOGO = """
            ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
            ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
            ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë          ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
            ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù          ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"""
            GITHUB_LINK = "GitHub: https://github.com/dereklee0310/RussianFishing4Script"
            DISCORD_LINK = "Discord: https://discord.gg/BZQWQnAMbY"
            # https://patorjk.com/software/taag/#p=testall&f=3D-ASCII&t=RF4S%0A, ANSI Shadow
            
            ROOT = Path(__file__).resolve().parents[1]
            
            FEATURES = (
                "Fishing Bot",
                "Craft Items",
                "Harvest Baits",
                "Toggle Moving Forward",
                "Automate Friction Brake",
                "Calculate tackle's stats",
            )
            
            
            class RF4SApp(App):
                """Main application class for Russian Fishing 4 automation.
            
                This class orchestrates the entire automation process, from parsing command-line
                arguments to configuring the environment and executing the fishing routine.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments
                    args (Namespace): Parsed command-line arguments
                    window (Window): Game window controller instance
                    player (Player): Player instance for fishing automation
                """
            
                def __init__(self):
                    """Initialize the application.
            
                    Loads configuration, parses command-line arguments, and sets up the environment.
                    """
                    super().__init__()
                    self.parser = self.create_parser()
                    # Parser will use the last occurence if the arguments are duplicated,
                    # so put argv at the end to overwrite launch options.
                    self.args = self.parser.parse_args(
                        shlex.split(self.cfg.SCRIPT.LAUNCH_OPTIONS) + sys.argv[1:]
                    )
                    if not self.is_args_valid(self.args):
                        utils.safe_exit()
                    self.cfg.merge_from_other_cfg(CN({"ARGS": config.dict_to_cfg(vars(self.args))}))
            
                def create_parser(self) -> ArgumentParser:
                    """Configure the argument parser with all supported command-line options.
            
                    :return: Configured ArgumentParser instance with all options and flags.
                    :rtype: ArgumentParser
                    """
                    parser = ArgumentParser(description="Start AFK script for Russian Fishing 4")
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
            
                    for argument in ARGUMENTS:
                        flag1 = f"-{argument[0]}"
                        flag2 = f"--{argument[1]}"
                        help_message = argument[2]
                        parser.add_argument(flag1, flag2, action="store_true", help=help_message)
            
                    profile_selection_strategy = parser.add_mutually_exclusive_group()
                    profile_selection_strategy.add_argument(
                        "-p",
                        "--pid",
                        type=int,
                        help="id of the profile you want to use",
                        metavar="PID",
                    )
                    profile_selection_strategy.add_argument(
                        "-N",
                        "--pname",
                        type=str,
                        help="name of the profile you want to use",
                        metavar="PROFILE_NAME",
                    )
                    parser.add_argument(
                        "-n",
                        "--fishes-in-keepnet",
                        default=0,
                        type=int,
                        help="number of fishes in your keepnet, 0 by default",
                        metavar="FISH_COUNT",
                    )
                    parser.add_argument(
                        "-BT",
                        "--boat-ticket",
                        nargs="?",
                        const=5,
                        type=int,
                        choices=[1, 2, 3, 5],
                        help=("renew boat ticket, DURATION: 1, 2, 3 or 5, 5 by default"),
                        metavar="DURATION",
                    )
                    parser.add_argument(
                        "-T",
                        "--trolling",
                        nargs="?",
                        const="forward",
                        type=str,
                        choices=["forward", "left", "right"],
                        help=(
                            "enable trolling mode, DIRECTION: 'forward', 'left', or 'right', "
                            "'forward' by default"
                        ),
                        metavar="DIRECTION",
                    )
                    parser.add_argument(
                        "-BL",
                        "--broken-lure",
                        nargs="?",
                        const="replace",
                        type=str,
                        choices=["replace", "alarm"],
                        help=(
                            "replace broken lure, ACTION: 'replace' or 'alarm', "
                            "'replace' by default"
                        ),
                        metavar="ACTION",
                    )
                    return parser
            
                def is_args_valid(self, args: Namespace) -> bool:
                    """Validate provided command-line arguments.
            
                    :param args: Parsed command-line arguments to validate.
                    :type args: Namespace
                    :return: Whether the arguments are valid.
                    :rtype: bool
                    """
                    if not 0 <= args.fishes_in_keepnet < self.cfg.KEEPNET.CAPACITY:
                        logger.critical(
                            "Invalid number of fishes in keepnet: '%s'", args.fishes_in_keepnet
                        )
                        return False
            
                    if args.pid is not None and not self.is_pid_valid(str(args.pid)):
                        logger.critical("Invalid profile id: '%s'", args.pid)
                        return False
            
                    if args.pname is not None and args.pname not in self.cfg.PROFILE:
                        logger.critical("Invalid profile name: '%s'", args.pname)
                        return False
            
                    # boat_ticket_duration already checked by choices[...]
                    return True
            
                def is_pid_valid(self, pid: str) -> bool:
                    """Check if the profile ID is valid.
            
                    :param pid: Profile ID to validate.
                    :type pid: str
                    :return: Whether the profile ID is valid.
                    :rtype: bool
                    """
                    return pid.isdigit() and 0 <= int(pid) < len(self.cfg.PROFILE)
            
                def is_smtp_valid(self) -> bool:
                    """Verify SMTP server connection for email notifications.
            
                    Tests the connection to the configured SMTP server using stored
                    credentials if email notifications are enabled.
            
                    :return: Whether the SMTP configuration is valid or not needed.
                    :rtype: bool
                    """
                    if not self.cfg.ARGS.EMAIL or not self.cfg.SCRIPT.SMTP_VERIFICATION:
                        return True
            
                    logger.info("Verifying SMTP connection")
            
                    email = self.cfg.NOTIFICATION.EMAIL
                    password = self.cfg.NOTIFICATION.PASSWORD
                    smtp_server_name = self.cfg.NOTIFICATION.SMTP_SERVER
            
                    try:
                        with smtplib.SMTP_SSL(smtp_server_name, 465) as smtp_server:
                            smtp_server.login(email, password)
                    except smtplib.SMTPAuthenticationError:
                        logger.critical(
                            "Email address or app password not accepted,\n"
                            "please check your email address and password.\n"
                            "For Gmail users, please refer to\n"
                            "https://support.google.com/accounts/answer/185833\n"
                        )
                        return False
                    except (TimeoutError, gaierror):
                        logger.critical("Invalid SMTP Server or connection timed out")
                        return False
                    return True
            
                def is_discord_webhook_url_valid(self) -> bool:
                    if not self.cfg.ARGS.DISCORD:
                        return True
                    if not self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL:
                        logger.critical(
                            "Discord Webhook url is not set, see\n"
                            "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks"
                        )
                        return False
                    return True
            
                def is_images_valid(self) -> bool:
                    """Verify that all required image files exist for the selected language.
            
                    Compares files in the reference 'en' directory with those in the current
                    language directory and reports any missing files.
            
                    :return: Whether all required image files are present.
                    :rtype: bool
                    """
                    if not self.cfg.SCRIPT.IMAGE_VERIFICATION:
                        return True
            
                    logger.info("Verifying image files")
                    if self.cfg.SCRIPT.LANGUAGE == "en":
                        return True
                    logger.warning(
                        "Language '%s' is not fully supported, consider using EN version",
                        self.cfg.SCRIPT.LANGUAGE,
                    )
                    image_dir = ROOT / "static" / self.cfg.SCRIPT.LANGUAGE
                    try:
                        current_images = [f.name for f in image_dir.iterdir() if f.is_file()]
                    except FileNotFoundError:
                        logger.critical("Invalid language: '%s'", self.cfg.SCRIPT.LANGUAGE)
                        return False
                    template_dir = ROOT / "static" / "en"
                    target_images = [f.name for f in template_dir.iterdir() if f.is_file()]
                    missing_images = set(target_images) - set(current_images)
                    if len(missing_images) > 0:
                        logger.critical("Some images are missing, please add them manually")
                        table = Table(
                            # "Filename",
                            Column("Filename", style=Style(color="red")),
                            title="Missing Images",
                            box=box.DOUBLE,
                            show_header=False,
                        )
                        for filename in missing_images:
                            table.add_row(f"static/{self.cfg.SCRIPT.LANGUAGE}/{filename}")
                        print(table)
                        return False
                    return True
            
                def is_profile_valid(self, profile_name: str) -> bool:
                    """Check if a profile configuration is valid and complete.
            
                    :param profile_name: Name of the profile to validate.
                    :type profile_name: str
                    :return: Whether the profile is valid.
                    :rtype: bool
                    """
                    if profile_name not in self.cfg.PROFILE:
                        logger.critical("Invalid profile name: '%s'", profile_name)
                        return False
            
                    mode = self.cfg.PROFILE[profile_name].MODE
                    if mode.upper() not in self.cfg.PROFILE:
                        logger.critical("Invalid mode: '%s'", mode)
                        return False
            
                    expected_keys = set(self.cfg.PROFILE[mode.upper()])
                    actual_keys = set(self.cfg.PROFILE[profile_name])
            
                    invalid_keys = actual_keys - expected_keys
                    missing_keys = expected_keys - actual_keys
            
                    if invalid_keys or missing_keys:
                        for key in invalid_keys:
                            logger.warning("Invalid setting: '%s'", key)
                        for key in missing_keys:
                            logger.warning("Missing setting: '%s'", key)
                    return True
            
                def display_profiles(self) -> None:
                    """Display a table of available profiles for user selection.
            
                    Shows a formatted table with profile IDs and names.
                    """
                    table = Table(
                        "Profiles",
                        title="Select a profile to start ‚öôÔ∏è",
                        show_header=False,
                        min_width=36,
                    )
                    for i, profile in enumerate(self.cfg.PROFILE):
                        table.add_row(f"{i:>2}. {profile}")
                    print(table)
            
                def get_pid(self) -> None:
                    """Prompt the user to enter a profile ID and validate the input.
            
                    Continuously prompts until a valid profile ID is entered or the
                    user chooses to quit.
                    """
                    print("Enter profile id to use, h to see help message, q to quit:")
            
                    while True:
                        user_input = input(">>> ")
                        if self.is_pid_valid(user_input):
                            break
                        if user_input == "q":
                            print("Bye.")
                            sys.exit()
                        if user_input == "h":
                            self.parser.print_help()
                            continue
                        utils.print_error("Invalid profile id, please try again.")
            
                    self.cfg.ARGS.PID = int(user_input)
            
                def create_user_profile(self) -> None:
                    """Configure the user profile based on arguments or interactive selection.
            
                    Selects a profile based on command-line arguments or user input,
                    validates the profile, and merges it with the configuration.
                    """
                    if self.cfg.ARGS.PNAME is not None:
                        profile_name = self.cfg.ARGS.PNAME
                    else:
                        if self.cfg.ARGS.PID is None:
                            self.display_profiles()
                            self.get_pid()
                        profile_name = list(self.cfg.PROFILE)[self.cfg.ARGS.PID]
            
                    if not self.is_profile_valid(profile_name):
                        utils.safe_exit()
            
                    # Merge args.opts here because we can only overwrite cfg.SELECTED
                    # after it's constructed using profile id or name.
                    # Process list-like values if possible
                    if "KEY.BOTTOM_RODS" in self.args.opts:
                        value_idx = self.args.opts.index("KEY.BOTTOM_RODS") + 1
                        self.args.opts[value_idx] = [
                            x.strip() for x in self.args.opts[value_idx].split(",")
                        ]
                    self.cfg.merge_from_list(self.args.opts)
            
                    mode = self.cfg.PROFILE[profile_name].MODE.upper()
                    self.cfg.SELECTED = CN({"NAME": profile_name}, new_allowed=True)
                    self.cfg.SELECTED.merge_from_other_cfg(self.cfg.PROFILE[mode])
                    self.cfg.SELECTED.merge_from_other_cfg(self.cfg.PROFILE[profile_name])
            
                    if (
                        hasattr(self.cfg.SELECTED, "LAUNCH_OPTIONS")
                        and self.cfg.SELECTED.LAUNCH_OPTIONS
                    ):  # Overwrite
                        args_list = shlex.split(self.cfg.SELECTED.LAUNCH_OPTIONS) + sys.argv[1:]
                        self.args = self.parser.parse_args(args_list)
                        self.cfg.ARGS = config.dict_to_cfg(vars(self.args))
            
                    # Check here because config might got overwritten
                    if (
                        not self.is_smtp_valid()
                        or not self.is_images_valid()
                        or not self.is_discord_webhook_url_valid()
                    ):
                        utils.safe_exit()
                    config.print_cfg(self.cfg.ARGS)
                    config.print_cfg(self.cfg.SELECTED)
            
                def is_window_valid(self) -> None:
                    """Set up and validate the game window.
            
                    Creates a Window object, checks if the window size is supported,
                    and disables incompatible features if needed.
                    """
                    if self.window.is_title_bar_exist():
                        logger.info("Window mode detected. Please don't move the game window")
                    if not self.window.is_size_supported():
                        logger.warning('Window mode must be "Borderless windowed" or "Window mode"')
                        logger.warning(
                            "Unsupported window size '%s', "
                            "use '2560x1440', '1920x1080' or '1600x900'",
                            self.window.get_resolution_str(),
                        )
                        logger.error(
                            "Snag detection will be disabled\n"
                            "Spooling detection will be disabled\n"
                            "Auto friction brake will be disabled\n"
                        )
            
                        self.cfg.ARGS.FRICTION_BRAKE = False
                        self.cfg.SCRIPT.SNAG_DETECTION = False
                        self.cfg.SCRIPT.SPOOLING_DETECTION = False
            
                    if (
                        self.cfg.SELECTED.MODE in ("telescopic", "bolognese")
                        and not self.window.is_size_supported()
                    ):
                        logger.critical(
                            "Fishing mode '%s' doesn't support window size '%s'",
                            self.cfg.SELECTED.MODE,
                            self.window.get_resolution_str(),
                        )
                        return False
                    return True
            
                def is_electro_valid(self):
                    """Display helpful information about the current configuration.
            
                    Checks configuration compatibility and prints warnings for
                    potential issues.
                    """
                    if not self.cfg.ARGS.ELECTRO:
                        return True
            
                    if self.cfg.SELECTED.MODE in ("pirk", "elevator"):
                        logger.info(
                            "Electric mode is enabled, make sure you're using Electro Raptor"
                        )
                    else:
                        logger.error(
                            "Electric mode is not compatible with mode '%s'"
                            "Electric mode will be disabled",
                            self.cfg.SELECTED.MODE,
                        )
                        self.cfg.ARGS.ELECTRO = False
                    return True
            
                def _start(self) -> None:
                    """Entry point."""
                    self.player = Player(self.cfg, self.window)
                    self.player.start_fishing()
            
                def start(self) -> None:
                    """Start the fishing automation process.
            
                    Sets up all required components, activates the game window,
                    registers key listeners, and begins the fishing automation.
                    Handles termination and displays result.
                    """
                    self.create_user_profile()
                    if not self.is_window_valid() or not self.is_electro_valid():
                        utils.safe_exit()
                    self.cfg.freeze()
            
                    if self.cfg.KEY.QUIT != "CTRL-C":
                        listener = keyboard.Listener(on_release=self._on_release)
                        listener.start()
                    print(f"Press {self.cfg.KEY.QUIT} to quit.")
                    self.window.activate_game_window()
                    try:
                        self._start()
                    except KeyboardInterrupt:
                        pass
            
                    self.display_result()
                    if self.cfg.ARGS.DATA:
                        self.player.timer.plot_and_save()
            
                def display_result(self):
                    print(
                        self.player.build_result_table(
                            self.player.build_result_dict("Terminated by user")
                        )
                    )
            
            
            def display_features() -> None:
                """Display a table of available features for user selection.
            
                Shows a formatted table with feature IDs and names.
                """
                table = Table(
                    "Features",
                    title="Select a feature to start üöÄ",
                    show_header=False,
                    min_width=36,
                )
            
                for i, feature in enumerate(FEATURES):
                    table.add_row(f"{i:>2}. {feature}")
                print(table)
            
            
            def get_pid() -> None:
                """Prompt the user to enter a profile ID and validate the input.
            
                Continuously prompts until a valid profile ID is entered or the
                user chooses to quit.
                """
                # print("Enter profile id to use, h to see help message, q to quit:")
                print("Enter feature id to use, q to quit:")
            
                while True:
                    user_input = input(">>> ")
                    if user_input.isdigit() and 0 <= int(user_input) < len(FEATURES):
                        break
                    if user_input == "q":
                        print("Bye.")
                        sys.exit()
                    utils.print_error("Invalid feature id, please try again.")
            
                return int(user_input)
            
            
            if __name__ == "__main__":
                print(Panel.fit(LOGO, box=box.HEAVY), GITHUB_LINK, DISCORD_LINK, sep="\n")
                utils.update_argv()
                display_features()
                match get_pid():
                    case 0:
                        try:
                            RF4SApp().start()
                        except Exception as e:
                            logger.critical(e, exc_info=True)
                        utils.safe_exit()
                    case 1:
                        craft.run_app_from_main()
                    case 2:
                        harvest.run_app_from_main()
                    case 3:
                        move.run_app_from_main()
                    case 4:
                        auto_friction_brake.run_app_from_main()
                    case 5:
                        calculate.run_app_from_main()
        üìÑ move.py
            """Movement automation for Russian Fishing 4 using keyboard controls.
            
            This module automates character movement in Russian Fishing 4 by simulating W key presses.
            Supports toggling movement state and includes optional Shift key integration for sprinting.
            
            .. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
            """
            
            import argparse
            import sys
            from pathlib import Path
            
            import pyautogui as pag
            from pynput import keyboard
            from rich import print
            
            sys.path.append(".")
            from rf4s import utils
            from rf4s.app.app import ToolApp
            from rf4s.config.config import print_cfg
            from rf4s.utils import create_rich_logger, safe_exit, update_argv
            
            ROOT = Path(__file__).resolve().parents[1]
            
            logger = create_rich_logger()
            
            
            class MoveApp(ToolApp):
                """Main controller for movement automation in Russian Fishing 4.
            
                Manages configuration, keyboard event listeners, and W/Shift key simulation.
            
                Attributes:
                    cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
                    w_key_pressed (bool): Tracks current state of W key simulation.
                """
            
                def __init__(self):
                    """Initialize configuration, CLI arguments, and game window.
            
                    1. Format keybinds in cfg node.
                    2. Create w key flag.
                    """
                    super().__init__()
            
                    # Format key
                    self.cfg.defrost()
                    self.cfg.ARGS.PAUSE_KEY = f"'{self.cfg.ARGS.PAUSE_KEY}'"
                    self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
                    self.cfg.freeze()
                    print_cfg(self.cfg.ARGS)
            
                    self.w_key_pressed = True
            
                def create_parser(self) -> argparse.ArgumentParser:
                    """Create an argument parser for the application.
            
                    :return: Configured argument parser.
                    :rtype: argparse.ArgumentParser
                    """
                    parser = argparse.ArgumentParser(
                        description="Moving the game character forward with W key."
                    )
                    parser.add_argument("opts", nargs="*", help="overwrite configuration")
                    parser.add_argument(
                        "-s", "--shift", action="store_true", help="Hold Shift key while moving"
                    )
                    parser.add_argument(
                        "-p",
                        "--pause-key",
                        default="w",
                        type=str,
                        help="key to pause the script, w by default",
                        metavar="KEY",
                    )
                    parser.add_argument(
                        "-q",
                        "--quit-key",
                        default="s",
                        type=str,
                        help="key to quit the script, s by default",
                        metavar="KEY",
                    )
                    return parser
            
                def _on_release(self, key: keyboard.KeyCode) -> None:
                    """Handle keyboard release events for script control.
            
                    :param key: Key released by the user.
                    :type key: keyboard.KeyCode
                    """
                    if str(key).lower() == self.cfg.ARGS.QUIT_KEY:
                        sys.exit()
                    elif str(key).lower() == self.cfg.ARGS.PAUSE_KEY:
                        if self.w_key_pressed:
                            self.w_key_pressed = False
                            return
                        pag.keyDown("w")
                        self.w_key_pressed = True
            
                @utils.release_keys_after(arrow_keys=True)
                def _start(self) -> None:
                    """Start W key automation and keyboard listener."""
                    print(
                        f"Press {self.cfg.ARGS.PAUSE_KEY[1:-1]} to pause, "
                        f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
                    )
                    if self.cfg.ARGS.SHIFT:
                        pag.keyDown("shift")
                    pag.keyDown("w")
                    # Blocking listener loop
                    with keyboard.Listener(on_release=self._on_release) as listener:
                        listener.join()
            
            
            def run_app_from_main():
                try:
                    MoveApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
            
            
            if __name__ == "__main__":
                update_argv()
                try:
                    MoveApp().start()
                except Exception as e:
                    logger.critical(e, exc_info=True)
                safe_exit()
        üìÅ __pycache__/
            üìÑ auto_friction_brake.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ calculate.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ craft.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ harvest.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]
            üìÑ move.cpython-312.pyc
                [ERROR: Unable to decode as UTF-8 or read file]