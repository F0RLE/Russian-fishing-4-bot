

# === all_content_Version3.py ===
import os

IMAGE_EXTENSIONS = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.webp', '.tiff'}
VIDEO_EXTENSIONS = {'.mp4', '.avi', '.mov', '.mkv', '.webm', '.flv', '.wmv'}
AUDIO_EXTENSIONS = {'.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a'}
CACHE_EXTENSIONS = {'.pyc'}
BINARY_EXTENSIONS = IMAGE_EXTENSIONS | VIDEO_EXTENSIONS | AUDIO_EXTENSIONS | {
    '.exe', '.dll', '.so', '.bin', '.dat', '.zip', '.rar', '.7z', '.tar', '.gz', '.pdf'
}

def remove_bom(text):
    if text.startswith('\ufeff'):
        return text[1:]
    return text

def safe_read_file(path, max_chars=5000):
    try:
        with open(path, encoding="utf-8", errors="replace") as f:
            content = f.read(max_chars)
            return remove_bom(content)
    except Exception as e:
        try:
            with open(path, encoding="latin1") as f:
                content = f.read(max_chars)
                return remove_bom(content)
        except Exception as e2:
            return f"<не удалось прочитать: {e2}>"

def file_type_note(name):
    ext = os.path.splitext(name)[1].lower()
    if ext in CACHE_EXTENSIONS:
        return "Это кэш Python (pyc-файл)"
    if ext in IMAGE_EXTENSIONS:
        return "Это картинка"
    if ext in VIDEO_EXTENSIONS:
        return "Это видео"
    if ext in AUDIO_EXTENSIONS:
        return "Это аудиофайл"
    if ext in BINARY_EXTENSIONS:
        return "Это бинарный файл"
    return None

def collect_all_content(start_path, out_path="all_content.txt", max_chars=5000):
    with open(out_path, "w", encoding="utf-8") as out:
        for root, dirs, files in os.walk(start_path):
            for name in files:
                file_path = os.path.join(root, name)
                rel_path = os.path.relpath(file_path, start_path)
                if rel_path == out_path:
                    continue  # не добавлять сам файл all_content.txt
                out.write(f"\n\n# === {rel_path} ===\n")
                note = file_type_note(name)
                if note:
                    out.write(note + "\n")
                else:
                    content = safe_read_file(file_path, max_chars)
                    out.write(content)
                    out.write("\n")
    print(f"Готово! Всё содержимое помещено в {out_path}")

if __name__ == "__main__":
    collect_all_content(".")


# === config.yaml ===
VERSION: "0.5.0"

SCRIPT:
  LANGUAGE: "en"
  LAUNCH_OPTIONS: ""
  SMTP_VERIFICATION: true
  IMAGE_VERIFICATION: true
  SNAG_DETECTION: true
  SPOOLING_DETECTION: true
  RANDOM_ROD_SELECTION: true
  SPOOL_CONFIDENCE: 0.98
  SPOD_ROD_RECAST_DELAY: 1800
  LURE_CHANGE_DELAY: 1800
  ALARM_SOUND: "./static/sound/guitar.wav"
  RANDOM_CAST_PROBABILITY: 0.25
  SCREENSHOT_TAGS:
    - "green"
    - "yellow"
    - "blue"
    - "purple"
    - "pink"

KEY:
  TEA: -1
  CARROT: -1
  BOTTOM_RODS: [1, 2, 3]
  COFFEE: 4
  DIGGING_TOOL: 5
  ALCOHOL: 6
  MAIN_ROD: 1
  SPOD_ROD: 7
  QUIT: "CTRL-C"

STAT:
  ENERGY_THRESHOLD: 0.74
  HUNGER_THRESHOLD: 0.5
  COMFORT_THRESHOLD: 0.51
  TEA_DELAY: 300
  COFFEE_LIMIT: 10
  COFFEE_PER_DRINK: 1
  ALCOHOL_DELAY: 900
  ALCOHOL_PER_DRINK: 1

FRICTION_BRAKE:
  INITIAL: 29
  MAX: 30
  START_DELAY: 2.0
  INCREASE_DELAY: 1.0
  SENSITIVITY: "medium"

KEEPNET:
  CAPACITY: 100
  FISH_DELAY: 0.0
  GIFT_DELAY: 4.0
  FULL_ACTION: "quit"
  WHITELIST:
    - "mackerel"
    - "saithe"
    - "herring"
    - "squid"
    - "scallop"
    - "mussel"
  BLACKLIST: []
  TAGS:
    - "green"
    - "yellow"
    - "blue"
    - "purple"
    - "pink"

NOTIFICATION:
  EMAIL: "email@example.com"
  PASSWORD: "password"
  SMTP_SERVER: "smtp.gmail.com"
  MIAO_CODE: "example"
  DISCORD_WEBHOOK_URL: ""

PAUSE:
  DELAY: 1800
  DURATION: 600

PROFILE:
  SPIN:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "normal"
  SPIN_WITH_PAUSE:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 1.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 3.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "pause"
  SPIN_WITH_LIFT:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 1.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "lift"
  BOTTOM:
    MODE: "bottom"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    POST_ACCELERATION: "off"
    CHECK_DELAY: 32.0
    CHECK_MISS_LIMIT: 16
    PUT_DOWN_DELAY: 0.0
  PIRK:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  PIRK_WITH_RETRIEVAL:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 0.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  WAKEY_RIG:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 45.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: true
    SHIFT: false
    PIRK_DURATION: 1.5
    PIRK_DELAY: 4.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR:
    MODE: "elevator"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR_WITH_DROP:
    MODE: "elevator"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  TELESCOPIC:
    MODE: "telescopic"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 16.0
    CAMERA_SHAPE: "square"
  BOLOGNESE:
    MODE: "bolognese"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 32.0
    CAMERA_SHAPE: "square"
    POST_ACCELERATION: "off"



# === LICENSE ===
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy,


# === README.md ===
**[[中文版]][readme]**
<div align="center">

![RF4S][rf4s_logo]
<h1 align="center">RF4S: Russian Fishing 4 Script</h1>

**A simple Russian Fishing 4 fishing bot, supporting spin, bottom, marine, and float fishing modes.**

<a target="_blank" href="https://opensource.org/license/gpl-3-0" style="background:none">
    <img src="https://img.shields.io/badge/License-GPLv3-blue.svg" style="height: 22px;" />
</a>
<a target="_blank" href="https://discord.gg/BZQWQnAMbY" style="background:none">
    <img src="https://img.shields.io/badge/discord-join-rf44.svg?labelColor=191937&color=6F6FF7&logo=discord" style="height: 22px;" />
</a>
<a target="_blank" href="http://makeapullrequest.com" style="background:none">
    <img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat" style="height: 22px;" />
</a>
<!-- <a target="_blank" href="https://github.com/pylint-dev/pylint" style="background:none">
    <img src="https://img.shields.io/badge/linting-pylint-yellowgreen" style="height: 22px;" />
</a> -->
<!-- <a target="_blank" href="https://github.com/psf/black" style="background:none">
    <img src="https://img.shields.io/badge/code%20style-black-000000.svg" style="height: 22px;" />
</a> -->
<!-- <a target="_blank" href="link_to_docs, tbd" style="background:none">
    <img src="https://img.shields.io/badge/docs-%23BE1B55" style="height: 22px;" />
</a> -->  

![Python badge][python_badge]
![Windows badge][windows_badge]

</div>

> [!TIP]
> Join the [Discord server][discord] if you want to suggest new features, report bugs or get help on how to use the script.


## Getting Started
### Prerequisites
Download and install **[Python 3.12.*][python]**.  

> [!IMPORTANT] 
> Ensure the **"Add Python to PATH"** option is selected during installation.  

> [!WARNING] 
> Python 3.13+ are not supported.
### Installation
See **[INSTALLATION][installation]**.
## Usage
### Before you start...
- Move your character to the fishing spot before running the script
- For Spin/Marine/Float/Wakey Rig Fishing: Pick up the rod you want to use.
- For Bottom Fishing:
    - Add tackles to quick selection slots.
    - Cast them and place them nearby so the bot can access them via shortcuts (1 ~ 3).
> [!NOTE]
> Currently, only bottom fishing mode support multiple rods.

### Let's Run it!
1. Open cmd/PowerShell
2. Navigate into the project directory and run the script with default configuration. Type `CTRL-C` to quit.
```
cd "path\to\the\project"
python tools\main.py
```
> [!TIP]
> `path\to\the\project` is the directory where you placed the files after cloning or extracting the project.  
> ![path]

> [!TIP]
> See **[CONFIGURATION][configuration]** for advanced usage and configuration options.

## Tools
### Craft items
Select materials before you run it, press `Ctrl-C` to quit.
```
python tools\craft.py
```
### Harvest baits
Press `Ctrl-C` to quit.
```
python tools\harvest.py
```
### Toggle moving forward
Press `W`to pause, `S` to quit.
```
python tools\move.py
```
### Automate friction brake
Press `G` to reset, `H` to quit.
```
python tools\auto_friction_brake.py
```
### Calculate tackle's stats and friction brake
```
python tools\calculate.py
```

## Troubleshooting
<details>
<summary>How to stop the script?</summary>

- Type `Ctrl-C` in your terminal. 
</details>
<!-- ------------------------------- divide -------------------------------- -->
<details>
<summary>Can't stop the script?</summary>

- Some keys might have been pressed down (e.g. `Ctrl`, `Shift`, `Mouse button`, etc.),  
  press them again to release it and type `Ctrl-C` as usual.
</details>
<!-- ------------------------------- divide -------------------------------- -->
<details>
<summary>Stuck at casting 128%?</summary>

- Check that the game language and script language settings are the same.
- Make sure your reel is fully loaded, or equip a rainbow line and use `-R` flag. 
</details>

<!-- ------------------------------- divide -------------------------------- -->
<details>
<summary>Didn't lift the rod after the retrieval is finished?</summary>

- Make sure your reel is fully loaded, or equip a rainbow line and use `-R` flag. 
- Change the game window size.
- Reduce the value of `SPOOL_CONFIDENCE` in `config.yaml`.
- Keep away from light sources or turn off the boat light.
</details>
<!-- ------------------------------- divide -------------------------------- -->
<details>
<summary>Script is running but nothing happen?</summary>

- Open cmd/Powershell as administrator and run it again.
</details>
<!-- ------------------------------- divide -------------------------------- -->

## Changelog
See **[CHANGELOG][changelog].**

## License
**[GNU General Public License version 3][license]**

## Contributing
Any contribution, bug report, or idea about new features is welcome.

## Contact me
dereklee0310@gmail.com 

[readme]: /docs/zh-TW/README.md
[rf4s_logo]: /static/readme/RF4S.png
[python_badge]: https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoCo


# === requirements.txt ===
pyautogui==0.9.54
keyboard==0.13.5
pywin32==306
pynput==1.7.6
opencv-python==4.8.0.76
Pillow==10.1.0
PyScreeze==0.1.29
python-dotenv==1.0.1
matplotlib==3.8.0
playsound==1.2.2 # downgrade to avoid bug
pyyaml==6.0.2
yacs==0.1.8
rich==13.9.4
bump-my-version==0.32.1
discord-webhook==1.4.1
# reference: https://stackoverflow.com/questions/68704443/python-playsound-error-261-for-command-the-driver-cannot-recognize-the-specifie



# === setup.bat ===
@echo off

echo This might take a while...

@REM for playsound module: https://github.com/TaylorSMarks/playsound/issues/145
python -m pip install wheel setuptools pip --upgrade
python -m pip install -r requirements.txt

if not exist ".\screenshots" mkdir screenshots
if not exist ".\logs" mkdir logs
if not exist ".\config.yaml" copy ".\rf4s\config\config.yaml" ".\config.yaml"


# === docs\en\CHANGELOG.md ===
**[[中文版]][CHANGELOG]**

## 0.5.0 (2025-06-06)

### 🆕 New Features
- **Discord Webhook Integration**: Added support for termination notifications via Discord webhooks. Set it with `NOTIFICATION.DISCORD_WEBHOOK_URL`.
- **Enhanced Tag Detection**: Added precise colored tag identification. Configure filtering with `KEEPNET.TAGS`.
- **Tag Filtering in Screenshots**: Integrated tag detection into screenshots. Use `SCRIPT.SCREENSHOT_TAGS` for filtering.
- **Profile-Specific Launch Options**: Profiles now support `LAUNCH_OPTIONS` that override global `SCRIPT.LAUNCH_OPTIONS`.
- **Bottom Mode Enhancement**: Added `PUT_DOWN_DELAY` to wait before checking other rods after hooking a fish.
- **Automated Gift Handling**: Automatically accepts gifts. Configure delay with `GIFT_DELAY`.
- **Random Rod Cast (`-RC`)**: Added flag for redundant casts. Adjust probability via `SCRIPT.RANDOM_CAST_PROBABILITY`.

### 🔧 Improvements
- **Result Table**: More detailed information has been added.
- **Stage Transitions**: Smoother reset/retrieve/pull sequences.
- **Gear Protection**: Decreases friction brake before quitting when using `-f` flag.
- **Configuration Fallback**: Gracefully defaults to built-in settings on missing configurations.

### 🐛 Bug Fixes
- Fixed PVA/groundbait refill issues across different rigs.
- Fixed missing material checks during crafting.
- Fixed crash caused by small `CHECK_DELAY` values.
- Fixed improper merging of `opts` into launch options.
- Resolved incompatibility between `-E` and `-g` flags.
- Fixed unexpected termination of `pirk` mode in edge cases.

### 🗃️ Deprecations & Renames
- `KEEPNET.DELAY` → `KEEPNET.FISH_DELAY`.
- `KEEPNET.RELEASE_WHITELIST` → `KEEPNET.WHITELIST`.
- Renamed launch options for clarity and consistency. Run `python tools\main.py -h` for details.

### 🧼 Maintenance
- Migrated code formatting/linting from Pylint/Black to Ruff.

## 0.4.2 (2025-04-07)
- Fixed a bug where the friction brake threshold was not being applied correctly.
- Fixed unexpected termination due to running out of fillet when using pirk/elevator mode.

## 0.4.1 (2025-03-30)
- Fixed a bug that left/right trolling mode doesn't work properly.
- Fixed an issue where electro mode doesn't work and compatible with `-g` flag.
- Fixed broken lure detection mechanism.
- Fixed a bug that pause is hard to trigger when using "toggle moving forward" tool.
- Added missing `POST_ACCELERATION` setting to `BOLOGNESE` mode.
- Tools now display config before running.
- Improved configuration guide.

## 0.4.0 (2025-03-16)
- Fixed a bug that the casting power level cannot be set to a value other than 1 or 5.
- Added `RETRIEVAL_TIMEOUT` to `SPIN` mode, allowing the script fall back to normal retrieval after retrieval with lift/pause timed out.

## 0.3.0 (2025-03-16)
- Reduced the sensitivity of lure break detection to avoid abnormal termination in the RU version.
- Added a new `KEEPNET.BLACKLIST` setting, blacklisted fish will always be released.
- Added a new `SHIFT` setting to `PIRK` mode, allowing users to hold shift while pirking.
- Increased check frequency for better user experience.
- Fixed a bug that the auto-friction-brake is not working properly.
- Updated READMEs.

## 0.2.1 (2025-03-08)
- Fixed a bug that auto-friction-brake, snag detection, and spooling detection are always disabled even the correct flags are used.

## 0.2.0 (2025-03-07)
- Fixed a bug that `-c` feature is not working properly.
- Added a `DEPTH_ADJUST_DURATION` setting to the `pirk` fishing mode to allow the user to set the duration of tightening the fishing line after opening the reel to adjust the depth of the lure.

## 0.1.0 (2025-03-06)
- New config system, bolognese mode, trolling mode, window mode support, and more.

[CHANGELOG]: /docs/zh-TW/CHANGELOG.md


# === docs\en\CONFIGURATION.md ===
**[[中文版]][configuration]**
## Using Launch Options
You can use launch options to enable one or more features at startup.
### Display Help Message
```
python tools\main.py -h
```
### Help Message
```
usage: main.py [-h] [-R] [-t] [-c] [-a] [-r] [-H] [-L] [-m] [-P] [-RC] [-SC] [-l] [-e] [-FB] [-GR] [-b] [-s] [-d] [-E]
               [-M] [-D] [-S] [-SO] [-SR] [-DM] [-GB] [-PVA] [-p PID | -N PROFILE_NAME] [-n FISH_COUNT]
               [-BT [DURATION]] [-T [DIRECTION]] [-BL [ACTION]]
               [opts ...]

Start AFK script for Russian Fishing 4

positional arguments:
  opts                  overwrite configuration

options:
  -h, --help            show this help message and exit
  -R, --rainbow         rainbow line meter for retrieval detection
  -t, --tag             keep only tagged fishes
  -c, --coffee          drink coffee if stamina is low during a fish fight
  -a, --alcohol         drink alcohol before keeping the fish
  -r, --refill          consume tea and carrot if hunger or comfort is low
  -H, --harvest         harvest baits before casting the rod
  -L, --lure            change current lure with a random one, mode: spin
  -m, --mouse           move mouse randomly before casting the rod
  -P, --pause           pause the script before casting the rod occasionally
  -RC, --random-cast    do a redundant rod cast randomly
  -SC, --skip-cast      skip the first rod cast
  -l, --lift            lift the tackle constantly during a fish fight
  -e, --electro         enable electric mode for Electro Raptor series reel
  -FB, --friction-brake
                        adjust friction brake automatically
  -GR, --gear-ratio     switch the gear ratio after the retrieval timed out
  -b, --bite            save a screenshot in screenshots/ before rod cast (for bite spot)
  -s, --screenshot      save a screenshot in screenshots/ after you caught a fish
  -d, --data            save fishing data in /logs
  -E, --email           send email noticication after the script stop
  -M, --miaotixing      send miaotixing notification after the script stop
  -D, --discord         send Discord notification after the script stop
  -S, --shutdown        shutdown computer after the script stop
  -SO, --signout        sign out instead of closing the game
  -SR, --spod-rod       recast spod rod
  -DM, --dry-mix        enable dry mix refill, mode: bottom
  -GB, --groundbait     enable groundbait refill, mode: bottom
  -PVA, --pva           enable pva refill, mode: bottom
  -p PID, --pid PID     id of the profile you want to use
  -N PROFILE_NAME, --pname PROFILE_NAME
                        name of the profile you want to use
  -n FISH_COUNT, --fishes-in-keepnet FISH_COUNT
                        number of fishes in your keepnet, 0 by default
  -BT [DURATION], --boat-ticket [DURATION]
                        renew boat ticket, DURATION: 1, 2, 3 or 5, 5 by default
  -T [DIRECTION], --trolling [DIRECTION]
                        enable trolling mode, DIRECTION: 'forward', 'left', or 'right', 'forward' by default
  -BL [ACTION], --broken-lure [ACTION]
                        replace broken lure, ACTION: 'replace' or 'alarm', 'replace' by default
```
> [!TIP]
> Other tools like `craft.py` or `move.py` also support `-h` for displaying help messages. 

> [!IMPORTANT]
> Add tea and carrot/coffee to your **[favorites][favorite_food]** if you want to use `-r` or `-c` options.  
> To use a option that replaces an item for you, you also need to add items to your **[favorites][favorite_lure]**.

### Examples
**Set the number of fishes in the keepnet to 32 (68 fishes to catch):**
```
python tools\main.py -n 32
```
**Select profile 3, drink the coffee while battling against fish, and send an email to yourself when it stops:**
```
python tools\main.py -p 3 --c --email
```
**Consume carrots, tea, and coffee to replenish player stats, and harvest baits before casting if possible.:**
```
python tools\main.py -rcH
```
**Recast spod rod regularly and refill dry mix if possible:**
```
python tools\main.py -o -dm
```


## Configuration
### Configure Settings
Edit your settings in `config.yaml`, changes will be applied when you run the script again.  
For details on each settings, see [configuration references](#configuration-references).

### Add a New Profile
If you want to add a custom profile for your use case, copy a existing profile from the default configuration file, edit it, and add it back to the `PROFILE` section.

Here we add a new profile called `YOUR_NEW_PROFILE`, it would pop up in the profile list when you run the script again:
```yaml
PROFILE:
  SPIN:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "normal"
            .
            .
            .
  YOUR_NEW_PROFILE:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 


# === docs\en\INSTALLATION.md ===
**[[中文版]][installation]**
### Approach 1: Clone via Git
```
git clone https://github.com/dereklee0310/RussianFishing4Script.git
cd RussianFishing4Script
.\setup.bat
```
> [!IMPORTANT] 
> Git must be installed on your system.
### Approach 2: Manual Download
1. [Download this repository][download].
2. Right-click `RussianFishing4Script-main.zip` and select "Extract here".
3. Open the extracted folder (`RussianFishing4Script-main`) and double-click `setup.bat` to install dependencies.
> [!TIP] 
> Create a virtual environment to avoid version conflicts if you already have Python installed.

> [!WARNING] 
> The download path cannot contain non-English characters.

## Environment Setup
### Enable Mouse ClickLock
- Go to Windows Mouse Settings > Enable **[Mouse ClickLock][clicklock]**.
- Set the time before locking to "Long".
### Language
- Confirm your game language matches the language setting in config.yaml (default is "en").
### Display
- Set both system and in-game interface scales to "1x".
- Use "window mode" or "borderless windowed" for the game window mode.
### Spool Detection
- By default, the bot checks the status of the spool (red box) for retrieval detection.  
  The spool must be filled with fishing line so the bot can decide whether the retriaval is finished.
- If you have rainbow line equiped, use `-R` option to detect meter instead (green box) for better accuracy. 
- Please refer to [configuration guide][configuration] to see how to use launch options.
  
![status]

[installation]: /docs/zh-TW/INSTALLATION.md
[download]: https://github.com/dereklee0310/RussianFishing4Script/archive/refs/heads/main.zip
[configuration]: /docs/en/CONFIGURATION.md
[clicklock]: /static/readme/clicklock.png
[status]: /static/readme/status.png


# === docs\zh-TW\CHANGELOG.md ===
**[[English version]][CHANGELOG]**

## 0.5.0 (2025-06-06)

### 🆕 新功能
- **Discord Webhook 整合**：新增腳本終止通知的 Discord Webhook 支持。使用 `NOTIFICATION.DISCORD_WEBHOOK_URL` 進行設定。
- **增強標籤檢測**：新增精確識別彩色標籤功能。通過 `KEEPNET.TAGS` 配置過濾條件。
- **截圖標籤過濾**：將標籤檢測整合至截圖功能。使用 `SCRIPT.SCREENSHOT_TAGS` 配置過濾條件。
- **設定檔專屬啟動參數**：設定檔新增 `LAUNCH_OPTIONS` 優先級覆蓋全域 `SCRIPT.LAUNCH_OPTIONS`。
- **底部模式優化**：新增 `PUT_DOWN_DELAY` 參數，在釣到魚後等待指定時間再檢查其他魚竿。
- **自動禮物處理**：新增自動接收禮物功能。通過 `GIFT_DELAY` 配置等待時間。
- **隨機拋竿 (`-RC`)**：新增冗餘拋竿指令。通過 `SCRIPT.RANDOM_CAST_PROBABILITY` 調整概率。

### 🔧 改進
- **結果表格**：新增更詳細的顯示資訊。
- **階段過渡**：重置／回收／提竿流程更流暢。
- **裝備保護**：使用 `-f` 參數退出時自動降低捲線器阻力。
- **設定回退**：遺失設定項時優雅回退至內建預設值。

### 🐛 錯誤修復
- 修復不同釣組下 PVA／誘餌補給異常問題。
- 修復製作物品時未檢測材料耗盡的問題。
- 修復小 `CHECK_DELAY` 值導致崩潰的問題。
- 修復 `opts` 參數未正確合併至啟動參數的問題。
- 解決 `-E` 和 `-g` 參數衝突問題。
- 修復 `pirk` 模式在極端情況下意外終止的問題。

### 🗃️ 棄用與重新命名
- `KEEPNET.DELAY` → `KEEPNET.FISH_DELAY`。
- `KEEPNET.RELEASE_WHITELIST` → `KEEPNET.WHITELIST`。
- 啟動參數名稱優化統一。執行 `python tools\main.py -h` 查看詳細變更。

### 🧼 維護
- 程式碼格式化／檢查工具從 Pylint／Black 遷移至 Ruff。

## 0.4.2 (2025-04-07)
- 修復摩擦制動閾值設定未正確生效的問題。
- 修正使用打狀態／電梯模式時，當魚餌耗盡導致腳本意外終止的問題。

## 0.4.1 (2025-03-30)
- 修復左／右拖釣模式無法正常運作的錯誤。
- 修復電輪模式無法運作及與 `-g` 相容性的問題。
- 修復損壞的誘餌偵測機制。
- 修復使用「切換前進」工具時暫停功能難以觸發的問題。
- 為 `BOLOGNESE` 模式新增遺漏的 `POST_ACCELERATION` 設定。
- 工具現在會在執行前顯示設定。
- 改進設定指南。

## 0.4.0 (2025-03-16)
- 修復了拋竿力度無法設定的問題。
- 為 `SPIN` 模式新增 `RETRIEVAL_TIMEOUT` 設定，讓腳本在打狀態超時後切換至正常收線模式。

## 0.3.0 (2025-03-16)
- 降低擬餌斷裂檢測的靈敏度，避免異常終止問題。
- 新增 `KEEPNET.BLACKLIST` 設定項，黑名單中的魚類將始終被放生。
- 為 `PIRK` 模式新增 `SHIFT` 設定，允許用戶在使用 pirking 時按住 shift 鍵操作。
- 提升檢測頻率以優化用戶體驗。
- 修復自動摩擦制動器無法正常運作的 bug。
- 更新 README 文件。

## 0.2.1 (2025-03-08)
- 修復了即使使用正確參數，自動摩擦制動／卡鉤檢測／捲線檢測仍被強制禁用的 bug。

## 0.2.0 (2025-03-07)
- 修復 `-c` 功能異常問題。
- 為 `pirk` 釣魚模式新增 `DEPTH_ADJUST_DURATION` 設定項，允許用戶設置開捲後收緊釣線調整誘餌深度的持續時間。

## 0.1.0 (2025-03-06)
- 全新配置系統，新增磯釣模式、拖釣模式、視窗模式支援等多項功能。

[CHANGELOG]: /docs/en/CHANGELOG.md


# === docs\zh-TW\CONFIGURATION.md ===
**[[English version]][configuration]**
## 使用啟動參數  
可通過啟動參數啟用一項或多項功能。  

### 顯示幫助信息  
```  
python tools\main.py -h  
```  

### 幫助信息說明  
```bash
usage: main.py [-h] [-R] [-t] [-c] [-a] [-r] [-H] [-L] [-m] [-P] [-RC] [-SC] [-l] [-e] [-FB] [-GR] [-b] [-s] [-d] [-E]
               [-M] [-D] [-S] [-SO] [-SR] [-DM] [-GB] [-PVA] [-p PID | -N PROFILE_NAME] [-n FISH_COUNT]
               [-BT [DURATION]] [-T [DIRECTION]] [-BL [ACTION]]
               [opts ...]

啟動《俄羅斯釣魚4》自動腳本

位置參數:
  opts                  覆寫配置文件參數

選項:
  -h, --help            顯示幫助訊息
  -R, --rainbow         使用彩虹線計量器偵測收線
  -t, --tag             僅保留已標記的魚
  -c, --coffee          體力不足時飲用咖啡恢復體力
  -a, --alcohol         在保存魚之前飲酒
  -r, --refill          當飢餓或舒適度過低時自動補充茶與胡蘿蔔
  -H, --harvest         拋竿前自動收餌
  -L, --lure            定期隨機更換擬餌（僅限路亞模式）
  -m, --mouse           拋竿前隨機移動滑鼠
  -P, --pause           偶爾暫停腳本運行
  -RC, --random-cast    隨機添加額外拋竿動作
  -SC, --skip-cast      跳過首次拋竿直接開始收線
  -l, --lift            遛魚時持續提竿以節省時間
  -e, --electro         為Electro Raptor系列捲線器啟用電動模式
  -FB, --friction-brake 啟用自動摩擦調整
  -GR, --gear-ratio     收線超時後切換齒輪比
  -b, --bite            拋竿前截圖保存至 screenshots/（可用於分析咬鉤點）
  -s, --screenshot      捕獲魚隻後自動截圖保存
  -d, --data            在/logs目錄保存釣魚數據
  -E, --email           腳本停止後發送郵件通知
  -M, --miaotixing      腳本停止後發送喵提醒通知
  -D, --discord         腳本停止後發送Discord通知
  -S, --shutdown        腳本結束後關閉電腦
  -SO, --signout        退出遊戲而非關機
  -SR, --spod-rod       定期重拋餌料竿（底釣模式）
  -DM, --dry-mix        補充乾混合餌（底釣模式）
  -GB, --groundbait     補充底餌（底釣模式）
  -PVA, --pva           補充PVA餌（底釣模式）
  -p PID, --pid PID     指定配置檔ID
  -N PROFILE_NAME, --pname PROFILE_NAME
                        指定配置檔名稱
  -n FISH_COUNT, --fishes-in-keepnet FISH_COUNT
                        魚護當前魚量（預設為0）
  -BT [DURATION], --boat-ticket [DURATION]
                        自動續費船票，時長：1, 2, 3或5小時（預設5小時）
  -T [DIRECTION], --trolling [DIRECTION]
                        啟用拖釣模式，方向：'forward','left','right'（預設按'j'前進）
  -BL [ACTION], --broken-lure [ACTION]
                        斷餌自動處理，操作：'replace'或'alarm'（預設更換）
``` 

> [!TIP]  
> 其他工具如`craft.py`或`move.py`也支持`-h`參數顯示幫助信息。

> [!IMPORTANT]
> 若需使用 `-r` 或 `-c` 參數，請將茶和胡蘿蔔/咖啡加入 **[收藏物品][favorite_food]**。  
> 需自動更換物品的功能，請將相關物品加入 **[收藏物品][favorite_lure]**。

### 使用示例  
**設置魚護當前魚量為32條（需捕獲68條）：**  
```  
python tools\main.py -n 32  
```  

**使用3號配置檔，遛魚時飲用咖啡，停止後發送郵件：**  
```  
python tools\main.py -p 3 --c --email  
```  

**自動補充體力/飢餓/舒適度，拋竿前收餌：**  
```  
python tools\main.py -rcH  
```  

**定期重拋餌料竿並補充乾混合餌：**  
```  
python tools\main.py -o -dm  
```  

## 配置文件  
### 修改設置  
編輯`config.yaml`後重新運行腳本即可生效。  
各項參數詳解參見[配置參數說明](#配置參數說明)。  

### 添加新配置檔  
1. 複製現有配置檔結構  
2. 修改參數後添加至`PROFILE`段落  

示例添加名為`YOUR_NEW_PROFILE`的路亞配置：  
```yaml  
PROFILE:  
  SPIN:   
    MODE: "spin"  
    CAST_POWER_LEVEL: 5.0  
    CAST_DELAY: 6.0  
    ...  
  
  YOUR_NEW_PROFILE:  
    MODE: "spin"  
    CAST_POWER_LEVEL: 5.0  
    CAST_DELAY: 4.0  # 縮短拋竿延遲  
    PRE_ACCELERATION: True  # 啟用預加速  
    ...  
```  

> [!IMPORTANT]  
> - 配置檔名稱需唯一  
> - 嚴格保持縮進格式  
> - `MODE`需為`spin`/`bottom`/`pirk`/`elevator`/`telescopic`/`bolognese`  

### 臨時覆寫配置  
無需修改文件，直接通過命令覆寫參數：  
```  
python tools\main.py SCRIPT.LANGUAGE "ru"  # 臨時設置腳本語言為俄語  
```  

### 雙竿拖釣模式  
組合底釣配置與`-T`參數實現：  
```  
python tools\main.py -T KEY.BOTTOM_RODS "1, 2"  # 指定使用1、2號快捷鍵位  
```  


## 配置參數說明  
```python  
"""YACS默認配置節點"""  

from yacs.config import CfgNode as CN  

_C = CN()  
_C.VERSION = "0.0.0"  

# --------------------------------- 通用設置 -------------------------------- #  
_C.SCRIPT = CN()  
_C.SCRIPT.LANGUAGE = "en" # 腳本語言: en/ru/zh-TW/zh-CN  
_C.SCRIPT.LAUNCH_OPTIONS = ""  # 默認啟動參數，如"-r -c -H"  
_C.SCRIPT.SMTP_VERIFICATION = True  # SMTP驗證  
_C.SCRIPT.IMAGE_VERIFICATION = True  # 圖像驗證  
_C.SCRIPT.SNAG_DETECTION = True  # 掛底檢測  
_C.SCRIPT.SPOOLING_DETECTION = True  # 線軸檢測  
_C.SCRIPT.RANDOM_ROD_SELECTION = True  # 底釣隨機選竿  
_C.SCRIPT.SPOOL_CONFIDENCE = 0.98  # 線軸檢測敏感度（值越低越敏感）  
_C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800  # 餌料竿重拋間隔（秒）  
_C.SCRIPT.LURE_CHANGE_DELAY = 1800  # 擬餌更換間隔（秒）  
_C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # 提示音文件路徑
_C.SCRIPT.RANDOM_CAST_PROBABILITY = 0.25 # 隨機拋竿失誤的機率
_C.SCRIPT.SCREENSHOT_TAGS = ( # 魚獲截圖的標記種類，列表為空的話所有的魚都會截圖
    "green",
    "yellow",
    "blue",
    "purple",
    "pink"
)

# --------------------------------- 快捷鍵設置 ------------------------------ #  
_C.KEY = CN()  
_C.KEY.TEA = -1  # 茶快捷鍵（-1使用快捷菜單）  
_C.KEY.CARROT = -1  # 胡蘿蔔快捷鍵  
_C.KEY.BOTTOM_RODS = (1, 2, 3)  # 底釣竿快捷鍵位  
_C.KEY.COFFEE = 4  # 咖啡快捷鍵  
_C.KEY.DIGGING_TOOL = 5  # 挖餌工具快捷鍵  
_C.KEY.ALCOHOL = 6  # 酒精飲品快捷鍵  
_C.KEY.MAIN_ROD = 1  # 主釣竿快捷鍵  
_C.KEY.SPOD_ROD = 7  # 餌料竿快捷鍵  
_C.KEY.QUIT = "CTRL-C"  # 退出快捷鍵  

# --------------------------------- 角色狀態 -------------------------------- #  
_C.STAT = CN()  
_C.STAT.ENERGY_THRESHOLD = 0.74  # 喝咖啡/收餌體力閾值  
_C.STAT.HUNGER_THRESHOLD = 0.5  # 食用胡蘿蔔飢餓閾值  
_C.STAT.COMFORT_THRESHOLD = 0.51  # 飲茶舒適度閾值  
_C.STAT.TEA_DELAY = 300  # 飲茶間隔（秒）  
_C.STAT.COFFEE_LIMIT = 10  # 單次遛魚最大咖啡飲用量  
_C.STAT.


# === docs\zh-TW\INSTALLATION.md ===
**[[English version]][installation]**

## 安裝步驟
### 方法一：透過 Git 克隆
```
git clone https://github.com/dereklee0310/RussianFishing4Script.git
cd RussianFishing4Script
.\setup.bat
```
> [!IMPORTANT]  
> 系統必須已安裝 Git。
### 方法二：手動下載
1. [下載此儲存庫][download]。
2. 對 `RussianFishing4Script-main.zip` 按右鍵並選擇「解壓縮到當前位置」。
3. 開啟解壓後的資料夾 (`RussianFishing4Script-main`)，雙擊 `setup.bat` 以安裝依賴項。
> [!TIP] 
> 若已安裝 Python 其他版本，建議創建虛擬環境以避免依賴衝突。

> [!WARNING]  
> 下載路徑不得包含非英文字元。

## 環境設定
### 啟用滑鼠點擊鎖定
- 前往 Windows 滑鼠設定 > 啟用 **[滑鼠點擊鎖定][clicklock]**。
- 將鎖定前的時間設為「長」。
### 語言設定
- 確認遊戲語言與 `config.yaml` 中的語言設定一致（預設為 "EN"）。
### 顯示設定
- 將系統和遊戲內的介面縮放比例均設為「1x」。
- 遊戲視窗模式請使用「視窗模式」或「無邊框視窗」。
### 線軸偵測
- 預設情況下，機器人會檢查線軸（紅色框）狀態以判斷收線是否完成。  
  線軸必須裝滿線，機器人才能判斷收線是否結束。
- 若裝備彩虹釣線，請使用 `-R` 選項改為偵測線的米數（綠色框）以獲得更佳準確度。
- 請參閱 [設定指南][configuration] 瞭解如何使用啟動選項。
  
![status]

[installation]: /docs/en/INSTALLATION.md
[download]: https://github.com/dereklee0310/RussianFishing4Script/archive/refs/heads/main.zip
[configuration]: /docs/zh-TW/CONFIGURATION.md
[clicklock]: /static/readme/clicklock.png
[status]: /static/readme/status.png


# === docs\zh-TW\README.md ===
**[[English version]][readme]**
<div align="center">

![rf4s_logo]
<h1 align="center">RF4S: 俄羅斯釣魚4腳本</h1>

**俄羅斯釣魚4的簡易釣魚機器人，支援路亞、水底、海釣及手竿等模式。**

<a target="_blank" href="https://opensource.org/license/gpl-3-0" style="background:none">
    <img src="https://img.shields.io/badge/License-GPLv3-blue.svg" style="height: 22px;" />
</a>
<a target="_blank" href="https://discord.gg/BZQWQnAMbY" style="background:none">
    <img src="https://img.shields.io/badge/discord-join-rf44.svg?labelColor=191937&color=6F6FF7&logo=discord" style="height: 22px;" />
</a>
<a target="_blank" href="http://makeapullrequest.com" style="background:none">
    <img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat" style="height: 22px;" />
</a>
<!-- <a target="_blank" href="https://github.com/pylint-dev/pylint" style="background:none">
    <img src="https://img.shields.io/badge/代碼檢查-pylint-yellowgreen" style="height: 22px;" />
</a>
<a target="_blank" href="https://github.com/psf/black" style="background:none">
    <img src="https://img.shields.io/badge/代碼風格-black-000000.svg" style="height: 22px;" />
</a> -->
<!-- <a target="_blank" href="link_to_docs, tbd" style="background:none">
    <img src="https://img.shields.io/badge/文件-%23BE1B55" style="height: 22px;" />
</a> -->  

![Python 標章][python_badge]
![Windows 標章][windows_badge]

</div>

> [!TIP]
> 若想建議新功能、回報錯誤或取得使用幫助，請加入 [Discord 伺服器discordDiscord]。


## 快速入門
### 必要條件
下載並安裝 **[Python 3.12.*][python]**。  

> [!IMPORTANT]  
> 安裝時請務必勾選 **「將Python加入PATH」** 選項。  

> [!WARNING]  
> 不支援 Python 3.13 及以上版本。
### 安裝步驟
請參閱 **[安裝指南][installation]**。
## 使用方式
### 開始前注意事項...
- 執行腳本前，請先將角色移動至釣點
- 路亞/海釣/手竿/維基模式：手持要使用的釣竿。
- 底釣模式：
    - 將釣組添加至快捷欄位。
    - 拋竿後將釣竿放置在附近，以便腳本可透過快捷鍵（1 ~ 3）操作。
> [!NOTE]
> 目前僅底釣模式支援多竿操作。

### 開始執行！
1. 開啟 cmd/PowerShell
2. 進入專案目錄並執行腳本（按 `CTRL-C` 退出）：
```
cd "專案目錄路徑"
python tools\main.py
```
> [!TIP]
> `專案目錄路徑` 是克隆或解壓縮專案後存放檔案的目錄。  
> ![路徑示意][path]

> [!TIP]
> 進階設定和使用方式請參閱 **[設定指南][configuration]**。

## 工具集
### 製作物品
執行前選取材料，按 `Ctrl-C` 退出。
```
python tools\craft.py
```
### 自動挖餌
按 `Ctrl-C` 退出。
```
python tools\harvest.py
```
### 自動前進
按 `W` 暫停，按 `S` 退出。
```
python tools\move.py
```
### 自動調整摩擦
按 `G` 重置，按 `H` 退出。
```
python tools\auto_friction_brake.py
```
### 計算釣組數值與摩擦
```
python tools\calculate.py
```

## 疑難排解
<details>
<summary>如何停止腳本？</summary>

- 在終端機中輸入 `CTRL-C`。 
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>無法停止腳本？</summary>

- 可能按鍵被卡住（如 `CTRL-C`、`SHIFT`、滑鼠按鍵等），  
  重新按壓卡住的按鍵後，再輸入 `CTRL-C`。
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>拋竿卡在128%？</summary>

- 確認遊戲語言與腳本語言設定一致。
- 確保線軸已纏滿釣線，或裝備彩虹線並使用 `-R` 參數。 
</details>

<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>收線完成後未抬竿？</summary>

- 確保線軸已纏滿釣線，或裝備彩虹線並使用 `-R` 參數。 
- 調整遊戲視窗大小。
- 降低 `config.yaml` 中的 `SPOOL_CONFIDENCE` 數值。
- 遠離光源或關閉船燈。
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>腳本執行但無反應？</summary>

- 以系統管理員身份開啟 cmd/Powershell 並重新執行。
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->

## 更新日誌
詳見 **[更新日誌][changelog]**。

## 授權條款
**[GNU General Public License version 3][license]**

## 貢獻指南
歡迎提交錯誤報告、功能建議或任何形式的貢獻。

## 聯絡作者
dereklee0310@gmail.com 

[readme]: /README.md

[rf4s_logo]: /static/readme/RF4S.png
[python_badge]: https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white
[windows_badge]: https://img.shields.io/badge/Windows-0078D6?style=for-the-badge&logo=windows&logoColor=white

[discord]: https://discord.gg/BZQWQnAMbY
[python]: https://www.python.org/downloads/
[installation]: /docs/zh-TW/INSTALLATION.md
[configuration]: /docs/zh-TW/CONFIGURATION.md
[changelog]: /docs/zh-TW/CHANGELOG.md
[path]: /static/readme/path.png
[license]: /LICENSE


# === rf4s\exceptions.py ===
"""
A module reserved for exception classes.
"""


class FishHookedError(Exception):
    """A fish is hooked during a wrong routine."""


class FishCapturedError(Exception):
    """A fish is captured during a wrong routine."""


class LineAtEndError(Exception):
    """Fishing line is at the end during retrieval."""


class LineSnaggedError(Exception):
    """Fishing line is snagged."""


class ItemNotFoundError(Exception):
    """Failed to find an available item for replacement."""


class LureBrokenError(Exception):
    """Lure is broken."""


class TackleBrokenError(Exception):
    """Tackle is broken."""


class DisconnectedError(Exception):
    """Disconnected from the game."""


class TicketExpiredError(Exception):
    """Ticket expired."""



# === rf4s\player.py ===
"""Module for Player class.

This module provides the main interface for automating fishing activities in a game.
It includes functionality for managing fishing loops, handling player stats, and
automating various fishing techniques.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import os
import random
import sys
from contextlib import contextmanager
from datetime import datetime
from multiprocessing import Lock

# from email.mime.image import MIMEImage
from pathlib import Path
from time import sleep

import pyautogui as pag
from playsound import playsound
from pynput import keyboard
from rich import box, print
from rich.table import Table

from rf4s import exceptions, utils
from rf4s.component.friction_brake import FrictionBrake
from rf4s.component.tackle import Tackle
from rf4s.controller.detection import Detection, TagColor
from rf4s.controller.notification import (
    DiscordColor,
    DiscordNotification,
    EmailNotification,
    MiaotixingNotification,
)
from rf4s.controller.timer import Timer
from rf4s.controller.window import Window
from rf4s.result.result import RF4SResult

logger = logging.getLogger("rich")
random.seed(datetime.now().timestamp())

PRE_RETRIEVAL_DURATION = 0.5
PULL_OUT_DELAY = 3
DIG_DELAY = 5
DIG_TIMEOUT = 32
ANIMATION_DELAY = 1
TICKET_EXPIRE_DELAY = 16
DISCONNECTED_DELAY = 8
WEAR_TEXT_UPDATE_DELAY = 2
PUT_DOWN_DELAY = 4

SCREENSHOT_DELAY = 2

TROLLING_KEY = "j"

FORWARD = "w"
LEFT_KEY = "a"
RIGHT_KEY = "d"


class Player:
    """Main interface of fishing loops and stages.

    This class manages the automation of fishing activities, including casting,
    retrieving, and handling fish. It also handles player stats, equipment, and
    various in-game mechanics.

    :param cfg: Configuration object containing settings for the fishing process.
    :type cfg: Config
    :param window: Window object for managing the game window.
    :type window: Window
    """

    def __init__(self, cfg, window: Window):
        """Initialize monitor, timer, and some trivial counters.

        :param cfg: Configuration object containing settings for the fishing process.
        :type cfg: Config
        :param window: Window object for managing the game window.
        :type window: Window
        """
        self.cfg = cfg
        self.window = window
        self.timer = Timer(cfg)
        self.detection = Detection(cfg, window)

        self.tackle_idx = 0
        if self.cfg.SELECTED.MODE == "bottom":
            self.num_tackle = len(self.cfg.KEY.BOTTOM_RODS)
        else:
            self.num_tackle = 1
        self.tackles = [
            Tackle(cfg, self.timer, self.detection) for _ in range(self.num_tackle)
        ]
        self.tackle = self.tackles[self.tackle_idx]

        self.friction_brake_lock = Lock()
        self.friction_brake = FrictionBrake(
            cfg, self.friction_brake_lock, self.detection
        )

        self.cur_coffee = 0
        self.have_new_lure = True
        self.have_new_groundbait = True
        self.have_new_dry_mix = True
        self.have_new_pva = True
        self.result = RF4SResult()

        self.clicklock_enabled = False

    def start_fishing(self) -> None:
        """Start the main fishing loop with the specified fishing strategy."""
        if self.cfg.ARGS.FRICTION_BRAKE:
            logger.info("Spawing new process, do not quit the script")
            self.friction_brake.monitor_process.start()

        if (
            self.cfg.SELECTED.MODE not in ("telescopic", "bottom")
            and not self.cfg.ARGS.SKIP_CAST
            and not self.detection.is_retrieval_finished()
        ):
            logger.critical(
                "The spool is not fully loaded, "
                "try moving your camera, "
                "changing your game window size or fishing line"
            )
            sys.exit(1)

        logger.info("Starting fishing mode: '%s'", self.cfg.SELECTED.MODE)
        self._start_trolling()
        getattr(self, f"start_{self.cfg.SELECTED.MODE}_mode")()

    # ---------------------------------------------------------------------------- #
    #                              main fishing loops                              #
    # ---------------------------------------------------------------------------- #
    def start_spin_mode(self) -> None:
        """Main spin fishing loop for 'spin' and 'spin_with_pause' modes."""
        skip_cast = self.cfg.ARGS.SKIP_CAST
        while True:
            if not skip_cast:
                self._refill_stats()
                self._harvest_baits(pickup=True)
                self.reset_tackle()
                self._change_tackle_lure()
                self._cast_tackle()
            skip_cast = False

            if self.cfg.SELECTED.TYPE != "normal":
                utils.hold_mouse_button(self.cfg.SELECTED.TIGHTEN_DURATION)
                getattr(self, f"retrieve_with_{self.cfg.SELECTED.TYPE}")()
            self.retrieve_line()

            if self.d


# === rf4s\utils.py ===
"""Helper functions for automation scripts.

This module provides utility functions for common tasks such as mouse control,
keyboard input, and result display. It also includes decorators for managing
key and mouse states during automation.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import sys
from time import sleep

import pyautogui as pag
from pyscreeze import Box
from rich.console import Console
from rich.logging import RichHandler
from rich.text import Text

# BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
BASE_DELAY = 1.2
LOOP_DELAY = 1

ANIMATION_DELAY = 1

logger = logging.getLogger("rich")

# ---------------------------------------------------------------------------- #
#                            common functionalities                            #
# ---------------------------------------------------------------------------- #


def hold_mouse_button(duration: float = 1, button: str = "left") -> None:
    """Hold left or right mouse button.

    :param duration: Hold time, defaults to 1.
    :type duration: float, optional
    :param button: Button to click, defaults to "left".
    :type button: str, optional
    """
    if duration == 0:
        return

    pag.mouseDown(button=button)
    sleep(duration)
    pag.mouseUp(button=button)
    if button == "left" and duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
        pag.click()


def hold_mouse_buttons(duration: float = 1) -> None:
    """Hold left and right mouse buttons simultaneously.

    :param duration: Hold time, defaults to 1.
    :type duration: float, optional
    """
    pag.mouseDown()
    pag.mouseDown(button="right")
    sleep(duration)
    pag.mouseUp()
    pag.mouseUp(button="right")
    if duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
        pag.click()


def sleep_and_decrease(num: int, delay: int) -> int:
    """Self-decrement with a delay.

    :param num: The variable to decrease.
    :type num: int
    :param delay: Sleep time.
    :type delay: int
    :return: Decreased num.
    :rtype: int
    """
    sleep(delay)
    return num - delay


def ask_for_confirmation(msg: str = "Ready to start") -> None:
    """Ask for confirmation of user settings if it's enabled.

    :param msg: Confirmation message, defaults to "Ready to start".
    :type msg: str
    """
    while True:
        ans = input(f"{msg}? [Y/n] ").strip().lower()
        if ans in ("y", ""):
            break
        if ans == "n":
            sys.exit()


def get_box_center(box: Box) -> tuple[int, int]:
    """Get the center coordinate (x, y) of the given box.

    # (x, y, w, h) -> (x, y), np.int64 -> int

    :param box: Box coordinates (x, y, w, h).
    :type box: Box
    :return: x and y coordinates of the center point.
    :rtype: tuple[int, int]
    """
    return int(box.left + box.width // 2), int(box.top + box.height // 2)


def create_rich_logger() -> RichHandler:
    """Create a default RichHandler for logging.

    :return: Logging handler from rich.
    :rtype: RichHandler
    """
    # Ignore %(name)s because it's too verbose
    # https://rich.readthedocs.io/en/latest/logging.html
    logging.basicConfig(
        level=logging.INFO,
        format="%(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        handlers=[RichHandler(rich_tracebacks=True)],
    )
    return logging.getLogger("rich")


# ---------------------------------------------------------------------------- #
#                                  decorators                                  #
# ---------------------------------------------------------------------------- #


# def toggle_clicklock(func):
#     """Toggle clicklock before and after calling the function."""

#     def wrapper(self, *args, **kwargs):
#         # ELECTRO must be enabled, always use electric mode if GEAR_RATIO is disabled
#         # otherwise, only use electric mode when it's the first time
#         if self.cfg.ARGS.ELECTRO and (
#             not self.cfg.ARGS.GEAR_RATIO or (not args or args[0])
#         ):
#             pag.click(clicks=2, interval=0.1)
#         else:
#             pag.mouseDown()
#         sleep(BASE_DELAY + LOOP_DELAY)
#         try:
#             func(self, *args, **kwargs)
#         finally:
#             if self.cfg.ARGS.ELECTRO:
#                 pag.click(clicks=2, interval=0.1)
#             else:
#                 pag.click()

#     return wrapper


def toggle_right_mouse_button(func):
    """Toggle right mouse button before and after calling the function."""

    def wrapper(*args, **kwargs):
        pag.mouseDown(button="right")
        try:
            func(*args, **kwargs)
        finally:
            pag.mouseUp(button="right")

    return wrapper


def press_before_and_after(key):
    def func_wrapper(func):
        def args_wrapper(*args, **kwargs):
            pag.press(key)
            sleep(ANIMATION_DELAY)
            try:
                func(*args, **kwargs)
            finally:
                pag.press(key)



# === rf4s\__init__.py ===



# === rf4s\app\app.py ===
"""Base application class for other tools.

Provides core functionality for:
- Configuration management
- Window control
- Result display

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import os
import signal
import sys
from abc import ABC, abstractmethod
from pathlib import Path

from pynput import keyboard
from rich import print
from rich.table import Table
from yacs.config import CfgNode as CN

from rf4s.config import config
from rf4s.controller.detection import Detection
from rf4s.controller.window import Window
from rf4s.result.result import Result

ROOT = Path(__file__).resolve().parents[2]


class App(ABC):
    """A base application class.

    Attributes:
        cfg (yacs.config.CfgNode): Default + user's configuration file
        window (Window): Window controller
    """

    def __init__(self):
        """Initialize a mutable cfg node for further modification."""
        self.cfg = config.setup_cfg()
        self.cfg.merge_from_file(ROOT / "config.yaml")
        self.window = Window()

    def _on_release(self, key: keyboard.KeyCode) -> None:
        """Monitor user's keystrokes and convert a key press to a CTRL_C_EVENT.

        :param key: The key that was released.
        :type key: keyboard.KeyCode

        Exits the application when the configured quit key is pressed.
        """
        # Trigger CTRL_C_EVENT, which will be caught in start() to simulate pressing
        # CTRL-C to terminate the script.
        if key == keyboard.KeyCode.from_char(self.cfg.KEY.QUIT):
            os.kill(os.getpid(), signal.CTRL_C_EVENT)
            sys.exit()

    @abstractmethod
    def _start(self):
        raise NotImplementedError("_start() must be implemented in subclass")

    @abstractmethod
    def start(self):
        raise NotImplementedError("start() must be implemented in subclass")

    @abstractmethod
    def create_parser(self):
        raise NotImplementedError("create_parser() must be implemented in subclass")

    @abstractmethod
    def display_result(self) -> None:
        raise NotImplementedError("display_result() must be implemented in subclass")


class ToolApp(App):
    """General application class for other tools.

    Attributes:
        detection (Detection): Detection controller
    """

    def __init__(self):
        """Set up an immutable cfg node for further modification.

        1. Parse command-line arguments and merge them with the existing cfg node.
        2. Create a Window instance and a Detection instance.
        3. Create an empty dictionary for result
        """
        super().__init__()
        args = self.create_parser().parse_args()
        args_cfg = CN({"ARGS": config.dict_to_cfg(vars(args))})
        self.cfg.merge_from_other_cfg(args_cfg)
        self.cfg.merge_from_list(args.opts)

        # Dummy node
        dummy = CN({"SELECTED": config.dict_to_cfg({"MODE": "spin"})})
        self.cfg.merge_from_other_cfg(dummy)
        self.cfg.freeze()

        self.detection = Detection(self.cfg, self.window)
        self.result = Result()  # This will be used in display_result()

    def display_result(self) -> None:
        """Display the running result in a table format."""
        result_dict = self.result.as_dict()
        if not result_dict:
            return

        table = Table("Result", title="Running Result", show_header=False)
        for name, value in self.result.as_dict().items():
            table.add_row(name, str(value))
        print(table)

    def start(self) -> None:
        """Wrapper method that handle window activation and result display."""
        if self.cfg.KEY.QUIT != "CTRL-C":
            listener = keyboard.Listener(on_release=self._on_release)
            listener.start()

        self.window.activate_game_window()
        try:
            self._start()
        except KeyboardInterrupt:
            pass
        self.display_result()
        self.window.activate_script_window()



# === rf4s\app\__pycache__\app.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\component\friction_brake.py ===
"""Module for friction brake related methods.

This module provides functionality for managing the friction brake in Russian Fishing 4,
including resetting, adjusting, and monitoring the friction brake.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
from multiprocessing import Process, Value
from time import sleep, time

import pyautogui as pag

from rf4s.controller.detection import Detection

MAX_FRICTION_BRAKE = 30
MIN_FRICTION_BRAKE = 0
UP = 1
DOWN = -1
FRICTION_BRAKE_MONITOR_DELAY = 2
LOOP_DELAY = 0.04

logger = logging.getLogger("rich")


class FrictionBrake:
    """Friction brake controller.

    This class handles the adjustment and monitoring of the friction brake during gameplay.

    Attributes:
        cfg (CfgNode): Configuration node for friction brake settings.
        detection (Detection): Detection instance for in-game state checks.
        cur (Value): Current value of the friction brake.
        lock (Lock): Lock for thread synchronization.
        monitor_process (Process): Process for monitoring the friction brake.
    """

    def __init__(self, cfg, lock, detection: Detection) -> None:
        """Initialize the FrictionBrake class with configuration, lock, and detection.

        :param cfg: Configuration node for friction brake settings.
        :type cfg: CfgNode
        :param lock: Lock for thread synchronization.
        :type lock: Lock
        :param detection: Detection instance for in-game state checks.
        :type detection: Detection
        """
        self.cfg = cfg
        self.lock = lock
        self.detection = detection
        self.cur = Value("i", cfg.FRICTION_BRAKE.INITIAL)
        self.monitor_process = Process(target=monitor_friction_brake, args=(self,))

    def reset(self, target: int) -> None:
        """Reset the friction brake to the target value.

        :param target: Target friction brake value.
        :type target: int
        """
        logger.info("Resetting friction brake")
        for _ in range(MAX_FRICTION_BRAKE):
            pag.scroll(UP)

        diff = MAX_FRICTION_BRAKE - target
        for _ in range(abs(diff)):
            pag.scroll(DOWN)
        self.cur.value = target

    def change(self, increase: bool) -> None:
        """Increase or decrease the friction brake.

        :param increase: Whether to increase the friction brake.
        :type increase: bool
        """
        if increase:
            if self.cur.value < self.cfg.FRICTION_BRAKE.MAX:
                pag.scroll(UP, _pause=False)
                self.cur.value = min(self.cur.value + 1, MAX_FRICTION_BRAKE)
        else:
            if self.cur.value > 0:
                pag.scroll(DOWN, _pause=False)
                self.cur.value = max(self.cur.value - 1, MIN_FRICTION_BRAKE)
        sleep(LOOP_DELAY)


def monitor_friction_brake(friction_brake: FrictionBrake) -> None:
    """Monitor friction brake bar and change it accordingly.

    This is used as the target function in multiprocess.Process and must be pickable,
    thus it must be declared as a global function instead of an instance method.

    :param friction_brake: Friction brake controller.
    :type friction_brake: FrictionBrake
    """
    logger.info("Monitoring friction brake")

    pre_time = time()
    fish_hooked = False

    try:
        while True:
            if not friction_brake.detection.is_fish_hooked_pixel():
                sleep(FRICTION_BRAKE_MONITOR_DELAY)
                fish_hooked = False
                continue
            if not fish_hooked:
                sleep(friction_brake.cfg.FRICTION_BRAKE.START_DELAY)
                fish_hooked = True
            with friction_brake.lock:
                if friction_brake.detection.is_friction_brake_high():
                    friction_brake.change(increase=False)
                if friction_brake.detection.is_reel_burning():
                    logger.info("Reel burning detected, decreasing friction brake")
                    friction_brake.change(increase=False)
                else:
                    cur_time = time()
                    if (
                        cur_time - pre_time
                        < friction_brake.cfg.FRICTION_BRAKE.INCREASE_DELAY
                    ):
                        continue
                    pre_time = cur_time
                    friction_brake.change(increase=True)
    except KeyboardInterrupt:
        pass



# === rf4s\component\tackle.py ===
"""Module for Tackle class and some decorators.

This module provides functionality for managing tackle-related actions in Russian Fishing 4,
such as casting, retrieving, and pulling fish. It also includes decorators for handling
common tasks like clicklock and key releases.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import random
from time import sleep
from typing import Literal

import pyautogui as pag
import win32api
import win32con
from pyscreeze import Box

from rf4s import exceptions, utils
from rf4s.controller.detection import Detection
from rf4s.controller.timer import Timer

logger = logging.getLogger("rich")

RESET_TIMEOUT = 16
CAST_SCALE = 0.4  # 25% / 0.4s

# BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
BASE_DELAY = 1.2
LOOP_DELAY = 1

ANIMATION_DELAY = 1

RETRIEVAL_TIMEOUT = 32
PULL_TIMEOUT = 16
RETRIEVAL_WITH_PAUSE_TIMEOUT = 128
LIFT_DURATION = 3
TELESCOPIC_RETRIEVAL_TIMEOUT = 8
LANDING_NET_DURATION = 6
LANDING_NET_DELAY = 0.5
SINK_DELAY = 2


OFFSET = 100
NUM_OF_MOVEMENT = 4


class Tackle:
    """Class for all tackle-dependent methods.

    This class handles actions related to the fishing tackle, such as casting,
    retrieving, and pulling fish. It also manages tackle resetting and gear ratio switching.

    Attributes:
        cfg (CfgNode): Configuration node for tackle settings.
        timer (Timer): Timer instance for timing actions.
        detection (Detection): Detection instance for in-game state checks.
        landing_net_out (bool): Whether the landing net is deployed.
        available (bool): Whether the tackle is available for use.
    """

    def __init__(self, cfg, timer: Timer, detection: Detection):
        """Initialize the Tackle class with configuration, timer, and detection.

        :param cfg: Configuration node for tackle settings.
        :type cfg: CfgNode
        :param timer: Timer instance for timing actions.
        :type timer: Timer
        :param detection: Detection instance for in-game state checks.
        :type detection: Detection
        """
        self.cfg = cfg
        self.timer = timer
        self.detection = detection
        self.landing_net_out = False  # For telescopic pull
        self.available = True

    @staticmethod
    def _check_status(func):
        def wrapper(self, *args, **kwargs):
            if not self.available:
                return
            try:
                func(self, *args)
            except Exception as e:
                raise e

        return wrapper

    def is_disconnected_or_ticketed_expired(self) -> None:
        """Check if the game disconnected or the boat ticket expired."""
        if self.detection.is_disconnected():
            raise exceptions.DisconnectedError
        if self.detection.is_ticket_expired():
            raise exceptions.TicketExpiredError

    @_check_status
    def reset(self) -> None:
        """Reset the tackle until ready and detect unexpected events.

        :raises exceptions.FishHookedError: A fish is hooked.
        :raises exceptions.FishCapturedError: A fish is captured.
        :raises exceptions.LineAtEndError: The line is at its end.
        :raises exceptions.LineSnaggedError: The line is snagged.
        :raises TimeoutError: The loop timed out.
        """
        logger.info("Resetting tackle")
        i = RESET_TIMEOUT
        while i > 0:
            if self.detection.is_tackle_ready():
                return
            if self.detection.is_fish_hooked():
                raise exceptions.FishHookedError
            if self.detection.is_fish_captured():
                raise exceptions.FishCapturedError
            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                raise exceptions.LineAtEndError
            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                raise exceptions.LineSnaggedError
            if self.detection.is_lure_broken():
                raise exceptions.LureBrokenError
            if self.detection.is_tackle_broken():
                raise exceptions.TackleBrokenError
            i = utils.sleep_and_decrease(i, LOOP_DELAY)

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    @_check_status
    def cast(self, lock: bool) -> None:
        """Cast the rod, then wait for the lure/bait to fly and sink.

        :param lock: Whether to lock the reel after casting.
        :type lock: bool
        """
        logger.info("Casting rod")
        if self.cfg.ARGS.MOUSE:
            self.move_mouse_randomly()
        match self.cfg.SELECTED.CAST_POWER_LEVEL:
            case 1:  # 0%
                pag.click()
            case 5:  # power cast
                with pag.hold("shift"):
                    utils.hold_mouse_button(1)
            case _:
                # -1 for backward compatibility
                duration = CAST_SCALE * (self.cfg.SELECTED.CAST_POWER_LEVEL - 1)
                utils.hold_mouse_but


# === rf4s\component\__pycache__\friction_brake.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\component\__pycache__\tackle.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\config.py ===
"""
Configuration module for managing and manipulating configuration settings.

This module provides utilities for setting up, converting, and printing
configuration nodes using the YACS library.
"""

from yacs.config import CfgNode as CN

from rf4s.config.defaults import get_cfg_defaults


def setup_cfg() -> CN:
    """
    Set up and return a default configuration node.

    This function initializes a default configuration node and allows new keys
    to be added to the configuration.

    :return: A cloned configuration node with default settings.
    :rtype: CN
    """
    cfg = get_cfg_defaults()
    cfg.set_new_allowed(True)
    return cfg.clone()


def dict_to_cfg(args: dict) -> CN:
    """
    Convert a dictionary to a configuration node.

    This function recursively converts a dictionary into a configuration node,
    allowing nested dictionaries to be converted into nested configuration nodes.

    :param args: Dictionary to be converted into a configuration node.
    :type args: dict
    :return: Configuration node created from the dictionary.
    :rtype: CN
    """
    cfg = CN()
    for k, v in args.items():
        k = k.upper()
        if isinstance(v, dict):
            cfg[k] = dict_to_cfg(v)
        else:
            cfg[k] = v
    return cfg


def print_cfg(cfg: CN, level: int = 0) -> None:
    """
    Print the configuration node in a readable format.

    This function recursively prints the configuration node, with indentation
    to represent nested levels.

    :param cfg: Configuration node to be printed.
    :type cfg: CN
    :param level: Current indentation level (used for recursion).
    :type level: int
    """
    cfg = dict(cfg)
    indent = "  " * level if level > 0 else ""
    for k, v in cfg.items():
        if isinstance(v, CN):
            print(f"{indent}{k}:")
            print_cfg(v, level + 1)
        else:
            print(f"{indent}{k}: {v}")


def to_list(profile: dict) -> list:
    """
    Convert a dictionary into a flat list of key-value pairs.

    This function flattens a dictionary into a list where keys and values
    are alternated.

    :param profile: Dictionary to be converted into a list.
    :type profile: dict
    :return: List containing alternating keys and values from the dictionary.
    :rtype: list
    """
    pairs = []
    for k, v in profile.items():
        pairs.extend([k, v])
    return pairs



# === rf4s\config\config.yaml ===
VERSION: "0.5.0"

SCRIPT:
  LANGUAGE: "en"
  LAUNCH_OPTIONS: ""
  SMTP_VERIFICATION: true
  IMAGE_VERIFICATION: true
  SNAG_DETECTION: true
  SPOOLING_DETECTION: true
  RANDOM_ROD_SELECTION: true
  SPOOL_CONFIDENCE: 0.98
  SPOD_ROD_RECAST_DELAY: 1800
  LURE_CHANGE_DELAY: 1800
  ALARM_SOUND: "./static/sound/guitar.wav"
  RANDOM_CAST_PROBABILITY: 0.25
  SCREENSHOT_TAGS:
    - "green"
    - "yellow"
    - "blue"
    - "purple"
    - "pink"

KEY:
  TEA: -1
  CARROT: -1
  BOTTOM_RODS: [1, 2, 3]
  COFFEE: 4
  DIGGING_TOOL: 5
  ALCOHOL: 6
  MAIN_ROD: 1
  SPOD_ROD: 7
  QUIT: "CTRL-C"

STAT:
  ENERGY_THRESHOLD: 0.74
  HUNGER_THRESHOLD: 0.5
  COMFORT_THRESHOLD: 0.51
  TEA_DELAY: 300
  COFFEE_LIMIT: 10
  COFFEE_PER_DRINK: 1
  ALCOHOL_DELAY: 900
  ALCOHOL_PER_DRINK: 1

FRICTION_BRAKE:
  INITIAL: 29
  MAX: 30
  START_DELAY: 2.0
  INCREASE_DELAY: 1.0
  SENSITIVITY: "medium"

KEEPNET:
  CAPACITY: 100
  FISH_DELAY: 0.0
  GIFT_DELAY: 4.0
  FULL_ACTION: "quit"
  WHITELIST:
    - "mackerel"
    - "saithe"
    - "herring"
    - "squid"
    - "scallop"
    - "mussel"
  BLACKLIST: []
  TAGS:
    - "green"
    - "yellow"
    - "blue"
    - "purple"
    - "pink"

NOTIFICATION:
  EMAIL: "email@example.com"
  PASSWORD: "password"
  SMTP_SERVER: "smtp.gmail.com"
  MIAO_CODE: "example"
  DISCORD_WEBHOOK_URL: ""

PAUSE:
  DELAY: 1800
  DURATION: 600

PROFILE:
  SPIN:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "normal"
  SPIN_WITH_PAUSE:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 1.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 3.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "pause"
  SPIN_WITH_LIFT:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 1.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "lift"
  BOTTOM:
    MODE: "bottom"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    POST_ACCELERATION: "off"
    CHECK_DELAY: 32.0
    CHECK_MISS_LIMIT: 16
    PUT_DOWN_DELAY: 0.0
  PIRK:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  PIRK_WITH_RETRIEVAL:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 0.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  WAKEY_RIG:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 45.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: true
    SHIFT: false
    PIRK_DURATION: 1.5
    PIRK_DELAY: 4.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR:
    MODE: "elevator"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR_WITH_DROP:
    MODE: "elevator"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  TELESCOPIC:
    MODE: "telescopic"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 16.0
    CAMERA_SHAPE: "square"
  BOLOGNESE:
    MODE: "bolognese"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 32.0
    CAMERA_SHAPE: "square"
    POST_ACCELERATION: "off"



# === rf4s\config\defaults.py ===
"""Default yacs config node."""

from yacs.config import CfgNode as CN

_C = CN()
_C.VERSION = "0.5.0"

# ---------------------------------------------------------------------------- #
#                                    General                                   #
# ---------------------------------------------------------------------------- #
_C.SCRIPT = CN()
_C.SCRIPT.LANGUAGE = "en"  # Language for the script. Options: en, ru, zh-TW, zh-CN
_C.SCRIPT.LAUNCH_OPTIONS = ""  # Default launch options for the script, e.g., -r -c -H
_C.SCRIPT.SMTP_VERIFICATION = True
_C.SCRIPT.IMAGE_VERIFICATION = True
_C.SCRIPT.SNAG_DETECTION = True
_C.SCRIPT.SPOOLING_DETECTION = True
_C.SCRIPT.RANDOM_ROD_SELECTION = True  # For bottom mode
# Confidence threshold for spooling detection (lower = more sensitive)
_C.SCRIPT.SPOOL_CONFIDENCE = 0.98
# Delay before recasting spod rod (in seconds)
# Use bottom mode and -o to enable it.
_C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800
# Delay before changing lure randomly (in seconds)
# Use spin mode and -L to enable it.
_C.SCRIPT.LURE_CHANGE_DELAY = 1800
_C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # Path to alarm sound file
# Probability to add a redundant rod cast (0.0 to 1.0)
_C.SCRIPT.RANDOM_CAST_PROBABILITY = 0.25
# When using -s flag, only take screenshot of the fishes with tags below
# If left empty, the script will take screenshot of every fish you caught
_C.SCRIPT.SCREENSHOT_TAGS = ("green", "yellow", "blue", "purple", "pink")

# ---------------------------------------------------------------------------- #
#                                  Key Binding                                 #
# ---------------------------------------------------------------------------- #
_C.KEY = CN()
_C.KEY.TEA = -1  # Key binding for tea. Set to -1 to use quick selection menu
_C.KEY.CARROT = -1  # Key binding for carrot. Set to -1 to use quick selection menu
_C.KEY.BOTTOM_RODS = (1, 2, 3)  # Key bindings for bottom rods
_C.KEY.COFFEE = 4  # Key binding for coffee. Set to -1 to use quick selection menu
_C.KEY.DIGGING_TOOL = 5  # Key binding for digging tool
_C.KEY.ALCOHOL = 6  # Key binding for alcohol
# Key binding for the main rod (used when harvesting baits with one rod)
_C.KEY.MAIN_ROD = 1
_C.KEY.SPOD_ROD = 7  # Key binding for the spod rod (used in bottom mode)
# Key binding to stop the script (default is Ctrl-C)
# If you want to use a special quitting shortcut, please refer to pynput's docs:
# https://pynput.readthedocs.io/en/latest/keyboard.html#pynput.keyboard.Key .
_C.KEY.QUIT = "CTRL-C"

# ---------------------------------------------------------------------------- #
#                                 Player Stats                                 #
# ---------------------------------------------------------------------------- #
_C.STAT = CN()
# Minimum energy level before drinking coffee/harvesting baits
_C.STAT.ENERGY_THRESHOLD = 0.74
_C.STAT.HUNGER_THRESHOLD = 0.5  # Minimum hunger level before consuming carrot
_C.STAT.COMFORT_THRESHOLD = 0.51  # Minimum comfort level before consuming tea
_C.STAT.TEA_DELAY = 300  # Delay between tea drinks (in seconds)
_C.STAT.COFFEE_LIMIT = 10  # Maximum coffee drinks per fish fight.
_C.STAT.COFFEE_PER_DRINK = 1  # Amount of coffee consumed per drink
_C.STAT.ALCOHOL_DELAY = 900  # Delay between alcohol drinks (in seconds)
_C.STAT.ALCOHOL_PER_DRINK = 1  # Amount of alcohol consumed per drink

# ---------------------------------------------------------------------------- #
#                   Friction Brake (Use -f flag to enable it)                  #
# ---------------------------------------------------------------------------- #
_C.FRICTION_BRAKE = CN()
_C.FRICTION_BRAKE.INITIAL = 29  # Initial friction brake value
_C.FRICTION_BRAKE.MAX = 30  # Maximum friction brake value
# Delay before starting to adjust friction brake after a fish is hooked
_C.FRICTION_BRAKE.START_DELAY = 2.0
_C.FRICTION_BRAKE.INCREASE_DELAY = 1.0  # Delay before increasing friction brake
_C.FRICTION_BRAKE.SENSITIVITY = "medium"  # Sensitivity of friction brake detection

# ---------------------------------------------------------------------------- #
#                                    Keepnet                                   #
# ---------------------------------------------------------------------------- #
_C.KEEPNET = CN()
_C.KEEPNET.CAPACITY = 100
_C.KEEPNET.FISH_DELAY = 0.0  # Delay before keeping the fish (for screenshots)
_C.KEEPNET.GIFT_DELAY = 4.0  # Delay before keeping the gift (for screenshots)
_C.KEEPNET.FULL_ACTION = "quit"  # Action when keepnet is full. Options: quit, alarm
# Whitelist for untagged fish releasing when using -t flag
# Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.WHITELIST = (
    "mackerel",
    "saithe",
    "herring",
    "squid",
    "scallop",
    "mussel",
)
# Fish in the blacklist will always be released
# Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.K


# === rf4s\config\__init__.py ===



# === rf4s\config\__pycache__\config.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\__pycache__\defaults.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\__pycache__\__init__.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\detection.py ===
"""Module for pyautogui.locateOnScreen and pag.pixel wrappers.

This module provides functionality for detecting in-game elements using image recognition
and pixel color analysis. It is used for automating tasks in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import time
from enum import Enum
from functools import partial
from pathlib import Path
from typing import Generator

import cv2
import numpy as np
import pyautogui as pag
from PIL import Image
from pyscreeze import Box

from rf4s.controller.window import Window

CRITICAL_COLOR = (206, 56, 21)
WARNING_COLOR = (227, 149, 23)
WHITE = (255, 255, 255)

MIN_GRAY_SCALE_LEVEL = 150
YELLOW_FRICTION_BRAKE = (200, 214, 63)
ORANGE_FRICTION_BRAKE = (229, 188, 0)
RED_FRICTION_BRAKE = (206, 56, 21)
COLOR_TOLERANCE = 32
CAMERA_OFFSET = 40
SIDE_LENGTH = 160
SIDE_LENGTH_HALF = 80
ORANGE_REEL = (227, 149, 23)

ROOT = Path(__file__).resolve().parents[2]


class TagColor(Enum):
    GREEN = "green_tag"
    YELLOW = "yellow_tag"
    PINK = "pink_tag"
    BLUE = "blue_tag"
    PURPLE = "purple_tag"


COORD_OFFSETS = {
    "1600x900": {
        "friction_brake_very_high": (502, 872),  # Left point only
        "friction_brake_high": (459, 872),
        "friction_brake_medium": (417, 872),
        "friction_brake_low": (396, 872),
        "fish_icon": (389, 844),
        "clip_icon": (1042, 844),
        "spool_icon": (1077, 844),  # x + 15, y + 15
        "reel_burning_icon": (1112, 842),
        "snag_icon": (1147, 829),  # x + 15, y
        "float_camera": (720, 654),
        "bait_icon": (35, 31),
    },
    "1920x1080": {
        "friction_brake_very_high": (662, 1052),
        "friction_brake_high": (619, 1052),
        "friction_brake_medium": (577, 1052),
        "friction_brake_low": (556, 1052),
        "fish_icon": (549, 1024),
        "clip_icon": (1202, 1024),
        "spool_icon": (1237, 1024),
        "reel_burning_icon": (1271, 1023),
        "snag_icon": (1307, 1009),
        "float_camera": (880, 834),
        "bait_icon": (35, 31),
    },
    "2560x1440": {
        "friction_brake_very_high": (982, 1412),
        "friction_brake_high": (939, 1412),
        "friction_brake_medium": (897, 1412),
        "friction_brake_low": (876, 1412),
        "fish_icon": (869, 1384),
        "clip_icon": (1522, 1384),
        "spool_icon": (1557, 1384),
        "reel_burning_icon": (1593, 1383),
        "snag_icon": (1627, 1369),
        "float_camera": (1200, 1194),
        "bait_icon": (35, 31),
    },
}

# ------------------------ Friction brake coordinates ------------------------ #
# ----------------------------- 900p - 1080p - 2k ---------------------------- #
# ------ left - red - yellow - center(left + 424) - yellow - red - right ----- #
# "bases": ((480, 270), (320, 180), (0, 0))
# "absolute": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702, "y": (1146, 1236, 1412)}
# "1600x900": {"x": (375, 480, 586, 799, 1011, 1118, 1222), "y": 876},
# "1920x1080": {"x": (535, 640, 746, 959, 1171, 1278, 1382), "y": 1056},
# "2560x1440": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702), "y": 1412},


class Detection:
    """A class that holds different aliases of locateOnScreen(image).

    This class provides methods for detecting various in-game elements such as fish,
    icons, and UI components using image recognition and pixel color analysis.

    Attributes:
        cfg (CfgNode): Configuration node for the detection settings.
        window (Window): Game window controller instance.
        image_dir (Path): Directory containing reference images for detection.
        coord_offsets (dict): Dictionary of coordinate offsets for different window sizes.
        bait_icon_reference_img (Image): Reference image for bait icon detection.
    """

    def __init__(self, cfg, window: Window):
        """Initialize the Detection class with configuration and window settings.

        :param cfg: Configuration node for detection settings.
        :type cfg: CfgNode
        :param window: Game window controller instance.
        :type window: Window
        """
        self.cfg = cfg
        self.window = window
        self.image_dir = ROOT / "static" / cfg.SCRIPT.LANGUAGE

        if window.is_size_supported():
            self._set_absolute_coords()
            self.is_fish_hooked = self.is_fish_hooked_pixel
        else:
            self.is_fish_hooked = partial(
                self._get_image_box,
                image="fish_icon",
                confidence="0.9",
            )

        self.bait_icon_reference_img = Image.open(self.image_dir / "bait_icon.png")

    def _get_image_box(
        self, image: str, confidence: float, multiple: bool = False
    ) -> Box | Generator[Box, None, None] | None:
        """A wrapper for locateOnScreen method and path resolving.

        :param image: Base name of the image.
        :type image: str
        :param confidence: Matching confidence for locateOnScreen.
        :type confidence: float
        :param 


# === rf4s\controller\notification.py ===
import json
import logging
import smtplib
from datetime import datetime, timezone
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from enum import Enum
from urllib import parse, request

from discord_webhook import DiscordEmbed, DiscordWebhook
from rich import box
from rich.console import Console
from rich.table import Table

logger = logging.getLogger("rich")

ICON_URL = "https://i.ibb.co/RpLYcdkm/icon.png"

# Name                             | Int value | Hex code
# ---------------------------------|-----------|----------
# `BLURPLE`                        | 5793266   | `#5865F2`
# `GREEN`                          | 5763719   | `#57F287`
# `YELLOW`                         | 16705372  | `#FEE75C`
# `FUSCHIA`                        | 15418782  | `#EB459E`
# `RED`                            | 15548997  | `#ED4245`
# `WHITE`                          | 16777215  | `#FFFFFF`
# `BLACK`                          | 2303786   | `#23272A`


class DiscordColor(Enum):
    BLURPLE = 5793266
    GREEN = 5763719
    YELLOW = 16705372
    FUSCHIA = 15418782
    RED = 15548997
    WHITE = 16777215
    BLACK = 2303786


class DiscordNotification:
    def __init__(self, cfg, result):
        self.cfg = cfg
        self.result = result

    def build_raw_table(self) -> str:
        console = Console(width=100, force_terminal=True, color_system=None)
        table = Table("Field", "Value", box=box.DOUBLE, show_header=False)

        for key, value in self.result.items():
            table.add_row(key, str(value))

        with console.capture() as capture:
            console.print(table)

        return capture.get().strip()

    def send(self, color: DiscordColor):
        logger.info("Sending Discord notification")
        raw_table = self.build_raw_table()
        webhook = DiscordWebhook(
            url=self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL,
            username="RF4S",
            avatar_url=ICON_URL,
        )

        embed = DiscordEmbed(
            title="Running Result",
            color=color,
            timestamp=datetime.now(timezone.utc).isoformat(),
            footer={"text": "RF4S: Russian Fishing 4 Script", "icon_url": ICON_URL},
        )
        embed.description = f"```\n{raw_table}\n```"  # Wrap in code block

        webhook.add_embed(embed)
        response = webhook.execute()

        if response.status_code == 200:
            logger.info("Result successfully sent to Discord")
        else:
            logger.error(f"Failed to send result to Discord: {response.text}")


class EmailNotification:
    def __init__(self, cfg, result):
        self.cfg = cfg
        self.result = result

    def send(self) -> None:
        """Send a notification email to the user's email address."""
        logger.info("Sending email notification")

        msg = MIMEMultipart()
        msg["Subject"] = "RF4S: Notice of Program Termination"
        msg["From"] = self.cfg.NOTIFICATION.EMAIL
        recipients = [self.cfg.NOTIFICATION.EMAIL]
        msg["To"] = ", ".join(recipients)

        text = ""
        for k, v in self.result.items():
            text += f"{k}: {v}\n"
        msg.attach(MIMEText(text))

        try:
            with smtplib.SMTP_SSL(self.cfg.NOTIFICATION.SMTP_SERVER, 465) as server:
                # smtp_server.ehlo()
                server.login(
                    self.cfg.NOTIFICATION.EMAIL, self.cfg.NOTIFICATION.PASSWORD
                )
                server.sendmail(
                    self.cfg.NOTIFICATION.EMAIL, recipients, msg.as_string()
                )
            logger.info("Email sent successfully")
        except Exception as e:
            logger.error(f"Failed to send email: {e}")


class MiaotixingNotification:
    def __init__(self, cfg, result):
        self.cfg = cfg
        self.result = result

    def send(self) -> None:
        """Send a notification to the user's miaotixing service.

        :param result: running result
        :type result: dict
        """
        logger.info("Sending miaotixing notification")

        text = ""
        for k, v in self.result.items():
            text += f"{k}: {v}\n"

        url = "http://miaotixing.com/trigger?" + parse.urlencode(
            {"id": self.cfg.NOTIFICATION.MIAO_CODE, "text": text, "type": "json"}
        )

        with request.urlopen(url) as page:
            result = page.read()
            json_object = json.loads(result)
            if json_object["code"] == 0:
                logger.info("Miaotixing notification sent successfully")
            else:
                logger.error(
                    "Miaotixing notification with error code: %s\nDescription: %s",
                    str(json_object["code"]),
                    json_object["msg"],
                )



# === rf4s\controller\timer.py ===
"""Module for Timer class.

This module provides functionality for managing timers and generating timestamps
for logging and automation purposes in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import datetime
import logging
import time

from matplotlib import pyplot as plt
from matplotlib.ticker import MaxNLocator

logger = logging.getLogger("rich")


class Timer:
    """Class for calculating and generating timestamps for logs.

    This class manages various timers and counters for tracking in-game events,
    such as casting times, consumable cooldowns, and script pauses.

    Attributes:
        cfg (CfgNode): Configuration node for timer settings.
        start_time (float): Timestamp when the timer was initialized.
        start_datetime (str): Formatted start date and time.
        cast_rhour (int | None): Real-time hour of the last cast.
        cast_ghour (int | None): In-game hour of the last cast.
        cast_rhour_list (list[int]): List of real-time hours for casts.
        cast_ghour_list (list[int]): List of in-game hours for casts.
        last_tea_drink (float): Timestamp of the last tea consumption.
        last_alcohol_drink (float): Timestamp of the last alcohol consumption.
        last_lure_change (float): Timestamp of the last lure change.
        last_spod_rod_recast (float): Timestamp of the last spod rod recast.
        last_pause (float): Timestamp of the last script pause.
    """

    def __init__(self, cfg):
        """Initialize the Timer class with configuration settings.

        :param cfg: Configuration node for timer settings.
        :type cfg: CfgNode
        """
        self.cfg = cfg
        self.start_time = time.time()
        self.start_datetime = time.strftime("%m/%d %H:%M:%S", time.localtime())

        self.cast_rhour = None
        self.cast_ghour = None
        self.cast_rhour_list = []
        self.cast_ghour_list = []

        self.last_tea_drink = 0
        self.last_alcohol_drink = 0
        self.last_lure_change = self.start_time
        self.last_spod_rod_recast = self.start_time
        self.last_pause = self.start_time

    def get_running_time(self) -> str:
        """Calculate the execution time of the program.

        :return: Formatted execution time (hh:mm:ss).
        :rtype: str
        """
        return time.time() - self.start_time

    def get_running_time_str(self) -> str:
        """Calculate the execution time of the program.

        :return: Formatted execution time (hh:mm:ss).
        :rtype: str
        """
        return str(
            datetime.timedelta(seconds=int(time.time() - self.start_time))
        )  # truncate to seconds

    def get_cur_timestamp(self) -> str:
        """Generate timestamp for images in screenshots/.

        :return: Current timestamp.
        :rtype: str
        """
        return time.strftime("%Y-%m-%d--%H-%M-%S", time.localtime())

    def get_start_datetime(self) -> str:
        """Generate a simplified timestamp for quit message.

        :return: Start date and time.
        :rtype: str
        """
        return self.start_datetime

    def get_cur_datetime(self) -> str:
        """Generate a simplified timestamp for quit message.

        :return: Current date and time.
        :rtype: str
        """
        return time.strftime("%m/%d %H:%M:%S", time.localtime())

    def update_cast_time(self) -> None:
        """Update the latest real and in-game hour of casting."""
        dt = datetime.datetime.now()
        self.cast_rhour = int((time.time() - self.start_time) // 3600)
        self.cast_ghour = int((dt.minute / 60 + dt.second / 3600) * 24 % 24)

    def add_cast_time(self) -> None:
        """Record the latest real and in-game hour of casting."""
        self.cast_rhour_list.append(self.cast_rhour)
        self.cast_ghour_list.append(self.cast_ghour)

    def get_cast_time_list(self) -> tuple[list[int]]:
        """Get lists of real and in-game hours for casts.

        :return: Lists of real and in-game hours.
        :rtype: tuple[list[int]]
        """
        return self.cast_rhour_list, self.cast_ghour_list

    def is_tea_drinkable(self) -> bool:
        """Check if it has been a long time since the last tea consumption.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_tea_drink > self.cfg.STAT.TEA_DELAY:
            self.last_tea_drink = cur_time
            return True
        return False

    def is_alcohol_drinkable(self) -> bool:
        """Check if it has been a long time since the last alcohol consumption.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_alcohol_drink > self.cfg.STAT.ALCOHOL_DELAY:
            self.last_alcohol_drink = cur_time
            self.last_tea_drink = cur_time  # Alcohol also refill comfort
            return True


# === rf4s\controller\window.py ===
"""Module for window controller.

This module provides functionality for managing and interacting with the game window
and terminal window in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import sys
from pathlib import Path
from time import sleep

# import win32api, win32con
import pyautogui as pag
import win32con
import win32gui

logger = logging.getLogger("rich")

ROOT = Path(__file__).resolve().parents[2]
ANIMATION_DELAY = 0.25


class Window:
    """Controller for terminal and game windows management.

    This class handles window focus, size detection, and screenshot functionality
    for the game and terminal windows.

    Attributes:
        game_title (str): Title of the game window.
        terminal_hwnd (int): Handle of the terminal window.
    """

    def __init__(self, game_title: str = "Russian Fishing 4"):
        """Set the hwnd of the terminal where user run the script.

        We didn't retrieve the game window's hwnd here because we don't want to check
        if the window is open right away. Instead, we perform the check after the
        configuration is set.

        :param game_title: Title of the game, defaults to "Russian Fishing 4".
        :type game_title: str, optional
        """
        self.game_title = game_title
        self.terminal_hwnd = win32gui.GetForegroundWindow()

    def _get_game_hwnd(self) -> int:
        """Get the handle of the game window.

        :return: Process handle of the game window.
        :rtype: int
        """
        hwnd = win32gui.FindWindow(None, self.game_title)  # class name: UnityWndClass
        if hwnd == 0:
            logger.critical("Failed to locate the game window: %s", self.game_title)
            sys.exit(1)
        return hwnd

    def is_title_bar_exist(self) -> bool:
        """Check if the game window is in windowed mode.

        :return: True if the game window has a title bar, False otherwise.
        :rtype: bool
        """
        style = win32gui.GetWindowLong(self._get_game_hwnd(), win32con.GWL_STYLE)
        return style & win32con.WS_CAPTION

    def get_box(self) -> tuple[int, int, int, int]:
        """Get the coordinates and dimensions of the game window.

        :return: Tuple containing (x, y, width, height) of the game window.
        :rtype: tuple[int, int, int, int]
        """
        # Absolute coordinates
        base_x, base_y, _, _ = win32gui.GetWindowRect(self._get_game_hwnd())
        if self.is_title_bar_exist():
            base_x += 8
            base_y += 31
        # Relative coordinates
        left, top, right, bottom = win32gui.GetClientRect(self._get_game_hwnd())
        return base_x, base_y, right - left, bottom - top

    def get_base_coordinates(self) -> tuple[int, int]:
        """Get the base coordinates of the game window.

        :return: Tuple containing (x, y) of the base coordinates.
        :rtype: tuple[int, int]
        """
        return self.get_box()[:2]

    def get_resolution_str(self) -> tuple[int, int]:
        """Get the resolution of the game window.

        :return: Tuple containing (width, height) of the game window.
        :rtype: tuple[int, int]
        """
        width, height = self.get_box()[2:]
        return f"{width}x{height}"

    def activate_script_window(self) -> None:
        """Focus the terminal where user run the script."""
        pag.press("alt")
        win32gui.SetForegroundWindow(self.terminal_hwnd)
        sleep(ANIMATION_DELAY)

    def activate_game_window(self) -> None:
        """Focus game window."""
        pag.press("alt")
        win32gui.SetForegroundWindow(self._get_game_hwnd())
        sleep(ANIMATION_DELAY)

    def is_size_supported(self) -> bool:
        """Check if the game window size is supported.

        :return: True if it's supported, False otherwise.
        :rtype: bool
        """
        return self.get_resolution_str() in (
            "2560x1440",
            "1920x1080",
            "1600x900",
        )

    def save_screenshot(self, time) -> None:
        """Save a screenshot of the game window to the screenshots directory.

        :param time: Timestamp for the filename.
        :type time: str
        """
        pag.screenshot(
            imageFilename=ROOT / "screenshots" / f"{time}.png",
            region=self.get_box(),
        )


if __name__ == "__main__":
    w = Window("Russian Fishing 4")
    # w.activate_game_window()
    print(w.get_box())
    print(w.get_base_coordinates())
    print(w.get_resolution_str())
    print(w.is_size_supported())

# SetForegroundWindow bug reference :
# https://stackoverflow.com/questions/56857560/win32gui-setforegroundwindowhandle-not-working-in-loop



# === rf4s\controller\__pycache__\detection.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\__pycache__\notification.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\__pycache__\timer.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\__pycache__\window.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\result\result.py ===
from dataclasses import dataclass

from rf4s.controller.timer import Timer


@dataclass
class Result:
    """Dummy result."""

    def as_dict(self) -> dict:
        return {}


@dataclass
class RF4SResult:
    tea: int = 0
    carrot: int = 0
    alcohol: int = 0
    coffee: int = 0
    bait: int = 0
    kept: int = 0
    total: int = 0
    green: int = 0
    yellow: int = 0
    blue: int = 0
    purple: int = 0
    pink: int = 0

    def as_dict(self, msg: str, timer: Timer) -> dict:
        # Will be 0 if total_fish_count = 0
        kept_ratio = f"{int(self.kept / max(1, self.total) * 100)}%"
        bite_rate = f"{int((self.total / (timer.get_running_time() / 3600)))}/hr"

        return {
            "Stop reason": msg,
            "Start time": timer.get_start_datetime(),
            "End time": timer.get_cur_datetime(),
            "Running time": timer.get_running_time_str(),
            "Bite rate": bite_rate,
            "Total fish": self.total,
            "Kept fish": self.kept,
            "Kept ratio": kept_ratio,
            "Green tag fish": self.green,
            "Yellow tag fish": self.yellow,
            "Blue tag fish": self.blue,
            "Purple tag fish": self.purple,
            "Pink tag fish": self.pink,
            "Tea consumed": self.tea,
            "Carrot consumed": self.carrot,
            "Alcohol consumed": self.alcohol,
            "Coffee consumed": self.coffee,
            "Bait harvested": self.bait,
        }


@dataclass
class CraftResult:
    succes: int = 0
    fail: int = 0
    material: int = 0

    def as_dict(self) -> dict:
        return {
            "Successful crafts": self.succes,
            "Failed crafts": self.fail,
            "Materials used": self.material,
        }


@dataclass
class HarvestResult:
    tea: int = 0
    carrot: int = 0
    bait: int = 0

    def as_dict(self) -> dict:
        return {
            "Tea consumed": self.tea,
            "Carrot consumed": self.carrot,
            "Bait harvested": self.bait,
        }



# === rf4s\result\__pycache__\result.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\exceptions.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\player.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\utils.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\__init__.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === static\en\0m.png ===
Это картинка


# === static\en\100wear.png ===
Это картинка


# === static\en\5m.png ===
Это картинка


# === static\en\bait_icon.png ===
Это картинка


# === static\en\blue_tag.png ===
Это картинка


# === static\en\broke.png ===
Это картинка


# === static\en\carrot.png ===
Это картинка


# === static\en\classic_feed_mix.png ===
Это картинка


# === static\en\coffee.png ===
Это картинка


# === static\en\comfort.png ===
Это картинка


# === static\en\confirm.png ===
Это картинка


# === static\en\disconnected.png ===
Это картинка


# === static\en\dry_feed_mix.png ===
Это картинка


# === static\en\energy.png ===
Это картинка


# === static\en\exit.png ===
Это картинка


# === static\en\favorite.png ===
Это картинка


# === static\en\fish_icon.png ===
Это картинка


# === static\en\food.png ===
Это картинка


# === static\en\gift.png ===
Это картинка


# === static\en\green_tag.png ===
Это картинка


# === static\en\groundbait_icon.png ===
Это картинка


# === static\en\harvest_confirm.png ===
Это картинка


# === static\en\herring.png ===
Это картинка


# === static\en\keep.png ===
Это картинка


# === static\en\lure_is_broken.png ===
Это картинка


# === static\en\mackerel.png ===
Это картинка


# === static\en\make.png ===
Это картинка


# === static\en\material_slot.png ===
Это картинка


# === static\en\movement.png ===
Это картинка


# === static\en\mussel.png ===
Это картинка


# === static\en\ok.png ===
Это картинка


# === static\en\ok_black.png ===
Это картинка


# === static\en\ok_white.png ===
Это картинка


# === static\en\perch.png ===
Это картинка


# === static\en\pink_tag.png ===
Это картинка


# === static\en\purple_tag.png ===
Это картинка


# === static\en\pva_icon.png ===
Это картинка


# === static\en\pva_stick_or_pva_stringer.png ===
Это картинка


# === static\en\quit.png ===
Это картинка


# === static\en\ready.png ===
Это картинка


# === static\en\saithe.png ===
Это картинка


# === static\en\scallop.png ===
Это картинка


# === static\en\scrollbar.png ===
Это картинка


# === static\en\shorthorn_sculpin.png ===
Это картинка


# === static\en\squid.png ===
Это картинка


# === static\en\tea.png ===
Это картинка


# === static\en\ticket.png ===
Это картинка


# === static\en\ticket_1.png ===
Это картинка


# === static\en\ticket_2.png ===
Это картинка


# === static\en\ticket_3.png ===
Это картинка


# === static\en\ticket_5.png ===
Это картинка


# === static\en\warning.png ===
Это картинка


# === static\en\welcome.png ===
Это картинка


# === static\en\wheel.png ===
Это картинка


# === static\en\yellow_tag.png ===
Это картинка


# === static\en\yes.png ===
Это картинка


# === static\readme\clicklock.png ===
Это картинка


# === static\readme\favorite_food.png ===
Это картинка


# === static\readme\favorite_lure.png ===
Это картинка


# === static\readme\icon.png ===
Это картинка


# === static\readme\mtx1.png ===
Это картинка


# === static\readme\mtx2.png ===
Это картинка


# === static\readme\mtx3.png ===
Это картинка


# === static\readme\path.png ===
Это картинка


# === static\readme\RF4S.png ===
Это картинка


# === static\readme\RF4S_original.png ===
Это картинка


# === static\readme\status.png ===
Это картинка


# === static\ru\0m.png ===
Это картинка


# === static\ru\100wear.png ===
Это картинка


# === static\ru\5m.png ===
Это картинка


# === static\ru\bait_icon.png ===
Это картинка


# === static\ru\blue_tag.png ===
Это картинка


# === static\ru\broke.png ===
Это картинка


# === static\ru\carrot.png ===
Это картинка


# === static\ru\classic_feed_mix.png ===
Это картинка


# === static\ru\coffee.png ===
Это картинка


# === static\ru\comfort.png ===
Это картинка


# === static\ru\confirm.png ===
Это картинка


# === static\ru\disconnected.png ===
Это картинка


# === static\ru\dry_feed_mix.png ===
Это картинка


# === static\ru\energy.png ===
Это картинка


# === static\ru\exit.png ===
Это картинка


# === static\ru\favorite.png ===
Это картинка


# === static\ru\fish_icon.png ===
Это картинка


# === static\ru\food.png ===
Это картинка


# === static\ru\gift.png ===
Это картинка


# === static\ru\green_tag.png ===
Это картинка


# === static\ru\groundbait_icon.png ===
Это картинка


# === static\ru\harvest_confirm.png ===
Это картинка


# === static\ru\herring.png ===
Это картинка


# === static\ru\keep.png ===
Это картинка


# === static\ru\lure_is_broken.png ===
Это картинка


# === static\ru\mackerel.png ===
Это картинка


# === static\ru\make.png ===
Это картинка


# === static\ru\material_slot.png ===
Это картинка


# === static\ru\movement.png ===
Это картинка


# === static\ru\mussel.png ===
Это картинка


# === static\ru\ok.png ===
Это картинка


# === static\ru\ok_black.png ===
Это картинка


# === static\ru\ok_white.png ===
Это картинка


# === static\ru\perch.png ===
Это картинка


# === static\ru\pink_tag.png ===
Это картинка


# === static\ru\purple_tag.png ===
Это картинка


# === static\ru\pva_icon.png ===
Это картинка


# === static\ru\pva_stick_or_pva_stringer.png ===
Это картинка


# === static\ru\quit.png ===
Это картинка


# === static\ru\ready.png ===
Это картинка


# === static\ru\saithe.png ===
Это картинка


# === static\ru\scallop.png ===
Это картинка


# === static\ru\scrollbar.png ===
Это картинка


# === static\ru\shorthorn_sculpin.png ===
Это картинка


# === static\ru\squid.png ===
Это картинка


# === static\ru\tea.png ===
Это картинка


# === static\ru\ticket.png ===
Это картинка


# === static\ru\ticket_1.png ===
Это картинка


# === static\ru\ticket_2.png ===
Это картинка


# === static\ru\ticket_3.png ===
Это картинка


# === static\ru\ticket_5.png ===
Это картинка


# === static\ru\warning.png ===
Это картинка


# === static\ru\welcome.png ===
Это картинка


# === static\ru\wheel.png ===
Это картинка


# === static\ru\yellow_tag.png ===
Это картинка


# === static\ru\yes.png ===
Это картинка


# === static\sound\app_1.wav ===
Это аудиофайл


# === static\sound\app_2.wav ===
Это аудиофайл


# === static\sound\app_3.wav ===
Это аудиофайл


# === static\sound\bell_1.wav ===
Это аудиофайл


# === static\sound\bell_2.wav ===
Это аудиофайл


# === static\sound\bell_3.wav ===
Это аудиофайл


# === static\sound\digital.wav ===
Это аудиофайл


# === static\sound\door_bell.wav ===
Это аудиофайл


# === static\sound\elevator.wav ===
Это аудиофайл


# === static\sound\fast_alarm.wav ===
Это аудиофайл


# === static\sound\flute_1.wav ===
Это аудиофайл


# === static\sound\flute_2.wav ===
Это аудиофайл


# === static\sound\guitar.wav ===
Это аудиофайл


# === static\sound\marimba.wav ===
Это аудиофайл


# === static\sound\ripple.wav ===
Это аудиофайл


# === static\zh-CN\0m.png ===
Это картинка


# === static\zh-CN\100wear.png ===
Это картинка


# === static\zh-CN\5m.png ===
Это картинка


# === static\zh-CN\bait_icon.png ===
Это картинка


# === static\zh-CN\blue_tag.png ===
Это картинка


# === static\zh-CN\broke.png ===
Это картинка


# === static\zh-CN\carrot.png ===
Это картинка


# === static\zh-CN\coffee.png ===
Это картинка


# === static\zh-CN\comfort.png ===
Это картинка


# === static\zh-CN\confirm.png ===
Это картинка


# === static\zh-CN\disconnected.png ===
Это картинка


# === static\zh-CN\energy.png ===
Это картинка


# === static\zh-CN\exit.png ===
Это картинка


# === static\zh-CN\favorite.png ===
Это картинка


# === static\zh-CN\fish_icon.png ===
Это картинка


# === static\zh-CN\food.png ===
Это картинка


# === static\zh-CN\gift.png ===
Это картинка


# === static\zh-CN\green_tag.png ===
Это картинка


# === static\zh-CN\groundbait_icon.png ===
Это картинка


# === static\zh-CN\harvest_confirm.png ===
Это картинка


# === static\zh-CN\keep.png ===
Это картинка


# === static\zh-CN\lure_is_broken.png ===
Это картинка


# === static\zh-CN\make.png ===
Это картинка


# === static\zh-CN\material_slot.png ===
Это картинка


# === static\zh-CN\movement.png ===
Это картинка


# === static\zh-CN\ok.png ===
Это картинка


# === static\zh-CN\pink_tag.png ===
Это картинка


# === static\zh-CN\purple_tag.png ===
Это картинка


# === static\zh-CN\pva_icon.png ===
Это картинка


# === static\zh-CN\quit.png ===
Это картинка


# === static\zh-CN\ready.png ===
Это картинка


# === static\zh-CN\scrollbar.png ===
Это картинка


# === static\zh-CN\tea.png ===
Это картинка


# === static\zh-CN\ticket.png ===
Это картинка


# === static\zh-CN\ticket_1.png ===
Это картинка


# === static\zh-CN\ticket_2.png ===
Это картинка


# === static\zh-CN\ticket_3.png ===
Это картинка


# === static\zh-CN\ticket_5.png ===
Это картинка


# === static\zh-CN\warning.png ===
Это картинка


# === static\zh-CN\welcome.png ===
Это картинка


# === static\zh-CN\wheel.png ===
Это картинка


# === static\zh-CN\yellow_tag.png ===
Это картинка


# === static\zh-CN\yes.png ===
Это картинка


# === static\zh-TW\0m.png ===
Это картинка


# === static\zh-TW\100wear.png ===
Это картинка


# === static\zh-TW\5m.png ===
Это картинка


# === static\zh-TW\bait_icon.png ===
Это картинка


# === static\zh-TW\blue_tag.png ===
Это картинка


# === static\zh-TW\broke.png ===
Это картинка


# === static\zh-TW\carrot.png ===
Это картинка


# === static\zh-TW\coffee.png ===
Это картинка


# === static\zh-TW\comfort.png ===
Это картинка


# === static\zh-TW\confirm.png ===
Это картинка


# === static\zh-TW\disconnected.png ===
Это картинка


# === static\zh-TW\energy.png ===
Это картинка


# === static\zh-TW\exit.png ===
Это картинка


# === static\zh-TW\favorite.png ===
Это картинка


# === static\zh-TW\fish_icon.png ===
Это картинка


# === static\zh-TW\food.png ===
Это картинка


# === static\zh-TW\gift.png ===
Это картинка


# === static\zh-TW\green_tag.png ===
Это картинка


# === static\zh-TW\groundbait_icon.png ===
Это картинка


# === static\zh-TW\harvest_confirm.png ===
Это картинка


# === static\zh-TW\herring.png ===
Это картинка


# === static\zh-TW\keep.png ===
Это картинка


# === static\zh-TW\lure_is_broken.png ===
Это картинка


# === static\zh-TW\mackerel.png ===
Это картинка


# === static\zh-TW\make.png ===
Это картинка


# === static\zh-TW\material_slot.png ===
Это картинка


# === static\zh-TW\movement.png ===
Это картинка


# === static\zh-TW\mussel.png ===
Это картинка


# === static\zh-TW\ok.png ===
Это картинка


# === static\zh-TW\pink_tag.png ===
Это картинка


# === static\zh-TW\purple_tag.png ===
Это картинка


# === static\zh-TW\pva_icon.png ===
Это картинка


# === static\zh-TW\quit.png ===
Это картинка


# === static\zh-TW\ready.png ===
Это картинка


# === static\zh-TW\saithe.png ===
Это картинка


# === static\zh-TW\scallop.png ===
Это картинка


# === static\zh-TW\scrollbar.png ===
Это картинка


# === static\zh-TW\squid.png ===
Это картинка


# === static\zh-TW\tea.png ===
Это картинка


# === static\zh-TW\ticket.png ===
Это картинка


# === static\zh-TW\ticket_1.png ===
Это картинка


# === static\zh-TW\ticket_2.png ===
Это картинка


# === static\zh-TW\ticket_3.png ===
Это картинка


# === static\zh-TW\ticket_5.png ===
Это картинка


# === static\zh-TW\warning.png ===
Это картинка


# === static\zh-TW\welcome.png ===
Это картинка


# === static\zh-TW\wheel.png ===
Это картинка


# === static\zh-TW\yellow_tag.png ===
Это картинка


# === static\zh-TW\yes.png ===
Это картинка


# === tools\auto_friction_brake.py ===
"""Automate friction brake adjustments in Russian Fishing 4.

This module provides functionality to automatically adjust the friction brake
based on in-game conditions. It supports key bindings for exiting the script
and resetting the friction brake.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import sys
from multiprocessing import Lock

from pynput import keyboard
from rich import print

sys.path.append(".")
from rf4s.app.app import ToolApp
from rf4s.component.friction_brake import FrictionBrake
from rf4s.config.config import print_cfg
from rf4s.utils import create_rich_logger

logger = create_rich_logger()


class FrictionBrakeApp(ToolApp):
    """Main application class for automating friction brake adjustments.

    This class manages the configuration, detection, and execution of the friction
    brake automation process. It also handles key bindings for exiting and resetting.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        friction_brake (FrictionBrake): Friction brake controller instance.
    """

    def __init__(self):
        """Initialize the application.

        1. Check the game window state.
        2. Format keybinds in cfg node.
        3. Display cfg node.
        4. Initialize a friction brake instance.
        """
        super().__init__()
        if not self.is_game_window_valid():
            sys.exit(1)

        # Format keys
        self.cfg.defrost()
        self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
        self.cfg.ARGS.RESET_KEY = f"'{self.cfg.ARGS.RESET_KEY}'"
        self.cfg.freeze()
        print_cfg(self.cfg.ARGS)
        print_cfg(self.cfg.FRICTION_BRAKE)

        self.friction_brake = FrictionBrake(self.cfg, Lock(), self.detection)

    def is_game_window_valid(self) -> bool:
        """Check if the game window mode and size are valid.

        :return: True if valid, False otherwise
        :rtype: bool
        """
        if self.window.is_title_bar_exist():
            logger.info("Window mode detected. Please don't move the game window")
        if not self.window.is_size_supported():
            logger.critical(
                'Window mode must be "Borderless windowed" or "Window mode"'
            )
            logger.critical(
                "Unsupported window size '%s', "
                "use '2560x1440', '1920x1080' or '1600x900'",
                self.window.get_resolution_str(),
            )
            return False
        return True

    def create_parser(self) -> argparse.ArgumentParser:
        """Create an argument parser for the application.

        :return: Configured argument parser.
        :rtype: argparse.ArgumentParser
        """
        parser = argparse.ArgumentParser(description="Automate friction brake.")
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-r",
            "--reset-key",
            default="g",
            type=str,
            help="key to reset friction brake, g by default",
            metavar="KEY",
        )
        parser.add_argument(
            "-q",
            "--quit-key",
            default="h",
            type=str,
            help="key to quit the script, h by default",
            metavar="KEY",
        )
        return parser

    def _on_release(self, key: keyboard.KeyCode) -> None:
        """Handle exit and quit events.

        :param key: The key that was released.
        :type key: keyboard.KeyCode
        """
        keystroke = str(key).lower()
        if keystroke == self.cfg.ARGS.QUIT_KEY:
            self.friction_brake.monitor_process.terminate()
            sys.exit()
        if keystroke == self.cfg.ARGS.RESET_KEY:
            self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)

    def _start(self):
        """Start the friction brake automation process.

        Begins the friction brake monitoring process and starts a keyboard listener
        to handle control keys.
        """
        print(
            f"Press {self.cfg.ARGS.RESET_KEY[1:-1]} to reset friction brake, "
            f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
        )
        self.friction_brake.monitor_process.start()
        with keyboard.Listener(on_release=self._on_release) as listener:
            listener.join()


if __name__ == "__main__":
    FrictionBrakeApp().start()



# === tools\calculate.py ===
"""Calculate the maximum friction brake you can use on your tackle.

This module provides functionality to calculate the maximum friction brake and tension
based on the reel's max drag, friction brake wear, leader's load capacity, and wear.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import sys

from rich import print
from rich.prompt import Prompt
from rich.table import Table

sys.path.append(".")
from rf4s import utils

BIAS = 1e-6


def get_tackle_stats():
    """Get actual stats of reel and leader based on their wears.

    Prompts the user for input and calculates the true max drag and load capacity
    after accounting for wear.

    :return: A tuple containing the true max drag and true load capacity.
    :rtype: tuple[float, float]
    """
    prompts = (
        "Reel's max drag (kg)",
        "Reel's friction brake wear (%)",
        "Leader's load capacity (kg)",
        "Leader's wear (%)",
    )

    while True:
        restart = False
        stats = []
        for prompt in prompts:
            validated_input = get_validated_input(prompt)
            if validated_input is None:
                restart = True
                break
            stats.append(validated_input)

        if restart:
            continue

        max_drag, friction_brake_wear, leader_load_capacity, leader_wear = stats
        true_max_drag = max_drag * (100 - friction_brake_wear) / 100
        true_load_capacity = leader_load_capacity * (100 - leader_wear) / 100
        return true_max_drag, true_load_capacity


def get_validated_input(prompt: str) -> float | None:
    """Get validated input from the user.

    Prompts the user for input and validates it. Supports quitting and restarting.

    :param prompt: The prompt message to display to the user.
    :type prompt: str
    :return: The validated input as a float, or None if the user chooses to restart.
    :rtype: float or None
    """
    while True:
        user_input = Prompt.ask(prompt)
        if user_input == "q":
            print("Bye.")
            sys.exit()
        if user_input == "r":
            return None

        try:
            return float(user_input)
        except ValueError:
            utils.print_error("Invalid input. Please enter a number.")


def main():
    """Main function to run the friction brake calculation.

    Prompts the user for input, calculates the result, and displays them in a table.
    """
    print("Please enter your tackle's stats, type q to quit, r to restart. ")
    while True:
        max_drag, load_capacity = get_tackle_stats()
        max_friction_brake = int(min(load_capacity * 30 / (max_drag + BIAS) - 1, 29))
        max_tension = max_drag * max_friction_brake / 30

        table = Table(
            "Result",
            title="Your tackle's real stats 🎣",
            show_header=False,
            min_width=36,
        )
        table.add_row("Reel's true max drag", f"{max_drag:.2f} kg")
        table.add_row("Leader's true load capacity", f"{load_capacity:.2f} kg")
        table.add_row("Friction brake tension", f"{max_tension:.2f} kg")
        table.add_row("Maximum friction brake to use", f"{max_friction_brake}")
        print(table)


if __name__ == "__main__":
    main()



# === tools\craft.py ===
"""Activate game window and start crafting things until running out of materials.

This module automates the crafting process in Russian Fishing 4. It supports
discarding crafted items, fast crafting mode, and a configurable crafting limit.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import random
import sys
from datetime import datetime
from pathlib import Path
from time import sleep

import pyautogui as pag
from pynput import keyboard

sys.path.append(".")
from rf4s.app.app import ToolApp
from rf4s.config.config import print_cfg
from rf4s.result.result import CraftResult
from rf4s.utils import create_rich_logger

CRAFT_DELAY = 4.0
CRAFT_DELAY_2X = CRAFT_DELAY * 2
LOOP_DELAY = 0.5
LOOP_DELAY_2X = LOOP_DELAY * 2
ROOT = Path(__file__).resolve().parents[1]

logger = create_rich_logger()


class CraftApp(ToolApp):
    """Main application class for automating crafting.

    This class manages the configuration, detection, and execution of the crafting
    process. It tracks the number of successful and failed crafts, as well as the
    total number of materials used.
    """

    def __init__(self):
        """Initialize the application."""
        super().__init__()
        print_cfg(self.cfg.ARGS)
        self.result = CraftResult()

    def create_parser(self) -> argparse.ArgumentParser:
        """Create an argument parser for the application.

        :return: Configured argument parser.
        :rtype: argparse.ArgumentParser
        """
        parser = argparse.ArgumentParser(description="Craft items automatically.")
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-d",
            "--discard",
            action="store_true",
            help="discard all the crafted items (for groundbaits)",
        )
        parser.add_argument(
            "-f",
            "--fast",
            action="store_true",
            help="disable delay randomization to speed up crafting",
        )
        parser.add_argument(
            "-n",
            "--craft-limit",
            type=int,
            default=-1,
            help="number of items to craft, no limit by default",
            metavar="LIMIT",
        )
        return parser

    def get_action_delays(self) -> tuple[float, float]:
        """Get crafting and checking delays.

        :return: Two delays in seconds
        :rtype: tuple[float, float]
        """
        if self.cfg.ARGS.FAST:
            return CRAFT_DELAY, LOOP_DELAY
        return (
            random.uniform(CRAFT_DELAY, CRAFT_DELAY_2X),
            random.uniform(LOOP_DELAY, LOOP_DELAY_2X),
        )

    def move_cursor_to_make_button(self) -> None:
        """Move the cursor to the make button position.

        This method uses the Detection class to find the position of the make button
        and moves the cursor to that position.
        """
        make_button_position = self.detection.get_make_button_position()
        if make_button_position is None:
            logger.critical(
                "Make button not found, please set the interface scale to "
                "1x or move your mouse around"
            )
            self.window.activate_script_window()
            sys.exit(1)
        pag.moveTo(make_button_position)

    def craft_item(
        self, craft_delay: float, accept_delay: float, accept_key: str
    ) -> None:
        """Craft an item.

        :param craft_delay: Delay in seconds before accepting the crafted item.
        :type craft_delay: float
        :param accept_delay: Delay in seconds after accepting the crafted item.
        :type accept_delay: float
        :param accept_key: Key to press after accepting the crafted item.
        :type accept_key: str
        """
        logger.info("Crafting item")
        pag.click()
        sleep(craft_delay)
        self.result.material += 1
        while True:
            if self.detection.is_operation_success():
                logger.info("Crafting successed")
                self.result.succes += 1
                break

            if self.detection.is_operation_failed():
                logger.warning("Crafting failed")
                self.result.fail += 1
                break
            sleep(LOOP_DELAY)
        pag.press(accept_key)
        sleep(accept_delay)

    def _start(self) -> None:
        """Main loop for crafting items.

        Executes the primary loop for crafting items until materials are exhausted or
        the crafting limit is reached. Supports fast crafting mode and discarding items.
        """
        if self.cfg.KEY.QUIT != "CTRL-C":
            listener = keyboard.Listener(on_release=self._on_release)
            listener.start()
        print(f"Press {self.cfg.KEY.QUIT} to quit.")
        random.seed(datetime.now().timestamp())
        accept_key = "backspace" if self.cfg.ARGS.DISCARD else "space"
        self.move_cursor_to_make_button()
        while True:
            i


# === tools\harvest.py ===
"""Script for automatic baits harvesting and hunger/comfort refill.

This module provides functionality to automate the harvesting of baits and refilling
of hunger and comfort in Russian Fishing 4. It includes options for power-saving
mode and configurable check delays.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import sys
from pathlib import Path
from time import sleep

import pyautogui as pag
from pynput import keyboard

sys.path.append(".")

from rf4s.app.app import ToolApp
from rf4s.config.config import print_cfg
from rf4s.controller.timer import Timer
from rf4s.result.result import HarvestResult
from rf4s.utils import create_rich_logger

ROOT = Path(__file__).resolve().parents[1]
DIG_DELAY = 5  # 4 + 1 s
CHECK_DELAY = 0.5
ANIMATION_DELAY = 0.5

logger = create_rich_logger()


class HarvestApp(ToolApp):
    """Main application class for automating bait harvesting and hunger/comfort refill.

    This class manages the configuration, detection, and execution of the harvesting
    and refill processes. It also handles power-saving mode and check delays.

    Attributes:
        timer (Timer): Timer instance for managing cooldowns.
    """

    def __init__(self):
        """Initialize the application.

        Loads configuration, parses command-line arguments, and sets up the game window,
        detection, and timer instances.
        """
        super().__init__()
        print_cfg(self.cfg.ARGS)

        self.timer = Timer(self.cfg)
        self.result = HarvestResult()

    def create_parser(self) -> argparse.ArgumentParser:
        """Create an argument parser for the application.

        :return: Configured argument parser.
        :rtype: argparse.ArgumentParser
        """
        parser = argparse.ArgumentParser(
            description="Harvest baits and refill hunger/comfort automatically.",
        )
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-r",
            "--refill",
            action="store_true",
            help="refill hunger and comfort by consuming tea and carrot",
        )
        parser.add_argument(
            "-s",
            "--power-saving",
            action="store_true",
            help="open control panel between checks to reduce power consumption",
        )
        parser.add_argument(
            "-n",
            "--check-delay",
            type=int,
            default=32,
            help="delay time between each checks, 32s by default",
        )
        return parser

    def harvest_baits(self) -> None:
        """Harvest baits using shovel/spoon.

        The digging tool should be pulled out before calling this method. Waits for
        harvest success and presses the spacebar to complete the process.
        """
        logger.info("Harvesting baits")
        pag.click()
        sleep(DIG_DELAY)
        while not self.detection.is_harvest_success():
            sleep(CHECK_DELAY)
        pag.press("space")
        logger.info("Baits harvested succussfully")
        sleep(ANIMATION_DELAY)

    def refill_player_stats(self) -> None:
        """Refill player stats using tea and carrot."""
        if not self.cfg.ARGS.REFILL:
            return

        logger.info("Refilling player stats")
        # Comfort is affected by weather, add a check to avoid over drink
        if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
            self._use_item("tea")
            self.result.tea += 1

        if self.detection.is_hunger_low():
            self._use_item("carrot")
            self.result.carrot += 1

    def _use_item(self, item: str) -> None:
        """Access an item by name using quick selection shortcut or menu.

        :param item: The name of the item to access.
        :type item: str
        """
        logger.info("Using item: %s", item)
        key = str(self.cfg.KEY[item.upper()])
        if key != "-1":  # Use shortcut
            pag.press(key)
        else:  # Open food menu
            with pag.hold("t"):
                sleep(ANIMATION_DELAY)
                food_position = self.detection.get_food_position(item)
                pag.moveTo(food_position)
                pag.click()
        sleep(ANIMATION_DELAY)

    def _start(self) -> None:
        """Main loop for eating and harvesting.

        Executes the primary loop for checking hunger/comfort levels, consuming food,
        and harvesting baits. Supports power-saving mode and configurable check delays.
        """
        if self.cfg.KEY.QUIT != "CTRL-C":
            listener = keyboard.Listener(on_release=self._on_release)
            listener.start()
        print(f"Press {self.cfg.KEY.QUIT} to quit.")

        pag.press(str(self.cfg.KEY.DIGGING_TOOL))
        sleep(3)
        while True:
            self.refill_player_stats()
            if self.detection.is_energy_high():
                self.harvest_baits()
                self.result.bait += 1
      


# === tools\main.py ===
"""Main CLI for Russian Fishing 4 Script.

This module provides the command-line interface and main execution logic
for automating fishing in Russian Fishing 4. It handles configuration,
argument parsing, window management, and fishing automation.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import shlex
import smtplib
import sys
from argparse import ArgumentParser, Namespace
from pathlib import Path
from socket import gaierror

from pynput import keyboard
from rich import box, print
from rich.panel import Panel
from rich.style import Style
from rich.table import Column, Table
from yacs.config import CfgNode as CN

sys.path.append(".")  # python -m module -> python file
from rf4s import utils
from rf4s.app.app import App
from rf4s.config import config
from rf4s.player import Player
from rf4s.utils import create_rich_logger

logger = create_rich_logger()

ARGUMENTS = (
    ("R", "rainbow", "rainbow line meter for retrieval detection"),
    ("t", "tag", "keep only tagged fishes"),
    ("c", "coffee", "drink coffee if stamina is low during a fish fight"),
    ("a", "alcohol", "drink alcohol before keeping the fish"),
    ("r", "refill", "consume tea and carrot if hunger or comfort is low"),
    ("H", "harvest", "harvest baits before casting the rod"),
    ("L", "lure", "change current lure with a random one, mode: spin"),
    ("m", "mouse", "move mouse randomly before casting the rod"),
    ("P", "pause", "pause the script before casting the rod occasionally"),
    ("RC", "random-cast", "do a redundant rod cast randomly"),
    ("SC", "skip-cast", "skip the first rod cast"),
    ("l", "lift", "lift the tackle constantly during a fish fight"),
    ("e", "electro", "enable electric mode for Electro Raptor series reel"),
    ("FB", "friction-brake", "adjust friction brake automatically"),
    ("GR", "gear-ratio", "switch the gear ratio after the retrieval timed out"),
    ("b", "bite", "save a screenshot in screenshots/ before rod cast (for bite spot)"),
    ("s", "screenshot", "save a screenshot in screenshots/ after you caught a fish"),
    ("d", "data", "save fishing data in /logs"),
    ("E", "email", "send email noticication after the script stop"),
    ("M", "miaotixing", "send miaotixing notification after the script stop"),
    ("D", "discord", "send Discord notification after the script stop"),
    ("S", "shutdown", "shutdown computer after the script stop"),
    ("SO", "signout", "sign out instead of closing the game"),
    ("SR", "spod-rod", "recast spod rod"),
    ("DM", "dry-mix", "enable dry mix refill, mode: bottom"),
    ("GB", "groundbait", "enable groundbait refill, mode: bottom"),
    ("PVA", "pva", "enable pva refill, mode: bottom"),
)

LOGO = """
██████╗ ███████╗██╗  ██╗███████╗
██╔══██╗██╔════╝██║  ██║██╔════╝
██████╔╝█████╗  ███████║███████╗
██╔══██╗██╔══╝  ╚════██║╚════██║
██║  ██║██║          ██║███████║
╚═╝  ╚═╝╚═╝          ╚═╝╚══════╝"""
GITHUB_LINK = "GitHub: https://github.com/dereklee0310/RussianFishing4Script"
DISCORD_LINK = "Discord: https://discord.gg/BZQWQnAMbY"
# https://patorjk.com/software/taag/#p=testall&f=3D-ASCII&t=RF4S%0A, ANSI Shadow

ROOT = Path(__file__).resolve().parents[1]


class RF4SApp(App):
    """Main application class for Russian Fishing 4 automation.

    This class orchestrates the entire automation process, from parsing command-line
    arguments to configuring the environment and executing the fishing routine.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments
        args (Namespace): Parsed command-line arguments
        window (Window): Game window controller instance
        player (Player): Player instance for fishing automation
    """

    def __init__(self):
        """Initialize the application.

        Loads configuration, parses command-line arguments, and sets up the environment.
        """
        super().__init__()
        self.parser = self.create_parser()
        # Parser will use the last occurence if the arguments are duplicated,
        # so put argv at the end to overwrite launch options.
        self.args = self.parser.parse_args(
            shlex.split(self.cfg.SCRIPT.LAUNCH_OPTIONS) + sys.argv[1:]
        )
        if not self.is_args_valid(self.args):
            sys.exit(1)
        self.cfg.merge_from_other_cfg(CN({"ARGS": config.dict_to_cfg(vars(self.args))}))

    def create_parser(self) -> ArgumentParser:
        """Configure the argument parser with all supported command-line options.

        :return: Configured ArgumentParser instance with all options and flags.
        :rtype: ArgumentParser
        """
        parser = ArgumentParser(description="Start AFK script for Russian Fishing 4")
        parser.add_argument("opts", nargs="*", help="overwrite configuration")

        for argument in ARGUMENTS:
            flag1 = f"-{argument[0]}"
            flag2 = f"--{argument[1]}"
            help_message = argument[2]
            parser.add_argument(flag1, flag2, action="s


# === tools\move.py ===
"""Movement automation for Russian Fishing 4 using keyboard controls.

This module automates character movement in Russian Fishing 4 by simulating W key presses.
Supports toggling movement state and includes optional Shift key integration for sprinting.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import sys
from pathlib import Path

import pyautogui as pag
from pynput import keyboard
from rich import print

sys.path.append(".")
from rf4s import utils
from rf4s.app.app import ToolApp
from rf4s.config.config import print_cfg

ROOT = Path(__file__).resolve().parents[1]


class MoveApp(ToolApp):
    """Main controller for movement automation in Russian Fishing 4.

    Manages configuration, keyboard event listeners, and W/Shift key simulation.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        w_key_pressed (bool): Tracks current state of W key simulation.
    """

    def __init__(self):
        """Initialize configuration, CLI arguments, and game window.

        1. Format keybinds in cfg node.
        2. Create w key flag.
        """
        super().__init__()

        # Format key
        self.cfg.defrost()
        self.cfg.ARGS.PAUSE_KEY = f"'{self.cfg.ARGS.PAUSE_KEY}'"
        self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
        self.cfg.freeze()
        print_cfg(self.cfg.ARGS)

        self.w_key_pressed = True

    def create_parser(self) -> argparse.ArgumentParser:
        """Create an argument parser for the application.

        :return: Configured argument parser.
        :rtype: argparse.ArgumentParser
        """
        parser = argparse.ArgumentParser(
            description="Moving the game character forward with W key."
        )
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-s", "--shift", action="store_true", help="Hold Shift key while moving"
        )
        parser.add_argument(
            "-p",
            "--pause-key",
            default="w",
            type=str,
            help="key to pause the script, w by default",
            metavar="KEY",
        )
        parser.add_argument(
            "-q",
            "--quit-key",
            default="s",
            type=str,
            help="key to quit the script, s by default",
            metavar="KEY",
        )
        return parser

    def _on_release(self, key: keyboard.KeyCode) -> None:
        """Handle keyboard release events for script control.

        :param key: Key released by the user.
        :type key: keyboard.KeyCode
        """
        if str(key).lower() == self.cfg.ARGS.QUIT_KEY:
            sys.exit()
        elif str(key).lower() == self.cfg.ARGS.PAUSE_KEY:
            if self.w_key_pressed:
                self.w_key_pressed = False
                return
            pag.keyDown("w")
            self.w_key_pressed = True

    @utils.release_keys_after(arrow_keys=True)
    def _start(self) -> None:
        """Start W key automation and keyboard listener."""
        print(
            f"Press {self.cfg.ARGS.PAUSE_KEY[1:-1]} to pause, "
            f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
        )
        if self.cfg.ARGS.SHIFT:
            pag.keyDown("shift")
        pag.keyDown("w")
        # Blocking listener loop
        with keyboard.Listener(on_release=self._on_release) as listener:
            listener.join()


if __name__ == "__main__":
    MoveApp().start()

