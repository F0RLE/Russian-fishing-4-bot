

# === all_content_Version3.py ===
import os

IMAGE_EXTENSIONS = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.webp', '.tiff'}
VIDEO_EXTENSIONS = {'.mp4', '.avi', '.mov', '.mkv', '.webm', '.flv', '.wmv'}
AUDIO_EXTENSIONS = {'.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a'}
CACHE_EXTENSIONS = {'.pyc'}
BINARY_EXTENSIONS = IMAGE_EXTENSIONS | VIDEO_EXTENSIONS | AUDIO_EXTENSIONS | {
    '.exe', '.dll', '.so', '.bin', '.dat', '.zip', '.rar', '.7z', '.tar', '.gz', '.pdf'
}

def remove_bom(text):
    if text.startswith('\ufeff'):
        return text[1:]
    return text

def safe_read_file(path, max_chars=5000):
    try:
        with open(path, encoding="utf-8", errors="replace") as f:
            content = f.read(max_chars)
            return remove_bom(content)
    except Exception as e:
        try:
            with open(path, encoding="latin1") as f:
                content = f.read(max_chars)
                return remove_bom(content)
        except Exception as e2:
            return f"<не удалось прочитать: {e2}>"

def file_type_note(name):
    ext = os.path.splitext(name)[1].lower()
    if ext in CACHE_EXTENSIONS:
        return "Это кэш Python (pyc-файл)"
    if ext in IMAGE_EXTENSIONS:
        return "Это картинка"
    if ext in VIDEO_EXTENSIONS:
        return "Это видео"
    if ext in AUDIO_EXTENSIONS:
        return "Это аудиофайл"
    if ext in BINARY_EXTENSIONS:
        return "Это бинарный файл"
    return None

def collect_all_content(start_path, out_path="all_content.txt", max_chars=5000):
    with open(out_path, "w", encoding="utf-8") as out:
        for root, dirs, files in os.walk(start_path):
            for name in files:
                file_path = os.path.join(root, name)
                rel_path = os.path.relpath(file_path, start_path)
                if rel_path == out_path:
                    continue  # не добавлять сам файл all_content.txt
                out.write(f"\n\n# === {rel_path} ===\n")
                note = file_type_note(name)
                if note:
                    out.write(note + "\n")
                else:
                    content = safe_read_file(file_path, max_chars)
                    out.write(content)
                    out.write("\n")
    print(f"Готово! Всё содержимое помещено в {out_path}")

if __name__ == "__main__":
    collect_all_content(".")


# === config.yaml ===
VERSION: "0.4.0"

SCRIPT:
  LANGUAGE: "ru"
  LAUNCH_OPTIONS: ""
  SMTP_VERIFICATION: true
  IMAGE_VERIFICATION: true
  SNAG_DETECTION: true
  SPOOLING_DETECTION: true
  RANDOM_ROD_SELECTION: true
  SPOOL_CONFIDENCE: 0.98
  SPOD_ROD_RECAST_DELAY: 1800
  LURE_CHANGE_DELAY: 1800
  ALARM_SOUND: "./static/sound/guitar.wav"

KEY:
  TEA: -1
  CARROT: -1
  BOTTOM_RODS: [1, 2, 3]
  COFFEE: 4
  DIGGING_TOOL: 5
  ALCOHOL: 6
  MAIN_ROD: 1
  SPOD_ROD: 7
  QUIT: "CTRL-C"

STAT:
  ENERGY_THRESHOLD: 0.74
  HUNGER_THRESHOLD: 0.5
  COMFORT_THRESHOLD: 0.51
  TEA_DELAY: 300
  COFFEE_LIMIT: 10
  COFFEE_PER_DRINK: 1
  ALCOHOL_DELAY: 900
  ALCOHOL_PER_DRINK: 1

FRICTION_BRAKE:
  INITIAL: 29
  MAX: 30
  START_DELAY: 2.0
  INCREASE_DELAY: 1.0
  SENSITIVITY: "medium"

KEEPNET:
  CAPACITY: 100
  DELAY: 0.0
  FULL_ACTION: "quit"
  RELEASE_WHITELIST:
    - "mackerel"
    - "saithe"
    - "herring"
    - "squid"
    - "scallop"
    - "mussel"
  BLACKLIST: []

NOTIFICATION:
  EMAIL: "email@example.com"
  PASSWORD: "password"
  SMTP_SERVER: "smtp.gmail.com"
  MIAO_CODE: "example"

PAUSE:
  DELAY: 1800
  DURATION: 600

PROFILE:
  SPIN:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "normal"
  SPIN_WITH_PAUSE:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 1.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 3.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "pause"
  SPIN_WITH_LIFT:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 1.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "lift"
  BOTTOM:
    MODE: "bottom"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    POST_ACCELERATION: "off"
    CHECK_DELAY: 32.0
    CHECK_MISS_LIMIT: 16
  PIRK:
    MODE: "pirk"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  PIRK_WITH_RETRIEVAL:
    MODE: "pirk"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 0.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  WAKEY_RIG:
    MODE: "pirk"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 45.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: true
    SHIFT: false
    PIRK_DURATION: 1.5
    PIRK_DELAY: 4.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR:
    MODE: "elevator"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR_WITH_DROP:
    MODE: "elevator"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  TELESCOPIC:
    MODE: "telescopic"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.75  # Увеличьте до 0.75-0.80 (было 0.68)
    CHECK_DELAY: 1.5         # Увеличьте до 1.5 (было 1.0)
    PULL_DELAY: 0.7          # Увеличьте до 0.7 (было 0.5)
    DRIFT_TIMEOUT: 45.0      # Увеличьте до 45-60 (было 16.0)
    CAMERA_SHAPE: "rectangle"  # Измените на "rectangle" (было "square")
  BOLOGNESE:
    MODE: "bolognese"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 32.0
    CAMERA_SHAPE: "square"
    PROFILE:
  MAX_udochka:
    MODE: "telescopic"
    LAUNCH_OPTIONS: "-r -H"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.80  # Повышенная чувствительность
    CHECK_DELAY: 2.0         # Дольше проверяем поплавок
    PULL_DELAY: 0.8          # Медленнее подсекаем
    DRIFT_TIMEOUT: 60.0      # Дольше ждем поклевку
    CAMERA_SHAPE: "rectangle" # Прямоугольная область для наблюдения



# === LICENSE ===
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy,


# === README.md ===
**[[中文版]][README]**
<div align="center">

![RF4S][RF4S logo]
<h1 align="center">RF4S: Russian Fishing 4 Script</h1>

**A simple fishing bot for Russian Fishing 4, supporting spin, bottom, marine, and float fishing.**

<a target="_blank" href="https://opensource.org/license/gpl-3-0" style="background:none">
    <img src="https://img.shields.io/badge/License-GPLv3-blue.svg" style="height: 22px;" />
</a>
<a target="_blank" href="https://discord.gg/BZQWQnAMbY" style="background:none">
    <img src="https://img.shields.io/badge/discord-join-rf44.svg?labelColor=191937&color=6F6FF7&logo=discord" style="height: 22px;" />
</a>
<a target="_blank" href="http://makeapullrequest.com" style="background:none">
    <img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat" style="height: 22px;" />
</a>
<a target="_blank" href="https://github.com/pylint-dev/pylint" style="background:none">
    <img src="https://img.shields.io/badge/linting-pylint-yellowgreen" style="height: 22px;" />
</a>
<a target="_blank" href="https://github.com/psf/black" style="background:none">
    <img src="https://img.shields.io/badge/code%20style-black-000000.svg" style="height: 22px;" />
</a>
<!-- <a target="_blank" href="link_to_docs, tbd" style="background:none">
    <img src="https://img.shields.io/badge/docs-%23BE1B55" style="height: 22px;" />
</a> -->  

![Python badge][Python badge]
![Windows badge][Windows badge]

</div>

> [!TIP]
> Join the [Discord server][Discord] if you want to suggest new features, report bugs or get help on how to use the script.


## Getting Started  
### Prerequisites
Download and install **[Python 3.12][Python]**.  

> [!IMPORTANT] 
> Ensure Python is added to `PATH` during installation.

> [!WARNING] 
> Python 3.13+ is not supported.

### Installation
1. Open cmd or PowerShell (not Python)
2. Clone the repository and navigate into the project directory:
```
git clone https://github.com/dereklee0310/RussianFishing4Script.git
cd RussianFishing4Script
```
> [!TIP]
> Or, **[download this repository][Download]** and unzip it if you don't have `git` installed on your pc.  
> Then run open cmd or PowerShell (not Python) and navigate into the project directory:
> ```
> cd "path\to\the\project"
> ```
> `path\to\the\project` should look something like `...\...\RussianFishing4Script-main`

> [!WARNING] 
> The download path cannot contain non-English characters.

### Dependencies
In cmd or PowerShell, type the command below to install required packages and create a default configuration file:
```
.\setup.bat
```

> [!TIP] 
> Create a virtual environment to avoid version conflicts if you already have Python installed.

### Setup
- Enable **[Mouse ClickLock][Clicklock]** in Windows mouse settings and set the time before locking to "Long".
- Make sure your game language is the same as the setting in `config.yaml` (default is `EN`).
- Set interface scale to `1x`.
- Set display mode to `window mode` or `borderless windowed`.
- Make sure your reel is fully loaded, or equip a rainbow line and use `-R` flag (see **[configuration guide][Configuration guide]**).
- Add tea, carrot, and coffee to your **[favorites][Favorite food]** if you want to use `-r` or `-c` flag.
- To use a feature that replaces an item for you, you must add items to your **[favorites][Favorite lure]** for replacement.

## Usage
### Before you start...
- Move your character to the fishing spot before running the script
- For Spin/Marine/Float/Wakey Rig Fishing: Pick up the rod you want to use.
- For Bottom Fishing:
    - Add tackles to quick selection slots.
    - Cast them and place them nearby so the bot can access them via shortcuts (1 ~ 3).
> [!NOTE]
> Currently, only bottom fishing mode support multiple rods.

### Let's Run it!
Run the script with default configuration:
```
python tools\main.py
```
For more advanced usage, see **[configuration guide][Configuration guide]**.
> [!IMPORTANT]
> If you want to run it in a new terminal window, don't forget to navigate into the project directory:
> ```
> cd "path\to\the\project"
> python tools\main.py
> ```

> [!NOTE]
> The script stops once the keepnet is full. Stop it manually by typing `Ctrl-C` in your terminal. 

## Tools
### Craft Items
**Craft items until materials run out (press `Ctrl-C` to quit):**
```
python tools\craft.py
```
**Craft 10 items:**
```
python tools\craft.py -n 10
```
**Discard crafted groundbaits:**
```
python tools\craft.py -d
```
> [!IMPORTANT]
> Select materials before you run the script.
### Harvest Baits
**Harvest baits (press `Ctrl-C` to quit):**
```
python tools\harvest.py
```
**Replenish hunger and comfort while harvesting:**
```
python tools\harvest.py -r
```
**Open control panel while waiting (reduces power consumption):**
```
python tools\harvest.py -s
```
### Toggle moving forward
**Toggle Auto-Move (`W`to pause, `S` to quit):**
```
python tools\move.py
```
**Move while holding Shift:**
```
python tools\move.py -s
```

### Automate Friction Brake
**Automate Fric


# === requirements.txt ===
pyautogui==0.9.54
keyboard==0.13.5
pywin32==306
# configparser==6.0.0
pynput==1.7.6
opencv-python==4.8.0.76
Pillow==10.1.0
PyScreeze==0.1.29
python-dotenv==1.0.1
matplotlib==3.8.0
playsound==1.2.2 # downgrade to avoid bug
pyyaml==6.0.2
yacs==0.1.8
rich==13.9.4
bump-my-version==0.32.1
# reference: https://stackoverflow.com/questions/68704443/python-playsound-error-261-for-command-the-driver-cannot-recognize-the-specifie



# === setup.bat ===
@echo off

echo This might take a while...

@REM for playsound module: https://github.com/TaylorSMarks/playsound/issues/145
python -m pip install wheel setuptools pip --upgrade
python -m pip install -r requirements.txt

if not exist ".\screenshots" mkdir screenshots
if not exist ".\logs" mkdir logs
if not exist ".\config.yaml" copy ".\rf4s\config\config.yaml" ".\config.yaml"


# === docs\en\CHANGELOG.md ===
**[[中文版]][CHANGELOG]**

## 0.4.2 (2025-04-07)
- Fixed a bug where the friction brake threshold was not being applied correctly

- Fixed unexpected termination due to running out of fillet when using pirk/elevator mode


## 0.4.1 (2025-03-30)

- Fixed a bug that left/right trolling mode doesn't work properly

- Fixed an issue where electro mode doesn't work and compatible with `-g` flag

- Fixed broken lure detection mechanism

- Fixed a bug that pause is hard to trigger when using "toggle moving foward" tool 

- Added missing `POST_ACCELERATION` setting to `BOLOGNESE` mode

- Tools now display config before running

- Improved configuration guide

## 0.4.0 (2025-03-16)

- Fixed a bug that the casting power level cannot be set to a value other than 1 or 5.

- Added `RETRIEVAL_TIMEOUT` to `SPIN` mode, allowing the script fall back to normal
  retrieval after retrieval with lift/pause timed out.

## 0.3.0 (2025-03-16)

- Reduced the sensitivity of lure break detection to avoid abnormal termination in the RU version.

- Added a new `KEEPNET.BLACKLIST` setting, blacklisted fish will always be released.

- Added a new `SHIFT` setting to `PIRK` mode, allowing users to hold shift while pirking.

- Increased check frequency for better user experience.

- Fixed a bug that the auto-friction-brake is not working properly.

- Updated READMEs


## 0.2.1 (2025-03-08)

- Fixed a bug that auto-friction-brake, snag detection, and spooling detection are always
  disabled even the correct flags are used.

## 0.2.0 (2025-03-07)

- Fixed a bug that `-c` feature is not working properly.

-  Added a `DEPTH_ADJUST_DURATION` setting to the `pirk` fishing mode to allow the user to set the duration of tightening the fishing line after opening the reel to adjust the depth of the lure.

## 0.1.0 (2025-03-06)

- New config system, bolognese mode, trolling mode, window mode support, and more.

[CHANGELOG]: /docs/zh-TW/CHANGELOG.md


# === docs\en\CONFIGURATION.md ===
**[[中文版]][Chinese configuration guide]**
# Configuration Guide
## Using Launch Options
You can use launch options to enable one or more features at startup.
### Display Help Message
```
python tools\main.py -h
```
### Help Message
```
usage: main.py [-h] [-c] [-A] [-r] [-H] [-g] [-f] [-l] [-C] [-o] [-L] [-x] [-X] [-b] [-S] [-e] [-P] [-M] [-s] [-so]
               [-gb] [-dm] [-pva] [-E] [-a | -m] [-d | -R] [-p PID | -N PROFILE_NAME] [-n FISH_COUNT] [-t [DURATION]]
               [-T [DIRECTION]] [-bl [ACTION]]
               [opts ...]

Start AFK script for Russian Fishing 4

positional arguments:
  opts                  overwrite configuration

options:
  -h, --help            show this help message and exit
  -c, --coffee          drink coffee if stamina is low
  -A, --alcohol         drink alcohol before keeping the fish regularly
  -r, --refill          refill hunger and comfort by consuming tea and carrot
  -H, --harvest         harvest baits before casting
  -g, --gear_ratio      switch the gear ratio after the retrieval timed out
  -f, --friction_brake  enable auto friction brake
  -l, --lift            lift the tackle constantly while pulling a fish
  -C, --skip_cast       Immediately start retrieving for the first fish
  -o, --spod_rod        recast spod rod regularly
  -L, --lure            change current lure with a random one regularly, mode: spin
  -x, --mouse           move mouse randomly before casting the rod
  -X, --pause           pause the script before casting the rod regularly
  -b, --bite            take a screenshot after casting in screenshots/ (for fish spot)
  -S, --screenshot      take a screenshot of every fish you caught in screenshots/
  -e, --email           send email noticication after the script stop
  -P, --plot            save fishing data in /logs
  -M, --miaotixing      send miaotixing notification after the script stop
  -s, --shutdown        shutdown computer after the script stop
  -so, --signout        Sign out instead of closing the game
  -gb, --groundbait     enable groundbait refill, mode: bottom
  -dm, --dry_mix        enable dry mix refill, mode: bottom
  -pva, --pva           enable pva refill, mode: bottom
  -E, --electro         enable electric mode for Electro Raptor series reel
  -a, --all             keep all captured fishes, used by default
  -m, --marked          keep only the marked fishes
  -d, --default-spool   use default spool icon for retrieval detection, used by default
  -R, --rainbow-line    use rainbow line meter for retrieval detection
  -p PID, --pid PID     id of the profile you want to use
  -N PROFILE_NAME, --pname PROFILE_NAME
                        name of the profile you want to use
  -n FISH_COUNT, --fishes-in-keepnet FISH_COUNT
                        number of fishes in your keepnet, 0 by default
  -t [DURATION], --boat-ticket [DURATION]
                        enable boat ticket auto renewal, DURATION: '1', '2', '3' or '5', will use a 5 hour ticket if
                        duration is not specified
  -T [DIRECTION], --trolling [DIRECTION]
                        enable trolling mode, DIRECTION: 'forward',''left', or 'right', will only move forward by
                        press 'j' if direction is not specified
  -bl [ACTION], --broken-lure [ACTION]
                        enable broken lure auto-replace, ACTION: 'replace' or 'alarm', will replace the broken lure if
                        action is not specified
```
> [!TIP]
> Other tools like `craft.py` or `move.py` also support `-h` for displaying help messages. 

### Examples
**Set the number of fishes in the keepnet to 32 (68 fishes to catch):**
```
python tools\main.py -n 32
```
**Select profile 3, drink the coffee while battling against fish, and send an email to yourself when it stops:**
```
python tools\main.py -p 3 --c --email
```
**Consume carrots, tea, and coffee to replenish player stats, and harvest baits before casting if possible.:**
```
python tools\main.py -rcH
```
**Recast spod rod regularly and refill dry mix if possible:**
```
python tools\main.py -o -dm
```


## Configuration
### Configure Settings
Edit your settings in `config.yaml`, changes will be applied when you run the script again.  
For details on each settings, see [configuration references](#configuration-references).

### Add a New Profile
If you want to add a custom profile for your use case, copy a existing profile from the default configuration file, edit it, and add it back to the `PROFILE` section.

Here we add a new profile called `YOUR_NEW_PROFILE`, it would pop up in the profile list when you run the script again:
```yaml
PROFILE:
  SPIN:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "normal"
            .
            .
            .
  YOUR_NEW_PROFILE:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    TIGHTE


# === docs\zh-TW\CHANGELOG.md ===
**[[English Version]][CHANGELOG]**

## 0.4.2 (2025-04-07)
- 修復摩擦制動閾值設定未正確生效的問題

- 修正使用打狀態/電梯模式時，當魚餌耗盡導致腳本意外終止的問題


## 0.4.1 (2025-03-30)
- 修復左/右拖釣模式無法正常運作的錯誤

- 修復電輪模式無法運作及與 `-g` 相容性的問題

- 修復損壞的誘餌偵測機制

- 修復使用「切換前進」工具時暫停功能難以觸發的問題

- 為 `BOLOGNESE` 模式新增遺漏的 `POST_ACCELERATION` 設定

- 工具現在會在執行前顯示設定

- 改進設定指南

## 0.4.0 (2025-03-16)

- 修復了拋竿力度無法設定的問題

- 為 `SPIN` 模式新增 `RETRIEVAL_TIMEOUT` 設定, 讓腳本在打狀態超時後切換至正常收線模式

## 0.3.0 (2025-03-16)

- 降低擬餌斷裂檢測的靈敏度，避免異常終止問題
- 新增 `KEEPNET.BLACKLIST` 設定項，黑名單中的魚類將始終被放生
- 為 `PIRK` 模式新增 `SHIFT` 設定，允許用戶在使用 pirking 時按住 shift 鍵操作
- 提升檢測頻率以優化用戶體驗
- 修復自動摩擦制動器無法正常運作的 bug
- 更新 README 文件

## 0.2.1 (2025-03-08)

- 修復了即使使用正確參數，自動摩擦制動/卡鉤檢測/捲線檢測仍被強制禁用的 bug

## 0.2.0 (2025-03-07)

- 修復 `-c` 功能異常問題
- 為 `pirk` 釣魚模式新增 `DEPTH_ADJUST_DURATION` 設定項，允許用戶設置開捲後收緊釣線調整誘餌深度的持續時間

## 0.1.0 (2025-03-06)

- 全新配置系統，新增磯釣模式、拖釣模式、視窗模式支援等多項功能

[CHANGELOG]: /docs/en/CHANGELOG.md


# === docs\zh-TW\CONFIGURATION.md ===
作者很懶，直接把丟給DeepSeek R1生成🤗

**[[English Version]][Configuration guide]**

# 配置指南  

## 使用啟動參數  
可通過啟動參數啟用一項或多項功能。  

### 顯示幫助信息  
```  
python tools\main.py -h  
```  

### 幫助信息說明  
```  
usage: main.py [-h] [-c] [-A] [-r] [-H] [-g] [-f] [-l] [-C] [-o] [-L] [-x] [-X] [-b] [-S] [-e] [-P] [-M] [-s] [-so]  
               [-gb] [-dm] [-pva] [-E] [-a | -m] [-d | -R] [-p PID | -N PROFILE_NAME] [-n FISH_COUNT] [-t [DURATION]]  
               [-T [DIRECTION]] [-bl [ACTION]]  
               [opts ...]  

啟動《俄羅斯釣魚4》自動腳本  

位置參數:  
  opts                  覆寫配置文件參數  

選項:  
  -h, --help            顯示幫助信息  
  -c, --coffee          體力不足時飲用咖啡  
  -A, --alcohol         定期飲用酒精飲料後存魚  
  -r, --refill          通過茶和胡蘿蔔補充飢餓與舒適度  
  -H, --harvest         拋竿前自動收餌  
  -g, --gear_ratio      超時後切換齒輪比  
  -f, --friction_brake  啟用自動摩擦剎車  
  -l, --lift            遛魚時持續提竿  
  -C, --skip_cast       跳過首次拋竿直接收線  
  -o, --spod_rod        定期重拋餌料竿  
  -L, --lure            定期隨機更換擬餌（僅路亞模式）  
  -x, --mouse           拋竿前隨機移動鼠標  
  -X, --pause           定期暫停腳本運行  
  -b, --bite            拋竿後截圖保存至screenshots/（用於魚點分析）  
  -S, --screenshot      為每條捕獲的魚截圖保存  
  -e, --email           腳本停止後發送郵件通知  
  -P, --plot            在/logs目錄保存釣魚數據  
  -M, --miaotixing      腳本停止後發送喵提醒通知  
  -s, --shutdown        腳本停止後關閉電腦  
  -so, --signout        退出遊戲而非關閉  
  -gb, --groundbait     補充底餌（僅底釣模式）  
  -dm, --dry_mix        補充乾混合餌（僅底釣模式）  
  -pva, --pva           補充PVA餌（僅底釣模式）  
  -E, --electro         為Electro Raptor系列捲線器啟用電動模式  
  -a, --all             保留所有魚獲（默認）  
  -m, --marked          僅保留標記魚獲  
  -d, --default-spool   使用默認線軸圖標檢測收線（默認）  
  -R, --rainbow-line    使用彩虹線計量器檢測收線  
  -p PID, --pid PID     指定配置檔ID  
  -N PROFILE_NAME, --pname PROFILE_NAME  
                        指定配置檔名稱  
  -n FISH_COUNT, --fishes-in-keepnet FISH_COUNT  
                        魚護當前魚量（默認0）  
  -t [DURATION], --boat-ticket [DURATION]  
                        自動續費船票，時長：'1','2','3'或'5'小時（默認5小時）  
  -T [DIRECTION], --trolling [DIRECTION]  
                        啟用拖釣模式，方向：'forward','left','right'（默認按'j'前進）  
  -bl [ACTION], --broken-lure [ACTION]  
                        斷餌自動處理，操作：'replace'或'alarm'（默認更換）  
```  

> [!TIP]  
> 其他工具如`craft.py`或`move.py`也支持`-h`參數顯示幫助信息。  

### 使用示例  
**設置魚護當前魚量為32條（需捕獲68條）：**  
```  
python tools\main.py -n 32  
```  

**使用3號配置檔，遛魚時飲用咖啡，停止後發送郵件：**  
```  
python tools\main.py -p 3 --c --email  
```  

**自動補充體力/飢餓/舒適度，拋竿前收餌：**  
```  
python tools\main.py -rcH  
```  

**定期重拋餌料竿並補充乾混合餌：**  
```  
python tools\main.py -o -dm  
```  

## 配置文件  
### 修改設置  
編輯`config.yaml`後重新運行腳本即可生效。  
各項參數詳解參見[配置參數說明](#配置參數說明)。  

### 添加新配置檔  
1. 複製現有配置檔結構  
2. 修改參數後添加至`PROFILE`段落  

示例添加名為`YOUR_NEW_PROFILE`的路亞配置：  
```yaml  
PROFILE:  
  SPIN:   
    MODE: "spin"  
    CAST_POWER_LEVEL: 5.0  
    CAST_DELAY: 6.0  
    ...  
  
  YOUR_NEW_PROFILE:  
    MODE: "spin"  
    CAST_POWER_LEVEL: 5.0  
    CAST_DELAY: 4.0  # 縮短拋竿延遲  
    PRE_ACCELERATION: True  # 啟用預加速  
    ...  
```  

> [!IMPORTANT]  
> - 配置檔名稱需唯一  
> - 嚴格保持縮進格式  
> - `MODE`需為`spin`/`bottom`/`pirk`/`elevator`/`telescopic`/`bolognese`  

### 臨時覆寫配置  
無需修改文件，直接通過命令覆寫參數：  
```  
python tools\main.py SCRIPT.LANGUAGE "ru"  # 臨時設置腳本語言為俄語  
```  

### 雙竿拖釣模式  
組合底釣配置與`-T`參數實現：  
```  
python tools\main.py -T KEY.BOTTOM_RODS "1, 2"  # 指定使用1、2號快捷鍵位  
```  


## 配置參數說明  
```python  
"""YACS默認配置節點"""  

from yacs.config import CfgNode as CN  

_C = CN()  
_C.VERSION = "0.0.0"  

# --------------------------------- 通用設置 -------------------------------- #  
_C.SCRIPT = CN()  
_C.SCRIPT.LANGUAGE = "en" # 腳本語言: en/ru/zh-TW/zh-CN  
_C.SCRIPT.LAUNCH_OPTIONS = ""  # 默認啟動參數，如"-r -c -H"  
_C.SCRIPT.SMTP_VERIFICATION = True  # SMTP驗證  
_C.SCRIPT.IMAGE_VERIFICATION = True  # 圖像驗證  
_C.SCRIPT.SNAG_DETECTION = True  # 掛底檢測  
_C.SCRIPT.SPOOLING_DETECTION = True  # 線軸檢測  
_C.SCRIPT.RANDOM_ROD_SELECTION = True  # 底釣隨機選竿  
_C.SCRIPT.SPOOL_CONFIDENCE = 0.98  # 線軸檢測敏感度（值越低越敏感）  
_C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800  # 餌料竿重拋間隔（秒）  
_C.SCRIPT.LURE_CHANGE_DELAY = 1800  # 擬餌更換間隔（秒）  
_C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # 提示音文件路徑  

# --------------------------------- 快捷鍵設置 ------------------------------ #  
_C.KEY = CN()  
_C.KEY.TEA = -1  # 茶快捷鍵（-1使用快捷菜單）  
_C.KEY.CARROT = -1  # 胡蘿蔔快捷鍵  
_C.KEY.BOTTOM_RODS = (1, 2, 3)  # 底釣竿快捷鍵位  
_C.KEY.COFFEE = 4  # 咖啡快捷鍵  
_C.KEY.DIGGING_TOOL = 5  # 挖餌工具快捷鍵  
_C.KEY.ALCOHOL = 6  # 酒精飲品快捷鍵  
_C.KEY.MAIN_ROD = 1  # 主釣竿快捷鍵  
_C.KEY.SPOD_ROD = 7  # 餌料竿快捷鍵  
_C.KEY.QUIT = "CTRL-C"  # 退出快捷鍵  

# --------------------------------- 角色狀態 -------------------------------- #  
_C.STAT = CN()  
_C.STAT.ENERGY_THRESHOLD = 0.74  # 喝咖啡/收餌體力閾值  
_C.STAT.HUNGER_THRESHOLD = 0.5  # 食用胡蘿蔔飢餓閾值  
_C.STAT.COMFORT_THRESHOLD = 0.51  # 飲茶舒適度閾值  
_C.STAT.TEA_DELAY = 300  # 飲茶間隔（秒）  
_C.STAT.COFFEE_LIMIT = 10  # 單次遛魚最大咖啡飲用量  
_C.STAT.COFFEE_PER_DRINK = 1  # 單次飲用咖啡量  
_C.STAT.ALCOHOL_DELAY = 900  # 飲酒間隔（秒）  
_C.STAT.ALCOHOL_PER_DRINK = 1  # 單次飲酒量  

# ----------------------------- 摩擦剎車設置（需-f參數）----------------------- #  


# === docs\zh-TW\README.md ===
作者很懶，直接把丟給DeepSeek R1生成🤗

**[[英文版]][README]**
<div align="center">

![RF4S][RF4S logo]
<h1 align="center">RF4S: 俄羅斯釣魚4腳本</h1>

**一個簡易的《俄羅斯釣魚4》輔助腳本，支持旋轉釣、底釣、海釣和浮標釣。**

<a target="_blank" href="https://opensource.org/license/gpl-3-0" style="background:none">
    <img src="https://img.shields.io/badge/License-GPLv3-blue.svg" style="height: 22px;" />
</a>
<a target="_blank" href="https://discord.gg/BZQWQnAMbY" style="background:none">
    <img src="https://img.shields.io/badge/discord-加入討論-rf44.svg?labelColor=191937&color=6F6FF7&logo=discord" style="height: 22px;" />
</a>
<a target="_blank" href="http://makeapullrequest.com" style="background:none">
    <img src="https://img.shields.io/badge/PRs-歡迎提交-brightgreen.svg?style=flat" style="height: 22px;" />
</a>
<a target="_blank" href="https://github.com/pylint-dev/pylint" style="background:none">
    <img src="https://img.shields.io/badge/代碼檢查-pylint-yellowgreen" style="height: 22px;" />
</a>
<a target="_blank" href="https://github.com/psf/black" style="background:none">
    <img src="https://img.shields.io/badge/代碼風格-black-000000.svg" style="height: 22px;" />
</a>
<!-- <a target="_blank" href="link_to_docs, tbd" style="background:none">
    <img src="https://img.shields.io/badge/文檔-%23BE1B55" style="height: 22px;" />
</a> -->  

![Python badge][Python badge]
![Windows badge][Windows badge]

</div>

> [!TIP]
> 如需建議新功能、報告錯誤或獲取腳本使用幫助，請加入 [Discord 伺服器][Discord]。


## 快速開始  
### 環境準備
下載並安裝 **[Python 3.12][Python]**。  

> [!IMPORTANT] 
> 安裝時請務必勾選 "將 Python 加入環境變數"

> [!WARNING] 
> 不支持 Python 3.13 及以上版本。

### 安裝步驟
1. 打開命令提示符 (cmd) 或 PowerShell
2. 克隆倉庫並進入項目目錄:
```
git clone https://github.com/dereklee0310/RussianFishing4Script.git
cd RussianFishing4Script
```
> [!TIP]
> 若未安裝 git，可直接 **[下載倉庫壓縮包][Download]** 並解壓縮
> 接著在 cmd 或 PowerShell 中執行下列命令以進入項目目錄:
> ```
> cd "path\to\the\project"
> ```
> `path\to\the\project` 看起來會像這樣 `...\...\RussianFishing4Script-main`

> [!WARNING] 
> 項目路徑請勿包含非英文字符。

### 依賴安裝
運行安裝腳本以安裝依賴包並生成默認配置文件:
```
.\setup.bat
```

> [!TIP] 
> 若已安裝 Python 其他版本，建議創建虛擬環境以避免依賴衝突。

### 遊戲設置
- 在 Windows 滑鼠設置中啟用 **[點擊鎖定][Clicklock]**，並將鎖定時間設為"長"。
- 確保遊戲語言與 `config.yaml` 中的設置一致(默認為 `EN`)。
- 將遊戲界面縮放設為 `1x`。
- 遊戲顯示模式設為 `窗口模式` 或 `無邊界窗口`。
- 確保魚線已完全纏繞，或使用彩虹線並添加 `-R` 參數 (請參閱 **[配置指南][Configuration guide]**)。
- 如需使用 `-r` 或 `-c` 參數，請將茶、胡蘿蔔和咖啡加入 **[快捷食物欄][Favorite food]**。
- 若需自動更換釣具，請將相關物品加入 **[快捷釣具欄][Favorite lure]**。

## 使用方法
### 開始前準備...
- 運行腳本前，請先將角色移動至釣點。
- 路亞/海釣/浮子/維基釣法: 手持對應魚竿。
- 底釣模式: 
    - 將釣組添加至快捷欄(1 ~ 3 號位)。
    - 拋竿後將釣組放置在角色附近，以便腳本通過快捷鍵操作。
> [!NOTE]
> 目前僅底釣模式支持多竿操作。

### 運行腳本！
使用默認配置運行腳本: 
```
python tools\main.py
```
高級用法請參閱 **[配置指南][Configuration guide]**。
> [!IMPORTANT]
> 若在新終端窗口中運行，請先切換至項目目錄: 
> ```
> cd "你的項目路徑\RussianFishing4Script"
> ```

> [!NOTE]
> 魚護滿後腳本會自動停止，手動停止請在終端中輸入 `Ctrl-C`。 

## 工具集
### 自動製作
**持續製作直至材料耗盡 (按 `Ctrl-C` 退出):**
```
python tools\craft.py
```
**製作 10 個物品:**
```
python tools\craft.py -n 10
```
**丟棄已製作的地面餌料:**
```
python tools\craft.py -d
```
> [!IMPORTANT]
> 運行前請先選中所需材料。
### 自動收餌
**持續收餌(按 `Ctrl-C` 退出):**
```
python tools\harvest.py
```
**收餌時自動補充飢餓和舒適度:**
```
python tools\harvest.py -r
```
**等待時打開控制面板(降低功耗):**
```
python tools\harvest.py -s
```
### 自動移動
**啟用自動前進(按 `W` 暫停，`S` 退出):**
```
python tools\move.py
```
**按住 Shift 移動:**
```
python tools\move.py -s
```

### 摩擦剎車自動化
**自動控制摩擦剎車(按 `G` 重置，`H` 退出):**
```
python tools\auto_friction_brake.py
```

### 釣具數值計算
**根據磨損顯示捲線器的真實阻力與前導線實際負載:**
```
python tools\calculate.py
```

## 配置說明
詳見 **[配置指南][Configuration guide]**。

## 故障排除
<details>
<summary>如何停止腳本？</summary>

- 在終端中輸入 `Ctrl-C`。 
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>無法停止腳本？</summary>

- 可能按鍵被鎖定(如 `Ctrl`、`Shift`、滑鼠按鍵等)，  
  再次按下對應按鍵解鎖後，輸入 `Ctrl-C` 即可。
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>卡在 128% 拋竿？</summary>

- 檢查遊戲語言與腳本語言設置是否一致
- 確保魚線已完全纏繞，或使用彩虹線並添加 `-R` 參數
</details>

<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>收線完成後未提竿？</summary>

- 確保魚線已完全纏繞，或使用彩虹線並添加 `-R` 參數
- 調整遊戲窗口大小
- 降低 `config.yaml` 中的 `SPOOL_CONFIDENCE` 數值
- 遠離光源或關閉船燈
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>腳本運行但無反應？</summary>

- 以管理員身份打開新終端窗口並重新運行
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->

## 更新日誌
詳見 **[更新日誌][Changelog]**。

## 許可協議
**[GNU General Public License version 3][License]**

## 參與貢獻
歡迎提交代碼、報告錯誤或提出新功能建議。

## 聯繫作者
dereklee0310@gmail.com 

[RF4S logo]: /static/readme/RF4S.png
[Python badge]: https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white
[Windows badge]: https://img.shields.io/badge/Windows-0078D6?style=for-the-badge&logo=windows&logoColor=white

[README]: /README.md
[Discord]: https://discord.gg/BZQWQnAMbY
[Python]: https://www.python.org/downloads/
[Download]: https://github.com/dereklee0310/RussianFishing4Script/archive/refs/


# === rf4s\exceptions.py ===
"""
A module reserved for exception classes.
"""


class FishHookedError(Exception):
    """A fish is hooked during a wrong routine."""


class FishCapturedError(Exception):
    """A fish is captured during a wrong routine."""


class LineAtEndError(Exception):
    """Fishing line is at the end during retrieval."""


class FishGotAwayError(Exception):
    """A hooked fish got away during pulling or retrieving stage."""


class LineSnaggedError(Exception):
    """Fishing line is snagged."""


class ItemNotFoundError(Exception):
    """Failed to find an available item for replacement."""


class LureBrokenError(Exception):
    """Lure is broken."""



# === rf4s\player.py ===
"""Module for Player class.

This module provides the main interface for automating fishing activities in a game.
It includes functionality for managing fishing loops, handling player stats, and
automating various fishing techniques.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import json
import logging
import os
import random
import smtplib
import sys
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from multiprocessing import Lock

# from email.mime.image import MIMEImage
from pathlib import Path
from time import sleep
from urllib import parse, request

import pyautogui as pag
from matplotlib import pyplot as plt
from matplotlib.ticker import MaxNLocator
from playsound import playsound
from pynput import keyboard
from rich import box, print
from rich.table import Table

from rf4s import exceptions, utils
from rf4s.component.friction_brake import FrictionBrake
from rf4s.component.tackle import Tackle
from rf4s.controller.detection import Detection
from rf4s.controller.timer import Timer
from rf4s.controller.window import Window

logger = logging.getLogger("rich")
random.seed(datetime.now().timestamp())

PRE_RETRIEVAL_DURATION = 0.5
PULL_OUT_DELAY = 3
DIG_DELAY = 5
DIG_TIMEOUT = 32
ANIMATION_DELAY = 1
TICKET_EXPIRE_DELAY = 16
DISCONNECTED_DELAY = 8
WEAR_TEXT_UPDATE_DELAY = 2
BOUND = 2
PUT_DOWN_DELAY = 4

SCREENSHOT_DELAY = 2

TROLLING_KEY = "j"

FORWARD = "w"
LEFT_KEY = "a"
RIGHT_KEY = "d"


class Player:
    """Main interface of fishing loops and stages.

    This class manages the automation of fishing activities, including casting,
    retrieving, and handling fish. It also handles player stats, equipment, and
    various in-game mechanics.

    :param cfg: Configuration object containing settings for the fishing process.
    :type cfg: Config
    :param window: Window object for managing the game window.
    :type window: Window
    """

    # pylint: disable=too-many-instance-attributes, disable=no-member
    # there are too many counters...
    # setting node's attributes will be merged on the fly

    def __init__(self, cfg, window: Window):
        """Initialize monitor, timer, and some trivial counters.

        :param cfg: Configuration object containing settings for the fishing process.
        :type cfg: Config
        :param window: Window object for managing the game window.
        :type window: Window
        """
        self.cfg = cfg
        self.window = window
        self.timer = Timer(cfg)
        self.detection = Detection(cfg, window)

        self.tackle_idx = 0
        if self.cfg.SELECTED.MODE == "bottom":
            self.num_tackle = len(self.cfg.KEY.BOTTOM_RODS)
        else:
            self.num_tackle = 1
        self.tackles = [
            Tackle(cfg, self.timer, self.detection) for _ in range(self.num_tackle)
        ]
        self.tackle = self.tackles[self.tackle_idx]

        self.friction_brake_lock = Lock()
        self.friction_brake = FrictionBrake(
            cfg, self.friction_brake_lock, self.detection
        )

        self.results = None

        self.cast_miss_count = 0
        self.keep_fish_count = 0
        self.marked_count = 0
        self.unmarked_count = 0

        self.tea_count = 0
        self.carrot_count = 0
        self.alcohol_count = 0
        self.cur_coffee_count = 0
        self.total_coffee_count = 0
        self.harvest_count = 0

        self.have_new_lure = True
        self.have_new_groundbait = True
        self.have_new_dry_mix = True
        self.have_new_pva = True

    def start_fishing(self) -> None:
        """Start the main fishing loop with the specified fishing strategy."""
        if self.cfg.ARGS.FRICTION_BRAKE:
            logger.info("Spawing new process, do not quit the script")
            self.friction_brake.monitor_process.start()

        if (
            self.cfg.SELECTED.MODE not in ("telescopic", "bottom")
            and not self.cfg.ARGS.SKIP_CAST
            and not self.detection.is_retrieval_finished()
        ):
            logger.critical(
                "The spool is not fully loaded, "
                "try moving your camera, "
                "changing your game window size or fishing line"
            )
            sys.exit(1)

        logger.info("Starting fishing mode: '%s'", self.cfg.SELECTED.MODE)
        self._start_trolling()
        getattr(self, f"start_{self.cfg.SELECTED.MODE}_mode")()

    # ---------------------------------------------------------------------------- #
    #                              main fishing loops                              #
    # ---------------------------------------------------------------------------- #
    def start_spin_mode(self) -> None:
        """Main spin fishing loop for 'spin' and 'spin_with_pause' modes."""
        skip_cast = self.cfg.ARGS.SKIP_CAST
        while True:
            if not skip_cast:
                self._refill_stats()
                self._harvest_baits(


# === rf4s\utils.py ===
"""Helper functions for automation scripts.

This module provides utility functions for common tasks such as mouse control,
keyboard input, and result display. It also includes decorators for managing
key and mouse states during automation.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import sys
from time import sleep

import pyautogui as pag
from pyscreeze import Box
from rich import print
from rich.console import Console
from rich.text import Text

# BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
BASE_DELAY = 1.2
LOOP_DELAY = 1

ANIMATION_DELAY = 1

logger = logging.getLogger("rich")

# ---------------------------------------------------------------------------- #
#                            common functionalities                            #
# ---------------------------------------------------------------------------- #


def hold_mouse_button(duration: float = 1, button: str = "left") -> None:
    """Hold left or right mouse button.

    :param duration: Hold time, defaults to 1.
    :type duration: float, optional
    :param button: Button to click, defaults to "left".
    :type button: str, optional
    """
    if duration == 0:
        return

    pag.mouseDown(button=button)
    sleep(duration)
    pag.mouseUp(button=button)
    if button == "left" and duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
        pag.click()


def hold_mouse_buttons(duration: float = 1) -> None:
    """Hold left and right mouse buttons simultaneously.

    :param duration: Hold time, defaults to 1.
    :type duration: float, optional
    """
    pag.mouseDown()
    pag.mouseDown(button="right")
    sleep(duration)
    pag.mouseUp()
    pag.mouseUp(button="right")
    if duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
        pag.click()


def sleep_and_decrease(num: int, delay: int) -> int:
    """Self-decrement with a delay.

    :param num: The variable to decrease.
    :type num: int
    :param delay: Sleep time.
    :type delay: int
    :return: Decreased num.
    :rtype: int
    """
    sleep(delay)
    return num - delay


def ask_for_confirmation(msg: str = "Ready to start") -> None:
    """Ask for confirmation of user settings if it's enabled.

    :param msg: Confirmation message, defaults to "Ready to start".
    :type msg: str
    """
    while True:
        ans = input(f"{msg}? [Y/n] ").strip().lower()
        if ans in ("y", ""):
            break
        if ans == "n":
            sys.exit()


def get_box_center(box: Box) -> tuple[int, int]:
    """Get the center coordinate (x, y) of the given box.

    # (x, y, w, h) -> (x, y), np.int64 -> int

    :param box: Box coordinates (x, y, w, h).
    :type box: Box
    :return: x and y coordinates of the center point.
    :rtype: tuple[int, int]
    """
    return int(box.left + box.width // 2), int(box.top + box.height // 2)


# ---------------------------------------------------------------------------- #
#                                  decorators                                  #
# ---------------------------------------------------------------------------- #


def toggle_clicklock(func):
    """Toggle clicklock before and after calling the function."""

    def wrapper(self, *args, **kwargs):
        # ELECTRO must be enabled, always use electric mode if GEAR_RATIO is disabled
        # otherwise, only use electric mode when it's the first time
        if self.cfg.ARGS.ELECTRO and (not self.cfg.ARGS.GEAR_RATIO or (not args or args[0])):
            pag.click(clicks=2, interval=0.1)
        else:
            pag.mouseDown()
        sleep(BASE_DELAY + LOOP_DELAY)
        try:
            func(self, *args, **kwargs)
        finally:
            if self.cfg.ARGS.ELECTRO:
                pag.click(clicks=2, interval=0.1)
            else:
                pag.click()

    return wrapper


def toggle_right_mouse_button(func):
    """Toggle right mouse button before and after calling the function."""

    def wrapper(*args, **kwargs):
        pag.mouseDown(button="right")
        try:
            func(*args, **kwargs)
        finally:
            pag.mouseUp(button="right")

    return wrapper


def press_before_and_after(key):
    def func_wrapper(func):
        def args_wrapper(*args, **kwargs):
            pag.press(key)
            sleep(ANIMATION_DELAY)
            try:
                func(*args, **kwargs)
            finally:
                pag.press(key)
                sleep(ANIMATION_DELAY)

        return args_wrapper

    return func_wrapper


def release_keys_after(arrow_keys: bool = False):
    """Release keys that might have been holding down

    :param arrow_keys: whether to toggle arrow keys, defaults to False
    :type arrow_keys: bool, optional
    """

    def release_keys(arrow_keys):
        pag.keyUp("ctrl")
        pag.keyUp("shift")
        if arrow_keys:
            pag.keyUp("w")
            pag.keyUp("a")
            pag.keyUp("d")

    def func_wrapper(func):  # Capture arrow_keys as 


# === rf4s\__init__.py ===



# === rf4s\app\app.py ===
"""Base application class for other tools.

Provides core functionality for:
- Configuration management
- Window control
- Result display

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

from pathlib import Path

from rich import print
from rich.table import Table
from yacs.config import CfgNode as CN

from rf4s.config import config
from rf4s.controller.window import Window

ROOT = Path(__file__).resolve().parents[2]


class App:
    """Main application class providing configuration setup, window management,
    and result display functionality.

    This class serves as a base for specialized tools. Subclasses must implement
    `_parse_args()` and `_start()` methods.

    Attributes:
        cfg (yacs.config.CfgNode): Merged configuration from defaults, config file,
            CLI arguments, and runtime options (frozen after initialization).
        window (rf4s.controller.window.Window): Window management controller.
    """

    def __init__(self):
        """Initialize application configuration and window controller.

        Configuration is built from:
        1. Default configuration
        2. config.yaml file
        3. Command-line arguments (via subclass implementation)
        4. Runtime options

        Raises:
            NotImplementedError: If subclass does not implement `_parse_args()`
        """
        self.cfg = config.setup_cfg()
        self.cfg.merge_from_file(ROOT / "config.yaml")
        args = self._parse_args()
        args_cfg = CN({"ARGS": config.dict_to_cfg(vars(args))})
        self.cfg.merge_from_other_cfg(args_cfg)
        self.cfg.merge_from_list(args.opts)

        # Dummy node
        dummy = CN({"SELECTED": config.dict_to_cfg({"MODE": "spin"})})
        self.cfg.merge_from_other_cfg(dummy)
        self.cfg.freeze()

        self.window = Window()

    def _parse_args(self):
        raise NotImplementedError("parse_args method must be implemented in subclass")

    def _start(self):
        raise NotImplementedError("_start method must be implemented in subclass")

    def start(self, results: tuple[tuple[str, str]] = ()) -> None:
        """Wrapper method for _start() that handle window activation and result display.

        :param results: (field name, attribute name) pairs
        :type results: tuple[tuple[str, str]], optional
        """
        self.window.activate_game_window()
        try:
            self._start()
        except KeyboardInterrupt:
            pass
        if results:
            self._print_results(results)
        self.window.activate_script_window()

    def _print_results(self, results: tuple[tuple[str, str]]) -> None:
        """Display the running results in a table format.

        :param results: (field name, attribute name) pairs
        :type results: tuple[tuple[str, str]]
        """
        table = Table(
            "Results",
            title="Running Results",
            show_header=False,
            # min_width=20,
        )
        table.title = "Running Results"
        for field_name, attribute_name in results:
            table.add_row(field_name, str(getattr(self, attribute_name)))
        print(table)



# === rf4s\component\friction_brake.py ===
"""Module for friction brake related methods.

This module provides functionality for managing the friction brake in Russian Fishing 4,
including resetting, adjusting, and monitoring the friction brake.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
from multiprocessing import Process, Value
from time import sleep, time

import pyautogui as pag

from rf4s.controller.detection import Detection

MAX_FRICTION_BRAKE = 30
MIN_FRICTION_BRAKE = 0
UP = 1
DOWN = -1
FRICTION_BRAKE_MONITOR_DELAY = 2
LOOP_DELAY = 0.04

logger = logging.getLogger("rich")


class FrictionBrake:
    """Friction brake controller.

    This class handles the adjustment and monitoring of the friction brake during gameplay.

    Attributes:
        cfg (CfgNode): Configuration node for friction brake settings.
        detection (Detection): Detection instance for in-game state checks.
        cur (Value): Current value of the friction brake.
        lock (Lock): Lock for thread synchronization.
        monitor_process (Process): Process for monitoring the friction brake.
    """

    def __init__(self, cfg, lock, detection: Detection) -> None:
        """Initialize the FrictionBrake class with configuration, lock, and detection.

        :param cfg: Configuration node for friction brake settings.
        :type cfg: CfgNode
        :param lock: Lock for thread synchronization.
        :type lock: Lock
        :param detection: Detection instance for in-game state checks.
        :type detection: Detection
        """
        self.cfg = cfg
        self.lock = lock
        self.detection = detection
        self.cur = Value("i", cfg.FRICTION_BRAKE.INITIAL)
        self.monitor_process = Process(target=monitor_friction_brake, args=(self,))

    def reset(self, target: int) -> None:
        """Reset the friction brake to the target value.

        :param target: Target friction brake value.
        :type target: int
        """
        logger.info("Resetting friction brake")
        for _ in range(MAX_FRICTION_BRAKE):
            pag.scroll(UP)

        diff = MAX_FRICTION_BRAKE - target
        for _ in range(abs(diff)):
            pag.scroll(DOWN)
        self.cur.value = target

    def change(self, increase: bool) -> None:
        """Increase or decrease the friction brake.

        :param increase: Whether to increase the friction brake.
        :type increase: bool
        """
        if increase:
            if self.cur.value < self.cfg.FRICTION_BRAKE.MAX:
                pag.scroll(UP, _pause=False)
                self.cur.value = min(self.cur.value + 1, MAX_FRICTION_BRAKE)
        else:
            if self.cur.value > 0:
                pag.scroll(DOWN, _pause=False)
                self.cur.value = max(self.cur.value - 1, MIN_FRICTION_BRAKE)
        sleep(LOOP_DELAY)


def monitor_friction_brake(friction_brake: FrictionBrake) -> None:
    """Monitor friction brake bar and change it accordingly.

    This is used as the target function in multiprocess.Process and must be pickable,
    thus it must be declared as a global function instead of an instance method.

    :param friction_brake: Friction brake controller.
    :type friction_brake: FrictionBrake
    """
    logger.info("Monitoring friction brake")

    pre_time = time()
    fish_hooked = False

    try:
        while True:
            if not friction_brake.detection.is_fish_hooked_pixel():
                sleep(FRICTION_BRAKE_MONITOR_DELAY)
                fish_hooked = False
                continue
            if not fish_hooked:
                sleep(friction_brake.cfg.FRICTION_BRAKE.START_DELAY)
                fish_hooked = True
            with friction_brake.lock:
                if friction_brake.detection.is_friction_brake_high():
                    friction_brake.change(increase=False)
                if friction_brake.detection.is_reel_burning():
                    logger.info("Reel burning detected, decreasing friction brake")
                    friction_brake.change(increase=False)
                else:
                    cur_time = time()
                    if (
                        cur_time - pre_time
                        < friction_brake.cfg.FRICTION_BRAKE.INCREASE_DELAY
                    ):
                        continue
                    pre_time = cur_time
                    friction_brake.change(increase=True)
    except KeyboardInterrupt:
        pass



# === rf4s\component\tackle.py ===
"""Module for Tackle class and some decorators.

This module provides functionality for managing tackle-related actions in Russian Fishing 4,
such as casting, retrieving, and pulling fish. It also includes decorators for handling
common tasks like clicklock and key releases.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

# pylint: disable=c-extension-no-member

import logging
import random
from time import sleep
from typing import Literal

import pyautogui as pag
import win32api
import win32con

from rf4s import exceptions, utils
from rf4s.controller.detection import Detection
from rf4s.controller.timer import Timer

logger = logging.getLogger("rich")

RESET_TIMEOUT = 16
CAST_SCALE = 0.4  # 25% / 0.4s

# BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
BASE_DELAY = 1.2
LOOP_DELAY = 1

ANIMATION_DELAY = 1

RETRIEVAL_TIMEOUT = 32
PULL_TIMEOUT = 16
RETRIEVAL_WITH_PAUSE_TIMEOUT = 128
LIFT_DURATION = 3
TELESCOPIC_RETRIEVAL_TIMEOUT = 8
LANDING_NET_DURATION = 6
LANDING_NET_DELAY = 0.5
SINK_DELAY = 2


OFFSET = 100
NUM_OF_MOVEMENT = 4


class Tackle:
    """Class for all tackle-dependent methods.

    This class handles actions related to the fishing tackle, such as casting,
    retrieving, and pulling fish. It also manages tackle resetting and gear ratio switching.

    Attributes:
        cfg (CfgNode): Configuration node for tackle settings.
        timer (Timer): Timer instance for timing actions.
        detection (Detection): Detection instance for in-game state checks.
        landing_net_out (bool): Whether the landing net is deployed.
        available (bool): Whether the tackle is available for use.
    """

    def __init__(self, cfg, timer: Timer, detection: Detection):
        """Initialize the Tackle class with configuration, timer, and detection.

        :param cfg: Configuration node for tackle settings.
        :type cfg: CfgNode
        :param timer: Timer instance for timing actions.
        :type timer: Timer
        :param detection: Detection instance for in-game state checks.
        :type detection: Detection
        """
        self.cfg = cfg
        self.timer = timer
        self.detection = detection
        self.landing_net_out = False  # For telescopic pull
        self.available = True

    @staticmethod
    def _check_status(func):
        def wrapper(self, *args, **kwargs):
            if not self.available:
                return
            try:
                func(self, *args)
            except Exception as e:
                raise e

        return wrapper

    @_check_status
    @utils.toggle_clicklock
    def reset(self) -> None:
        """Reset the tackle until ready and detect unexpected events.

        :raises exceptions.FishHookedError: A fish is hooked.
        :raises exceptions.FishCapturedError: A fish is captured.
        :raises exceptions.LineAtEndError: The line is at its end.
        :raises exceptions.LineSnaggedError: The line is snagged.
        :raises TimeoutError: The loop timed out.
        """
        logger.info("Resetting tackle")
        i = RESET_TIMEOUT
        while i > 0:
            if self.detection.is_tackle_ready():
                return
            if self.detection.is_fish_hooked():
                raise exceptions.FishHookedError
            if self.detection.is_fish_captured():
                raise exceptions.FishCapturedError
            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                raise exceptions.LineAtEndError
            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                raise exceptions.LineSnaggedError
            if self.detection.is_lure_broken():
                raise exceptions.LureBrokenError
            i = utils.sleep_and_decrease(i, LOOP_DELAY)

        raise TimeoutError

    @_check_status
    def cast(self, lock: bool) -> None:
        """Cast the rod, then wait for the lure/bait to fly and sink.

        :param lock: Whether to lock the reel after casting.
        :type lock: bool
        """
        logger.info("Casting rod")
        if self.cfg.ARGS.MOUSE:
            self.move_mouse_randomly()
        match self.cfg.SELECTED.CAST_POWER_LEVEL:
            case 1:  # 0%
                pag.click()
            case 5:  # power cast
                with pag.hold("shift"):
                    utils.hold_mouse_button(1)
            case _:
                # -1 for backward compatibility
                duration = CAST_SCALE * (self.cfg.SELECTED.CAST_POWER_LEVEL - 1)
                utils.hold_mouse_button(duration)

        sleep(self.cfg.SELECTED.CAST_DELAY)
        if lock:
            pag.click()

    def sink(self) -> None:
        """Sink the lure until an event happens, designed for marine and wakey rig."""
        logger.info("Sinking lure")
        i = self.cfg.SELECTED.SINK_TIMEOUT
        while i > 0:
            i = utils.sleep_and_decrease(i, LOOP_DELAY)
            if self.detection.is_moving_in_bottom_layer()


# === rf4s\component\__pycache__\friction_brake.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\component\__pycache__\friction_brake.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\component\__pycache__\tackle.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\component\__pycache__\tackle.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\config.py ===
"""
Configuration module for managing and manipulating configuration settings.

This module provides utilities for setting up, converting, and printing
configuration nodes using the YACS library.
"""

from yacs.config import CfgNode as CN

from rf4s.config.defaults import get_cfg_defaults


def setup_cfg() -> CN:
    """
    Set up and return a default configuration node.

    This function initializes a default configuration node and allows new keys
    to be added to the configuration.

    :return: A cloned configuration node with default settings.
    :rtype: CN
    """
    cfg = get_cfg_defaults()
    cfg.set_new_allowed(True)
    return cfg.clone()


def dict_to_cfg(args: dict) -> CN:
    """
    Convert a dictionary to a configuration node.

    This function recursively converts a dictionary into a configuration node,
    allowing nested dictionaries to be converted into nested configuration nodes.

    :param args: Dictionary to be converted into a configuration node.
    :type args: dict
    :return: Configuration node created from the dictionary.
    :rtype: CN
    """
    cfg = CN()
    for k, v in args.items():
        k = k.upper()
        if isinstance(v, dict):
            cfg[k] = dict_to_cfg(v)
        else:
            cfg[k] = v
    return cfg


def print_cfg(cfg: CN, level: int = 0) -> None:
    """
    Print the configuration node in a readable format.

    This function recursively prints the configuration node, with indentation
    to represent nested levels.

    :param cfg: Configuration node to be printed.
    :type cfg: CN
    :param level: Current indentation level (used for recursion).
    :type level: int
    """
    cfg = dict(cfg)
    indent = "  " * level if level > 0 else ""
    for k, v in cfg.items():
        if isinstance(v, CN):
            print(f"{indent}{k}:")
            print_cfg(v, level + 1)
        else:
            print(f"{indent}{k}: {v}")


def to_list(profile: dict) -> list:
    """
    Convert a dictionary into a flat list of key-value pairs.

    This function flattens a dictionary into a list where keys and values
    are alternated.

    :param profile: Dictionary to be converted into a list.
    :type profile: dict
    :return: List containing alternating keys and values from the dictionary.
    :rtype: list
    """
    pairs = []
    for k, v in profile.items():
        pairs.extend([k, v])
    return pairs



# === rf4s\config\config.yaml ===
VERSION: "0.4.2"

SCRIPT:
  LANGUAGE: "en"
  LAUNCH_OPTIONS: ""
  SMTP_VERIFICATION: true
  IMAGE_VERIFICATION: true
  SNAG_DETECTION: true
  SPOOLING_DETECTION: true
  RANDOM_ROD_SELECTION: true
  SPOOL_CONFIDENCE: 0.98
  SPOD_ROD_RECAST_DELAY: 1800
  LURE_CHANGE_DELAY: 1800
  ALARM_SOUND: "./static/sound/guitar.wav"

KEY:
  TEA: -1
  CARROT: -1
  BOTTOM_RODS: [1, 2, 3]
  COFFEE: 4
  DIGGING_TOOL: 5
  ALCOHOL: 6
  MAIN_ROD: 1
  SPOD_ROD: 7
  QUIT: "CTRL-C"

STAT:
  ENERGY_THRESHOLD: 0.74
  HUNGER_THRESHOLD: 0.5
  COMFORT_THRESHOLD: 0.51
  TEA_DELAY: 300
  COFFEE_LIMIT: 10
  COFFEE_PER_DRINK: 1
  ALCOHOL_DELAY: 900
  ALCOHOL_PER_DRINK: 1

FRICTION_BRAKE:
  INITIAL: 29
  MAX: 30
  START_DELAY: 2.0
  INCREASE_DELAY: 1.0
  SENSITIVITY: "medium"

KEEPNET:
  CAPACITY: 100
  DELAY: 0.0
  FULL_ACTION: "quit"
  RELEASE_WHITELIST:
    - "mackerel"
    - "saithe"
    - "herring"
    - "squid"
    - "scallop"
    - "mussel"
  BLACKLIST: []

NOTIFICATION:
  EMAIL: "email@example.com"
  PASSWORD: "password"
  SMTP_SERVER: "smtp.gmail.com"
  MIAO_CODE: "example"

PAUSE:
  DELAY: 1800
  DURATION: 600

PROFILE:
  SPIN:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "normal"
  SPIN_WITH_PAUSE:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 1.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 3.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "pause"
  SPIN_WITH_LIFT:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 1.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "lift"
  BOTTOM:
    MODE: "bottom"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    POST_ACCELERATION: "off"
    CHECK_DELAY: 32.0
    CHECK_MISS_LIMIT: 16
  PIRK:
    MODE: "pirk"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  PIRK_WITH_RETRIEVAL:
    MODE: "pirk"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 0.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  WAKEY_RIG:
    MODE: "pirk"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 45.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: true
    SHIFT: false
    PIRK_DURATION: 1.5
    PIRK_DELAY: 4.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR:
    MODE: "elevator"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR_WITH_DROP:
    MODE: "elevator"
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  TELESCOPIC:
    MODE: "telescopic"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 16.0
    CAMERA_SHAPE: "square"
  BOLOGNESE:
    MODE: "bolognese"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 32.0
    CAMERA_SHAPE: "square"
    POST_ACCELERATION: "off"



# === rf4s\config\defaults.py ===
"""Default yacs config node."""

from yacs.config import CfgNode as CN

_C = CN()
_C.VERSION = "0.4.2"

# ---------------------------------------------------------------------------- #
#                                    General                                   #
# ---------------------------------------------------------------------------- #
_C.SCRIPT = CN()
_C.SCRIPT.LANGUAGE = "en"  # Language for the script. Options: en, ru, zh-TW, zh-CN
_C.SCRIPT.LAUNCH_OPTIONS = ""  # Default launch options for the script, e.g., -r -c -H
_C.SCRIPT.SMTP_VERIFICATION = True
_C.SCRIPT.IMAGE_VERIFICATION = True
_C.SCRIPT.SNAG_DETECTION = True
_C.SCRIPT.SPOOLING_DETECTION = True
_C.SCRIPT.RANDOM_ROD_SELECTION = True  # For bottom mode
# Confidence threshold for spooling detection (lower = more sensitive)
_C.SCRIPT.SPOOL_CONFIDENCE = 0.98
# Delay before recasting spod rod (in seconds)
# Use bottom mode and -o to enable it.
_C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800
# Delay before changing lure randomly (in seconds)
# Use spin mode and -L to enable it.
_C.SCRIPT.LURE_CHANGE_DELAY = 1800
_C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # Path to alarm sound file

# ---------------------------------------------------------------------------- #
#                                  Key Binding                                 #
# ---------------------------------------------------------------------------- #
_C.KEY = CN()
_C.KEY.TEA = -1  # Key binding for tea. Set to -1 to use quick selection menu
_C.KEY.CARROT = -1  # Key binding for carrot. Set to -1 to use quick selection menu
_C.KEY.BOTTOM_RODS = (1, 2, 3)  # Key bindings for bottom rods
_C.KEY.COFFEE = 4  # Key binding for coffee. Set to -1 to use quick selection menu
_C.KEY.DIGGING_TOOL = 5  # Key binding for digging tool
_C.KEY.ALCOHOL = 6  # Key binding for alcohol
# Key binding for the main rod (used when harvesting baits with one rod)
_C.KEY.MAIN_ROD = 1
_C.KEY.SPOD_ROD = 7  # Key binding for the spod rod (used in bottom mode)
# Key binding to stop the script (default is Ctrl-C)
# If you want to use a special quitting shortcut, please refer to pynput's docs:
# https://pynput.readthedocs.io/en/latest/keyboard.html#pynput.keyboard.Key .
_C.KEY.QUIT = "CTRL-C"

# ---------------------------------------------------------------------------- #
#                                 Player Stats                                 #
# ---------------------------------------------------------------------------- #
_C.STAT = CN()
# Minimum energy level before drinking coffee/harvesting baits
_C.STAT.ENERGY_THRESHOLD = 0.74
_C.STAT.HUNGER_THRESHOLD = 0.5  # Minimum hunger level before consuming carrot
_C.STAT.COMFORT_THRESHOLD = 0.51  # Minimum comfort level before consuming tea
_C.STAT.TEA_DELAY = 300  # Delay between tea drinks (in seconds)
_C.STAT.COFFEE_LIMIT = 10  # Maximum coffee drinks per fish fight.
_C.STAT.COFFEE_PER_DRINK = 1  # Amount of coffee consumed per drink
_C.STAT.ALCOHOL_DELAY = 900  # Delay between alcohol drinks (in seconds)
_C.STAT.ALCOHOL_PER_DRINK = 1  # Amount of alcohol consumed per drink

# ---------------------------------------------------------------------------- #
#                   Friction Brake (Use -f flag to enable it)                  #
# ---------------------------------------------------------------------------- #
_C.FRICTION_BRAKE = CN()
_C.FRICTION_BRAKE.INITIAL = 29  # Initial friction brake value
_C.FRICTION_BRAKE.MAX = 30  # Maximum friction brake value
# Delay before starting to adjust friction brake after a fish is hooked
_C.FRICTION_BRAKE.START_DELAY = 2.0
_C.FRICTION_BRAKE.INCREASE_DELAY = 1.0  # Delay before increasing friction brake
_C.FRICTION_BRAKE.SENSITIVITY = "medium"  # Sensitivity of friction brake detection

# ---------------------------------------------------------------------------- #
#                                    Keepnet                                   #
# ---------------------------------------------------------------------------- #
_C.KEEPNET = CN()
_C.KEEPNET.CAPACITY = 100
_C.KEEPNET.DELAY = 0.0  # Delay before keeping the fish (for screenshots)
_C.KEEPNET.FULL_ACTION = "quit"  # Action when keepnet is full. Options: quit, alarm
# Whitelist for unmarked fish releasing when using -m flag
# Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.RELEASE_WHITELIST = (
    "mackerel",
    "saithe",
    "herring",
    "squid",
    "scallop",
    "mussel",
)
# Fish in the blacklist will always be released
# Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.BLACKLIST = ()

# ---------------------------------------------------------------------------- #
#                                 Notification                                 #
# ---------------------------------------------------------------------------- #
_C.NOTIFICATION = CN()
_C.NOTIFICATION.EMAIL = "email@example.com"
_C.NOTIFICATION.PASSWORD = "password"
_C.NOTIFICATION.SMTP_S


# === rf4s\config\__init__.py ===



# === rf4s\config\__pycache__\config.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\__pycache__\config.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\__pycache__\defaults.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\__pycache__\defaults.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\__pycache__\__init__.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\config\__pycache__\__init__.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\detection.py ===
"""Module for pyautogui.locateOnScreen and pag.pixel wrappers.

This module provides functionality for detecting in-game elements using image recognition
and pixel color analysis. It is used for automating tasks in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

# pylint: disable=missing-function-docstring

import time
from pathlib import Path
from typing import Generator

import pyautogui as pag
from PIL import Image
from pyscreeze import Box

from rf4s.controller.window import Window

CRITICAL_COLOR = (206, 56, 21)
WARNING_COLOR = (227, 149, 23)
WHITE = (255, 255, 255)

MIN_GRAY_SCALE_LEVEL = 150
YELLOW_FRICTION_BRAKE = (200, 214, 63)
ORANGE_FRICTION_BRAKE = (229, 188, 0)
RED_FRICTION_BRAKE = (206, 56, 21)
COLOR_TOLERANCE = 32
CAMERA_OFFSET = 40
SIDE_LENGTH = 160
SIDE_LENGTH_HALF = 80
ORANGE_REEL = (227, 149, 23)

ROOT = Path(__file__).resolve().parents[2]

COORD_OFFSETS = {
    "1600x900": {
        "friction_brake_very_high": (502, 872),  # Left point only
        "friction_brake_high": (459, 872),
        "friction_brake_medium": (417, 872),
        "friction_brake_low": (396, 872),
        "fish_icon": (389, 844),
        "clip_icon": (1042, 844),
        "spool_icon": (1077, 844),  # x + 15, y + 15
        "reel_burning_icon": (1112, 842),
        "snag_icon": (1147, 829),  # x + 15, y
        "float_camera": (720, 654),
        "bait_icon": (35, 31),
    },
    "1920x1080": {
        "friction_brake_very_high": (662, 1052),
        "friction_brake_high": (619, 1052),
        "friction_brake_medium": (577, 1052),
        "friction_brake_low": (556, 1052),
        "fish_icon": (549, 1024),
        "clip_icon": (1202, 1024),
        "spool_icon": (1237, 1024),
        "reel_burning_icon": (1271, 1023),
        "snag_icon": (1307, 1009),
        "float_camera": (880, 834),
        "bait_icon": (35, 31),
    },
    "2560x1440": {
        "friction_brake_very_high": (982, 1412),
        "friction_brake_high": (939, 1412),
        "friction_brake_medium": (897, 1412),
        "friction_brake_low": (876, 1412),
        "fish_icon": (869, 1384),
        "clip_icon": (1522, 1384),
        "spool_icon": (1557, 1384),
        "reel_burning_icon": (1593, 1383),
        "snag_icon": (1627, 1369),
        "float_camera": (1200, 1194),
        "bait_icon": (35, 31),
    },
}

# ------------------------ Friction brake coordinates ------------------------ #
# ----------------------------- 900p - 1080p - 2k ---------------------------- #
# ------ left - red - yellow - center(left + 424) - yellow - red - right ----- #
# "bases": ((480, 270), (320, 180), (0, 0))
# "absolute": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702, "y": (1146, 1236, 1412)}
# "1600x900": {"x": (375, 480, 586, 799, 1011, 1118, 1222), "y": 876},
# "1920x1080": {"x": (535, 640, 746, 959, 1171, 1278, 1382), "y": 1056},
# "2560x1440": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702), "y": 1412},


class Detection:
    """A class that holds different aliases of locateOnScreen(image).

    This class provides methods for detecting various in-game elements such as fish,
    icons, and UI components using image recognition and pixel color analysis.

    Attributes:
        cfg (CfgNode): Configuration node for the detection settings.
        window (Window): Game window controller instance.
        image_dir (Path): Directory containing reference images for detection.
        coord_offsets (dict): Dictionary of coordinate offsets for different window sizes.
        bait_icon_reference_img (Image): Reference image for bait icon detection.
    """

    # pylint: disable=too-many-public-methods

    def __init__(self, cfg, window: Window):
        """Initialize the Detection class with configuration and window settings.

        :param cfg: Configuration node for detection settings.
        :type cfg: CfgNode
        :param window: Game window controller instance.
        :type window: Window
        """
        self.cfg = cfg
        self.window = window
        self.image_dir = ROOT / "static" / cfg.SCRIPT.LANGUAGE

        if window.supported:
            self._set_absolute_coords()

        self.bait_icon_reference_img = Image.open(self.image_dir / "bait_icon.png")

    def _get_image_box(
        self, image: str, confidence: float, multiple: bool = False
    ) -> Box | Generator[Box, None, None] | None:
        """A wrapper for locateOnScreen method and path resolving.

        :param image: Base name of the image.
        :type image: str
        :param confidence: Matching confidence for locateOnScreen.
        :type confidence: float
        :param multiple: Whether to locate all matching images, defaults to False.
        :type multiple: bool, optional
        :return: Image box, None if not found.
        :rtype: Box | None
        """
        image_path = str(self.image_dir / f"{image}.png")
        if multiple:
            return pag.locateAllOnScreen(image_path, confidence=confidence)
        return pag.locateOnScreen


# === rf4s\controller\timer.py ===
"""Module for Timer class.

This module provides functionality for managing timers and generating timestamps
for logging and automation purposes in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import datetime
import time


class Timer:
    """Class for calculating and generating timestamps for logs.

    This class manages various timers and counters for tracking in-game events,
    such as casting times, consumable cooldowns, and script pauses.

    Attributes:
        cfg (CfgNode): Configuration node for timer settings.
        start_time (float): Timestamp when the timer was initialized.
        start_datetime (str): Formatted start date and time.
        cast_rhour (int | None): Real-time hour of the last cast.
        cast_ghour (int | None): In-game hour of the last cast.
        cast_rhour_list (list[int]): List of real-time hours for casts.
        cast_ghour_list (list[int]): List of in-game hours for casts.
        last_tea_drink (float): Timestamp of the last tea consumption.
        last_alcohol_drink (float): Timestamp of the last alcohol consumption.
        last_lure_change (float): Timestamp of the last lure change.
        last_spod_rod_recast (float): Timestamp of the last spod rod recast.
        last_pause (float): Timestamp of the last script pause.
    """

    # pylint: disable=too-many-instance-attributes
    # there are too many counters...

    def __init__(self, cfg):
        """Initialize the Timer class with configuration settings.

        :param cfg: Configuration node for timer settings.
        :type cfg: CfgNode
        """
        self.cfg = cfg
        self.start_time = time.time()
        self.start_datetime = time.strftime("%m/%d %H:%M:%S", time.localtime())

        self.cast_rhour = None
        self.cast_ghour = None
        self.cast_rhour_list = []
        self.cast_ghour_list = []

        self.last_tea_drink = 0
        self.last_alcohol_drink = 0
        self.last_lure_change = self.start_time
        self.last_spod_rod_recast = self.start_time
        self.last_pause = self.start_time

    def get_running_time(self) -> str:
        """Calculate the execution time of the program.

        :return: Formatted execution time (hh:mm:ss).
        :rtype: str
        """
        return str(
            datetime.timedelta(seconds=int(time.time() - self.start_time))
        )  # truncate to seconds

    def get_cur_timestamp(self) -> str:
        """Generate timestamp for images in screenshots/.

        :return: Current timestamp.
        :rtype: str
        """
        return time.strftime("%Y-%m-%d--%H-%M-%S", time.localtime())

    def get_start_datetime(self) -> str:
        """Generate a simplified timestamp for quit message.

        :return: Start date and time.
        :rtype: str
        """
        return self.start_datetime

    def get_cur_datetime(self) -> str:
        """Generate a simplified timestamp for quit message.

        :return: Current date and time.
        :rtype: str
        """
        return time.strftime("%m/%d %H:%M:%S", time.localtime())

    def update_cast_time(self) -> None:
        """Update the latest real and in-game hour of casting."""
        dt = datetime.datetime.now()
        self.cast_rhour = int((time.time() - self.start_time) // 3600)
        self.cast_ghour = int((dt.minute / 60 + dt.second / 3600) * 24 % 24)

    def add_cast_time(self) -> None:
        """Record the latest real and in-game hour of casting."""
        self.cast_rhour_list.append(self.cast_rhour)
        self.cast_ghour_list.append(self.cast_ghour)

    def get_cast_time_list(self) -> tuple[list[int]]:
        """Get lists of real and in-game hours for casts.

        :return: Lists of real and in-game hours.
        :rtype: tuple[list[int]]
        """
        return self.cast_rhour_list, self.cast_ghour_list

    def is_tea_drinkable(self) -> bool:
        """Check if it has been a long time since the last tea consumption.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_tea_drink > self.cfg.STAT.TEA_DELAY:
            self.last_tea_drink = cur_time
            return True
        return False

    def is_alcohol_drinkable(self) -> bool:
        """Check if it has been a long time since the last alcohol consumption.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_alcohol_drink > self.cfg.STAT.ALCOHOL_DELAY:
            self.last_alcohol_drink = cur_time
            self.last_tea_drink = cur_time  # Alcohol also refill comfort
            return True
        return False

    def is_lure_changeable(self):
        """Check if it has been a long time since the last lure change.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - sel


# === rf4s\controller\window.py ===
"""Module for window controller.

This module provides functionality for managing and interacting with the game window
and terminal window in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import sys
from pathlib import Path
from time import sleep

# import win32api, win32con
import pyautogui as pag
import win32con
import win32gui

logger = logging.getLogger("rich")

ROOT = Path(__file__).resolve().parents[2]


class Window:
    """Controller for terminal and game windows management.

    This class handles window focus, size detection, and screenshot functionality
    for the game and terminal windows.

    Attributes:
        _title (str): Title of the game window.
        _script_hwnd (int): Handle of the terminal window.
        _game_hwnd (int): Handle of the game window.
        box (tuple[int, int, int, int]): Coordinates and dimensions of the game window.
        title_bar_exist (bool): Whether the game window has a title bar.
        supported (bool): Whether the game window size is supported.
    """

    def __init__(self, window_title: str = "Russian Fishing 4"):
        """Initialize the Window class with the game window title.

        :param window_title: Title of the game window, defaults to "Russian Fishing 4".
        :type window_title: str, optional
        """
        self._title = window_title
        self._script_hwnd = self._get_cur_hwnd()
        self._game_hwnd = self._get_game_hwnd()
        self.box = self._get_box()
        self.title_bar_exist = self._is_title_bar_exist()
        self.supported = self._is_size_supported()

    def _get_cur_hwnd(self) -> int:
        """Get the handle of the terminal window.

        :return: Process handle of the terminal window.
        :rtype: int
        """
        return win32gui.GetForegroundWindow()

    def _get_game_hwnd(self) -> int:
        """Get the handle of the game window.

        :return: Process handle of the game window.
        :rtype: int
        """
        hwnd = win32gui.FindWindow(None, self._title)
        # print(win32gui.GetClassName(hwnd)) # class name: UnityWndClass
        if not hwnd:
            logger.error("Failed to locate the game window: %s", self._title)
            sys.exit()
        return hwnd

    def _is_title_bar_exist(self) -> bool:
        """Check if the game window is in windowed mode.

        :return: True if the game window has a title bar, False otherwise.
        :rtype: bool
        """
        style = win32gui.GetWindowLong(self._game_hwnd, win32con.GWL_STYLE)
        return style & win32con.WS_CAPTION

    def _get_box(self) -> tuple[int, int, int, int]:
        """Get the coordinates and dimensions of the game window.

        :return: Tuple containing (x, y, width, height) of the game window.
        :rtype: tuple[int, int, int, int]
        """
        base_x, base_y, _, _ = win32gui.GetWindowRect(self._game_hwnd)
        if self._is_title_bar_exist():
            base_x += 8
            base_y += 31
        left, top, right, bottom = win32gui.GetClientRect(self._game_hwnd)
        width = right - left
        height = bottom - top
        return base_x, base_y, width, height

    def activate_script_window(self) -> None:
        """Focus terminal."""
        pag.press("alt")
        win32gui.SetForegroundWindow(
            self._script_hwnd
        )  # fullscreen mode is not supported
        sleep(0.25)

    def activate_game_window(self) -> None:
        """Focus game window."""
        pag.press("alt")
        win32gui.SetForegroundWindow(
            self._game_hwnd
        )  # fullscreen mode is not supported
        sleep(0.25)

    def _is_size_supported(self) -> bool:
        """Check if the game window size is supported.

        :return: True if the window size is supported, False otherwise.
        :rtype: bool
        """
        if self.box[2:] in ((2560, 1440), (1920, 1080), (1600, 900)):
            return True
        return False

    def save_screenshot(self, time) -> None:
        """Save a screenshot of the game window to the screenshots directory.

        :param time: Timestamp to use as the filename.
        :type time: str
        """
        # datetime.now().strftime("%H:%M:%S")
        pag.screenshot(
            # imageFilename=rf"../screenshots/{time}.png",
            imageFilename=ROOT / "screenshots" / f"{time}.png",
            region=self.box,
        )


if __name__ == "__main__":
    w = Window("Russian Fishing 4")
    w.activate_game_window()

# SetForegroundWindow bug reference :
# https://stackoverflow.com/questions/56857560/win32gui-setforegroundwindowhandle-not-working-in-loop



# === rf4s\controller\__pycache__\detection.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\__pycache__\detection.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\__pycache__\timer.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\__pycache__\timer.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\__pycache__\window.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\controller\__pycache__\window.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\exceptions.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\exceptions.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\player.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\player.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\utils.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\utils.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\__init__.cpython-311.pyc ===
Это кэш Python (pyc-файл)


# === rf4s\__pycache__\__init__.cpython-312.pyc ===
Это кэш Python (pyc-файл)


# === static\en\0m.png ===
Это картинка


# === static\en\100wear.png ===
Это картинка


# === static\en\5m.png ===
Это картинка


# === static\en\bait_icon.png ===
Это картинка


# === static\en\broke.png ===
Это картинка


# === static\en\carrot.png ===
Это картинка


# === static\en\classic_feed_mix.png ===
Это картинка


# === static\en\coffee.png ===
Это картинка


# === static\en\comfort.png ===
Это картинка


# === static\en\confirm.png ===
Это картинка


# === static\en\disconnected.png ===
Это картинка


# === static\en\dry_feed_mix.png ===
Это картинка


# === static\en\energy.png ===
Это картинка


# === static\en\exit.png ===
Это картинка


# === static\en\favorite.png ===
Это картинка


# === static\en\fish_icon.png ===
Это картинка


# === static\en\food.png ===
Это картинка


# === static\en\groundbait_icon.png ===
Это картинка


# === static\en\harvest_confirm.png ===
Это картинка


# === static\en\herring.png ===
Это картинка


# === static\en\keep.png ===
Это картинка


# === static\en\lure_is_broken.png ===
Это картинка


# === static\en\mackerel.png ===
Это картинка


# === static\en\make.png ===
Это картинка


# === static\en\mark.png ===
Это картинка


# === static\en\material_slot.png ===
Это картинка


# === static\en\movement.png ===
Это картинка


# === static\en\mussel.png ===
Это картинка


# === static\en\ok.png ===
Это картинка


# === static\en\ok_black.png ===
Это картинка


# === static\en\ok_white.png ===
Это картинка


# === static\en\perch.png ===
Это картинка


# === static\en\pva_icon.png ===
Это картинка


# === static\en\quit.png ===
Это картинка


# === static\en\ready.png ===
Это картинка


# === static\en\saithe.png ===
Это картинка


# === static\en\scallop.png ===
Это картинка


# === static\en\scrollbar.png ===
Это картинка


# === static\en\shorthorn_sculpin.png ===
Это картинка


# === static\en\squid.png ===
Это картинка


# === static\en\tea.png ===
Это картинка


# === static\en\ticket.png ===
Это картинка


# === static\en\ticket_1.png ===
Это картинка


# === static\en\ticket_2.png ===
Это картинка


# === static\en\ticket_3.png ===
Это картинка


# === static\en\ticket_5.png ===
Это картинка


# === static\en\warning.png ===
Это картинка


# === static\en\welcome.png ===
Это картинка


# === static\en\wheel.png ===
Это картинка


# === static\en\yes.png ===
Это картинка


# === static\readme\cd.png ===
Это картинка


# === static\readme\clicklock.png ===
Это картинка


# === static\readme\favorites.png ===
Это картинка


# === static\readme\favorites_2.png ===
Это картинка


# === static\readme\file_integrity.png ===
Это картинка


# === static\readme\file_integrity_2.png ===
Это картинка


# === static\readme\mtx1.png ===
Это картинка


# === static\readme\mtx2.png ===
Это картинка


# === static\readme\mtx3.png ===
Это картинка


# === static\readme\RF4S.png ===
Это картинка


# === static\readme\RF4S_original.png ===
Это картинка


# === static\readme\status.png ===
Это картинка


# === static\ru\0m.png ===
Это картинка


# === static\ru\100wear.png ===
Это картинка


# === static\ru\5m.png ===
Это картинка


# === static\ru\bait_icon.png ===
Это картинка


# === static\ru\broke.png ===
Это картинка


# === static\ru\carrot.png ===
Это картинка


# === static\ru\classic_feed_mix.png ===
Это картинка


# === static\ru\coffee.png ===
Это картинка


# === static\ru\comfort.png ===
Это картинка


# === static\ru\confirm.png ===
Это картинка


# === static\ru\disconnected.png ===
Это картинка


# === static\ru\dry_feed_mix.png ===
Это картинка


# === static\ru\energy.png ===
Это картинка


# === static\ru\exit.png ===
Это картинка


# === static\ru\favorite.png ===
Это картинка


# === static\ru\fish_icon.png ===
Это картинка


# === static\ru\food.png ===
Это картинка


# === static\ru\groundbait_icon.png ===
Это картинка


# === static\ru\harvest_confirm.png ===
Это картинка


# === static\ru\herring.png ===
Это картинка


# === static\ru\keep.png ===
Это картинка


# === static\ru\lure_is_broken.png ===
Это картинка


# === static\ru\mackerel.png ===
Это картинка


# === static\ru\make.png ===
Это картинка


# === static\ru\mark.png ===
Это картинка


# === static\ru\material_slot.png ===
Это картинка


# === static\ru\movement.png ===
Это картинка


# === static\ru\mussel.png ===
Это картинка


# === static\ru\ok.png ===
Это картинка


# === static\ru\ok_black.png ===
Это картинка


# === static\ru\ok_white.png ===
Это картинка


# === static\ru\perch.png ===
Это картинка


# === static\ru\pva_icon.png ===
Это картинка


# === static\ru\quit.png ===
Это картинка


# === static\ru\ready.png ===
Это картинка


# === static\ru\saithe.png ===
Это картинка


# === static\ru\scallop.png ===
Это картинка


# === static\ru\scrollbar.png ===
Это картинка


# === static\ru\shorthorn_sculpin.png ===
Это картинка


# === static\ru\squid.png ===
Это картинка


# === static\ru\tea.png ===
Это картинка


# === static\ru\ticket.png ===
Это картинка


# === static\ru\ticket_1.png ===
Это картинка


# === static\ru\ticket_2.png ===
Это картинка


# === static\ru\ticket_3.png ===
Это картинка


# === static\ru\ticket_5.png ===
Это картинка


# === static\ru\warning.png ===
Это картинка


# === static\ru\welcome.png ===
Это картинка


# === static\ru\wheel.png ===
Это картинка


# === static\ru\yes.png ===
Это картинка


# === static\sound\app_1.wav ===
Это аудиофайл


# === static\sound\app_2.wav ===
Это аудиофайл


# === static\sound\app_3.wav ===
Это аудиофайл


# === static\sound\bell_1.wav ===
Это аудиофайл


# === static\sound\bell_2.wav ===
Это аудиофайл


# === static\sound\bell_3.wav ===
Это аудиофайл


# === static\sound\digital.wav ===
Это аудиофайл


# === static\sound\door_bell.wav ===
Это аудиофайл


# === static\sound\elevator.wav ===
Это аудиофайл


# === static\sound\fast_alarm.wav ===
Это аудиофайл


# === static\sound\flute_1.wav ===
Это аудиофайл


# === static\sound\flute_2.wav ===
Это аудиофайл


# === static\sound\guitar.wav ===
Это аудиофайл


# === static\sound\marimba.wav ===
Это аудиофайл


# === static\sound\ripple.wav ===
Это аудиофайл


# === static\zh-CN\0m.png ===
Это картинка


# === static\zh-CN\100wear.png ===
Это картинка


# === static\zh-CN\5m.png ===
Это картинка


# === static\zh-CN\bait_icon.png ===
Это картинка


# === static\zh-CN\broke.png ===
Это картинка


# === static\zh-CN\carrot.png ===
Это картинка


# === static\zh-CN\coffee.png ===
Это картинка


# === static\zh-CN\comfort.png ===
Это картинка


# === static\zh-CN\confirm.png ===
Это картинка


# === static\zh-CN\disconnected.png ===
Это картинка


# === static\zh-CN\energy.png ===
Это картинка


# === static\zh-CN\exit.png ===
Это картинка


# === static\zh-CN\favorite.png ===
Это картинка


# === static\zh-CN\fish_icon.png ===
Это картинка


# === static\zh-CN\food.png ===
Это картинка


# === static\zh-CN\groundbait_icon.png ===
Это картинка


# === static\zh-CN\harvest_confirm.png ===
Это картинка


# === static\zh-CN\keep.png ===
Это картинка


# === static\zh-CN\lure_is_broken.png ===
Это картинка


# === static\zh-CN\make.png ===
Это картинка


# === static\zh-CN\mark.png ===
Это картинка


# === static\zh-CN\material_slot.png ===
Это картинка


# === static\zh-CN\movement.png ===
Это картинка


# === static\zh-CN\ok.png ===
Это картинка


# === static\zh-CN\pva_icon.png ===
Это картинка


# === static\zh-CN\quit.png ===
Это картинка


# === static\zh-CN\ready.png ===
Это картинка


# === static\zh-CN\scrollbar.png ===
Это картинка


# === static\zh-CN\tea.png ===
Это картинка


# === static\zh-CN\ticket.png ===
Это картинка


# === static\zh-CN\ticket_1.png ===
Это картинка


# === static\zh-CN\ticket_2.png ===
Это картинка


# === static\zh-CN\ticket_3.png ===
Это картинка


# === static\zh-CN\ticket_5.png ===
Это картинка


# === static\zh-CN\warning.png ===
Это картинка


# === static\zh-CN\welcome.png ===
Это картинка


# === static\zh-CN\wheel.png ===
Это картинка


# === static\zh-CN\yes.png ===
Это картинка


# === static\zh-TW\0m.png ===
Это картинка


# === static\zh-TW\100wear.png ===
Это картинка


# === static\zh-TW\5m.png ===
Это картинка


# === static\zh-TW\bait_icon.png ===
Это картинка


# === static\zh-TW\broke.png ===
Это картинка


# === static\zh-TW\carrot.png ===
Это картинка


# === static\zh-TW\coffee.png ===
Это картинка


# === static\zh-TW\comfort.png ===
Это картинка


# === static\zh-TW\confirm.png ===
Это картинка


# === static\zh-TW\disconnected.png ===
Это картинка


# === static\zh-TW\energy.png ===
Это картинка


# === static\zh-TW\exit.png ===
Это картинка


# === static\zh-TW\favorite.png ===
Это картинка


# === static\zh-TW\fish_icon.png ===
Это картинка


# === static\zh-TW\food.png ===
Это картинка


# === static\zh-TW\groundbait_icon.png ===
Это картинка


# === static\zh-TW\harvest_confirm.png ===
Это картинка


# === static\zh-TW\herring.png ===
Это картинка


# === static\zh-TW\keep.png ===
Это картинка


# === static\zh-TW\lure_is_broken.png ===
Это картинка


# === static\zh-TW\mackerel.png ===
Это картинка


# === static\zh-TW\make.png ===
Это картинка


# === static\zh-TW\mark.png ===
Это картинка


# === static\zh-TW\material_slot.png ===
Это картинка


# === static\zh-TW\movement.png ===
Это картинка


# === static\zh-TW\mussel.png ===
Это картинка


# === static\zh-TW\ok.png ===
Это картинка


# === static\zh-TW\pva_icon.png ===
Это картинка


# === static\zh-TW\quit.png ===
Это картинка


# === static\zh-TW\ready.png ===
Это картинка


# === static\zh-TW\saithe.png ===
Это картинка


# === static\zh-TW\scallop.png ===
Это картинка


# === static\zh-TW\scrollbar.png ===
Это картинка


# === static\zh-TW\squid.png ===
Это картинка


# === static\zh-TW\tea.png ===
Это картинка


# === static\zh-TW\ticket.png ===
Это картинка


# === static\zh-TW\ticket_1.png ===
Это картинка


# === static\zh-TW\ticket_2.png ===
Это картинка


# === static\zh-TW\ticket_3.png ===
Это картинка


# === static\zh-TW\ticket_5.png ===
Это картинка


# === static\zh-TW\warning.png ===
Это картинка


# === static\zh-TW\welcome.png ===
Это картинка


# === static\zh-TW\wheel.png ===
Это картинка


# === static\zh-TW\yes.png ===
Это картинка


# === tools\auto_friction_brake.py ===
"""Automate friction brake adjustments in Russian Fishing 4.

This module provides functionality to automatically adjust the friction brake
based on in-game conditions. It supports key bindings for exiting the script
and resetting the friction brake.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import logging
import shlex
import sys
from multiprocessing import Lock
from pathlib import Path

from pynput import keyboard
from rich.logging import RichHandler

sys.path.append(".")


from rf4s.app.app import App
from rf4s.component.friction_brake import FrictionBrake
from rf4s.config.config import print_cfg
from rf4s.controller.detection import Detection

EXIT = "'h'"
RESET = "'g'"
ROOT = Path(__file__).resolve().parents[1]

logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[RichHandler(rich_tracebacks=True)],
)
logger = logging.getLogger("rich")


class FrictionBrakeApp(App):
    """Main application class for automating friction brake adjustments.

    This class manages the configuration, detection, and execution of the friction
    brake automation process. It also handles key bindings for exiting and resetting.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        window (Window): Game window controller instance.
        detection (Detection): Detection instance for in-game state checks.
        friction_brake_lock (Lock): Dummy lock for thread synchronization.
        friction_brake (FrictionBrake): Friction brake controller instance.
    """

    def __init__(self):
        """Initialize the application.

        Loads configuration, parses command-line arguments, sets up the game window,
        and initializes the friction brake controller.
        """
        super().__init__()

        # Format key
        self.cfg.defrost()
        self.cfg.ARGS.EXIT_KEY = f"'{self.cfg.ARGS.EXIT_KEY}'"
        self.cfg.ARGS.RESET_KEY = f"'{self.cfg.ARGS.RESET_KEY}'"
        self.cfg.freeze()
        print_cfg(self.cfg.ARGS)
        print_cfg(self.cfg.FRICTION_BRAKE)

        width, height = self.window.box[:2]
        if self.window.title_bar_exist:
            logger.info("Window mode detected. Please don't move the game window")
        if not self.window.supported:
            logger.warning('Window mode must be "Borderless windowed" or "Window mode"')
            logger.critical(
                "Invalid window size '%s', use '2560x1440', '1920x1080' or '1600x900'",
                f"{width}x{height}",
            )
            sys.exit(1)

        self.detection = Detection(self.cfg, self.window)

        self.friction_brake_lock = Lock()  # dummy lock
        self.friction_brake = FrictionBrake(
            self.cfg, self.friction_brake_lock, self.detection
        )

    def _parse_args(self) -> argparse.Namespace:
        """Configure argument parser and parse command-line arguments.

        :return: Parsed command-line arguments.
        :rtype: argparse.Namespace
        """
        parser = argparse.ArgumentParser(description="Automate friction brake.")
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-e",
            "--exit-key",
            default="h",
            type=str,
            help="key to quit the script, h by default",
            metavar="KEY",
        )
        parser.add_argument(
            "-r",
            "--reset-key",
            default="g",
            type=str,
            help="key to reset friction brake, g by default",
            metavar="KEY",
        )
        args_list = shlex.split(self.cfg.SCRIPT.LAUNCH_OPTIONS) + sys.argv[1:]
        return parser.parse_args(args_list)

    def _on_release(self, key: keyboard.KeyCode) -> None:
        """Handle key release events for controlling the application.

        Exits the script or resets the friction brake based on the key pressed.

        :param key: The key that was released.
        :type key: keyboard.KeyCode
        """
        keystroke = str(key).lower()
        if keystroke == self.cfg.ARGS.EXIT_KEY:
            self.friction_brake.monitor_process.terminate()
            sys.exit()
        if keystroke == self.cfg.ARGS.RESET_KEY:
            self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)

    def _start(self):
        """Start the friction brake automation process.

        Begins the friction brake monitoring process and starts a keyboard listener
        to handle control keys.
        """
        self.friction_brake.monitor_process.start()
        with keyboard.Listener(on_release=self._on_release) as listener:
            listener.join()


if __name__ == "__main__":
    FrictionBrakeApp().start()



# === tools\calculate.py ===
"""Calculate the maximum friction brake you can use on your tackle.

This module provides functionality to calculate the maximum friction brake and tension
based on the reel's max drag, friction brake wear, leader's load capacity, and wear.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import sys

from rich import print
from rich.prompt import Prompt
from rich.table import Table

sys.path.append(".")
from rf4s import utils

BIAS = 1e-6


def get_tackle_stats():
    """Get actual stats of reel and leader based on their wears.

    Prompts the user for input and calculates the true max drag and load capacity
    after accounting for wear.

    :return: A tuple containing the true max drag and true load capacity.
    :rtype: tuple[float, float]
    """
    prompts = (
        "Reel's max drag (kg): ",
        "Reel's friction brake wear (%): ",
        "Leader's load capacity (kg): ",
        "Leader's wear (%): ",
    )

    while True:
        restart = False
        stats = []
        for prompt in prompts:
            validated_input = get_validated_input(prompt)
            if validated_input is None:
                restart = True
                break
            stats.append(validated_input)

        if restart:
            continue

        max_drag, friction_brake_wear, leader_load_capacity, leader_wear = stats
        true_max_drag = max_drag * (100 - friction_brake_wear) / 100
        true_load_capacity = leader_load_capacity * (100 - leader_wear) / 100
        return true_max_drag, true_load_capacity


def get_validated_input(prompt: str) -> float | None:
    """Get validated input from the user.

    Prompts the user for input and validates it. Supports quitting and restarting.

    :param prompt: The prompt message to display to the user.
    :type prompt: str
    :return: The validated input as a float, or None if the user chooses to restart.
    :rtype: float or None
    """
    while True:
        user_input = Prompt.ask(prompt)
        if user_input == "q":
            print("Bye.")
            sys.exit()
        if user_input == "r":
            return None

        try:
            return float(user_input)
        except ValueError:
            utils.print_error("Invalid input. Please enter a number.")


def main():
    """Main function to run the friction brake calculation.

    Prompts the user for input, calculates the results, and displays them in a table.
    """
    print("Please enter your tackle's stats, type q to quit, r to restart. ")
    while True:
        max_drag, load_capacity = get_tackle_stats()
        max_friction_brake = int(min(load_capacity * 30 / (max_drag + BIAS) - 1, 29))
        max_tension = max_drag * max_friction_brake / 30

        table = Table(
            "Results",
            title="Your tackle's real stats 🎣",
            show_header=False,
            min_width=36,
        )
        table.add_row("Reel's true max drag", f"{max_drag:.2f} kg")
        table.add_row("Leader's true load capacity", f"{load_capacity:.2f} kg")
        table.add_row("Friction brake tension", f"{max_tension:.2f} kg")
        table.add_row("Maximum friction brake to use", f"{max_friction_brake}")
        print(table)


if __name__ == "__main__":
    main()



# === tools\craft.py ===
"""Activate game window and start crafting things until running out of materials.

This module automates the crafting process in Russian Fishing 4. It supports
discarding crafted items, fast crafting mode, and a configurable crafting limit.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

# pylint: disable=no-member
# setting node's attributes will be merged on the fly

import argparse
import logging
import random
import sys
from datetime import datetime
from pathlib import Path
from time import sleep

import pyautogui as pag
from rich.logging import RichHandler

sys.path.append(".")

from rf4s.app.app import App
from rf4s.config.config import print_cfg
from rf4s.controller.detection import Detection

CRAFT_DELAY = 4.0
CRAFT_DELAY_2X = 8.0

ANIMATION_DELAY = 0.5
ANIMATION_DELAY_2X = 1.0
ROOT = Path(__file__).resolve().parents[1]

logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[RichHandler(rich_tracebacks=True)],
)
logger = logging.getLogger("rich")


class CraftApp(App):
    """Main application class for automating crafting.

    This class manages the configuration, detection, and execution of the crafting
    process. It tracks the number of successful and failed crafts, as well as the
    total number of materials used.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        window (Window): Game window controller instance.
        detection (Detection): Detection instance for in-game state checks.
        success_count (int): Number of successful crafts.
        fail_count (int): Number of failed crafts.
        craft_count (int): Total number of crafting attempts.
    """

    def __init__(self):
        """Initialize the application.

        Loads configuration, parses command-line arguments, and sets up the game window
        and detection instances.
        """
        super().__init__()
        print_cfg(self.cfg.ARGS)

        self.detection = Detection(self.cfg, self.window)

        self.success_count = 0
        self.fail_count = 0
        self.craft_count = 0

    def _parse_args(self) -> argparse.Namespace:
        """Configure argument parser and parse command-line arguments.

        :return: Parsed command-line arguments.
        :rtype: argparse.Namespace
        """
        parser = argparse.ArgumentParser(description="Craft items automatically.")
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-d",
            "--discard",
            action="store_true",
            help="discard all the crafted items (for groundbaits)",
        )
        parser.add_argument(
            "-f",
            "--fast",
            action="store_true",
            help="disable delay randomization to speed up crafting",
        )
        parser.add_argument(
            "-n",
            "--craft-limit",
            type=int,
            default=-1,
            help="number of items to craft, no limit by default",
            metavar="LIMIT",
        )
        return parser.parse_args()

    def _start(self) -> None:
        """Main loop for crafting items.

        Executes the primary loop for crafting items until materials are exhausted or
        the crafting limit is reached. Supports fast crafting mode and discarding items.
        """
        random.seed(datetime.now().timestamp())
        craft_delay = CRAFT_DELAY
        click_delay = ANIMATION_DELAY

        make_button_position = self.detection.get_make_button_position()
        if make_button_position is None:
            logger.critical(
                "Make button not found, please set the interface scale to "
                "1x or move your mouse around"
            )
            self.window.activate_script_window()
            return
        pag.moveTo(make_button_position)

        while self.detection.is_material_complete():
            logger.info("Crafting item")
            pag.click()

            if not self.cfg.ARGS.FAST:
                craft_delay = random.uniform(CRAFT_DELAY, CRAFT_DELAY_2X)
                click_delay = random.uniform(ANIMATION_DELAY, ANIMATION_DELAY_2X)
            sleep(craft_delay)

            while True:
                if self.detection.is_operation_success():
                    logger.info("Item crafted successfully")
                    self.success_count += 1
                    break

                if self.detection.is_operation_failed():
                    logger.warning("Failed to craft item")
                    self.fail_count += 1
                    break
                sleep(ANIMATION_DELAY)
            self.craft_count += 1

            pag.press("backspace" if self.cfg.ARGS.DISCARD else "space")
            if self.craft_count >= self.cfg.ARGS.CRAFT_LIMIT:
                break
            sleep(click_delay)


if __name__ == "__main__":
    CraftApp().start(
        (
            ("Success


# === tools\harvest.py ===
"""Script for automatic baits harvesting and hunger/comfort refill.

This module provides functionality to automate the harvesting of baits and refilling
of hunger and comfort in Russian Fishing 4. It includes options for power-saving
mode and configurable check delays.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

# pylint: disable=no-member
# setting node's attributes will be merged on the fly

import argparse
import logging
import sys
from pathlib import Path
from time import sleep

import pyautogui as pag
from rich.logging import RichHandler
from yacs.config import CfgNode as CN

sys.path.append(".")

from rf4s import utils
from rf4s.app.app import App
from rf4s.config.config import print_cfg
from rf4s.controller.detection import Detection
from rf4s.controller.timer import Timer

ROOT = Path(__file__).resolve().parents[1]

logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[RichHandler(rich_tracebacks=True)],
)
logger = logging.getLogger("rich")

ANIMATION_DELAY = 0.5


class HarvestApp(App):
    """Main application class for automating bait harvesting and hunger/comfort refill.

    This class manages the configuration, detection, and execution of the harvesting
    and refill processes. It also handles power-saving mode and check delays.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        window (Window): Game window controller instance.
        detection (Detection): Detection instance for in-game state checks.
        timer (Timer): Timer instance for managing cooldowns.
        tea_count (int): Number of tea consumed.
        carrot_count (int): Number of carrots consumed.
        harvest_count (int): Number of baits harvested.
    """

    def __init__(self):
        """Initialize the application.

        Loads configuration, parses command-line arguments, and sets up the game window,
        detection, and timer instances.
        """
        super().__init__()
        print(self.cfg.ARGS)

        self.detection = Detection(self.cfg, self.window)
        self.timer = Timer(self.cfg)

        self.tea_count = 0
        self.carrot_count = 0
        self.harvest_count = 0

    def _parse_args(self) -> argparse.Namespace:
        """Configure argument parser and parse command-line arguments.

        :return: Parsed command-line arguments.
        :rtype: argparse.Namespace
        """
        parser = argparse.ArgumentParser(
            description="Harvest baits and refill hunger/comfort automatically.",
        )
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-r",
            "--refill",
            action="store_true",
            help="refill hunger and comfort by consuming tea and carrot",
        )
        parser.add_argument(
            "-s",
            "--power-saving",
            action="store_true",
            help="open control panel between checks to reduce power consumption",
        )
        parser.add_argument(
            "-n",
            "--check-delay",
            type=int,
            default=32,
            help="delay time between each checks, 32s by default",
        )
        return parser.parse_args()

    def _harvest_baits(self) -> None:
        """Harvest baits from the game.

        The digging tool should be pulled out before calling this method. Waits for
        harvest success and presses the spacebar to complete the process.
        """
        logger.info("Harvesting baits")
        # Dig and wait (4 + 1)s
        pag.click()
        sleep(5)

        i = 64
        while i > 0 and not self.detection.is_harvest_success():
            i = utils.sleep_and_decrease(i, 2)
        pag.press("space")
        logger.info("Baits harvested succussfully")
        sleep(ANIMATION_DELAY)

    def _consume_food(self, food: str) -> None:
        """Consume a specific type of food.

        Opens the food menu, moves the cursor to the food's position, and clicks to consume it.

        :param food: The type of food to consume (e.g., "tea" or "carrot").
        :type food: str
        """
        logger.info("Consuming %s", food)
        with pag.hold("t"):
            sleep(ANIMATION_DELAY)
            pag.moveTo(self.detection.get_food_position(food))
            pag.click()
        sleep(ANIMATION_DELAY)

    def _start(self) -> None:
        """Main loop for eating and harvesting.

        Executes the primary loop for checking hunger/comfort levels, consuming food,
        and harvesting baits. Supports power-saving mode and configurable check delays.
        """
        pag.press(str(self.cfg.KEY.DIGGING_TOOL))
        sleep(3)
        while True:
            if self.cfg.ARGS.REFILL:
                if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
                    self._consume_food("tea")
                    self.tea_count += 1

          


# === tools\main.py ===
"""Main CLI for Russian Fishing 4 Script.

This module provides the command-line interface and main execution logic
for automating fishing in Russian Fishing 4. It handles configuration,
argument parsing, window management, and fishing automation.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

# pylint: disable=no-member

import logging
import os
import shlex
import signal
import smtplib
import sys
from argparse import ArgumentParser, Namespace
from pathlib import Path
from socket import gaierror

from pynput import keyboard
from rich import box, print
from rich.logging import RichHandler
from rich.panel import Panel
from rich.style import Style
from rich.table import Column, Table
from yacs.config import CfgNode as CN

sys.path.append(".")  # python -m module -> python file

from rf4s import utils
from rf4s.config import config
from rf4s.controller.window import Window
from rf4s.player import Player

# Ignore %(name)s because it's verbose
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[RichHandler(rich_tracebacks=True)],
)
logger = logging.getLogger("rich")
# Reference: https://rich.readthedocs.io/en/latest/logging.html

ARGUMENTS = (
    ("c", "coffee", "drink coffee if stamina is low"),
    ("A", "alcohol", "drink alcohol before keeping the fish regularly"),
    ("r", "refill", "refill hunger and comfort by consuming tea and carrot"),
    ("H", "harvest", "harvest baits before casting"),
    ("g", "gear_ratio", "switch the gear ratio after the retrieval timed out"),
    ("f", "friction_brake", "enable auto friction brake"),
    ("l", "lift", "lift the tackle constantly while pulling a fish"),
    ("C", "skip_cast", "Immediately start retrieving for the first fish"),
    ("o", "spod_rod", "recast spod rod regularly"),
    ("L", "lure", "change current lure with a random one regularly, mode: spin"),
    ("x", "mouse", "move mouse randomly before casting the rod"),
    ("X", "pause", "pause the script before casting the rod regularly"),
    ("b", "bite", "take a screenshot after casting in screenshots/ (for fish spot)"),
    ("S", "screenshot", "take a screenshot of every fish you caught in screenshots/"),
    ("e", "email", "send email noticication after the script stop"),
    ("P", "plot", "save fishing data in /logs"),
    ("M", "miaotixing", "send miaotixing notification after the script stop"),
    ("s", "shutdown", "shutdown computer after the script stop"),
    ("so", "signout", "Sign out instead of closing the game"),
    ("gb", "groundbait", "enable groundbait refill, mode: bottom"),
    ("dm", "dry_mix", "enable dry mix refill, mode: bottom"),
    ("pva", "pva", "enable pva refill, mode: bottom"),
    ("E", "electro", "enable electric mode for Electro Raptor series reel"),
)

LOGO = """
██████╗ ███████╗██╗  ██╗███████╗
██╔══██╗██╔════╝██║  ██║██╔════╝
██████╔╝█████╗  ███████║███████╗
██╔══██╗██╔══╝  ╚════██║╚════██║
██║  ██║██║          ██║███████║
╚═╝  ╚═╝╚═╝          ╚═╝╚══════╝"""
GITHUB_LINK = "GitHub: https://github.com/dereklee0310/RussianFishing4Script"
DISCORD_LINK = "Discord: https://discord.gg/BZQWQnAMbY"
# https://patorjk.com/software/taag/#p=testall&f=3D-ASCII&t=RF4S%0A, ANSI Shadow

ROOT = Path(__file__).resolve().parents[1]


class Rf4sApp:
    """Main application class for Russian Fishing 4 automation.

    This class orchestrates the entire automation process, from parsing command-line
    arguments to configuring the environment and executing the fishing routine.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        args (Namespace): Parsed command-line arguments.
        window (Window): Game window controller instance.
        player (Player): Player instance for fishing automation.
    """

    def __init__(self):
        """Initialize the application.

        Loads configuration, parses command-line arguments, and sets up the environment.
        """
        print(Panel.fit(LOGO, box=box.HEAVY), GITHUB_LINK, DISCORD_LINK, sep="\n")
        self.cfg = config.setup_cfg()
        self.cfg.merge_from_file(ROOT / "config.yaml")

        # Parser will use the last occurence if the arguments are duplicated,
        # so put argv at the end to overwrite launch options.
        args_list = shlex.split(self.cfg.SCRIPT.LAUNCH_OPTIONS) + sys.argv[1:]
        self.parser = self._setup_parser()
        args = self.parser.parse_args(args_list)
        if not self._is_args_valid(args):
            sys.exit(1)

        args_cfg = CN({"ARGS": config.dict_to_cfg(vars(args))})
        self.cfg.merge_from_other_cfg(args_cfg)
        self.args = args

    def _setup_parser(self) -> ArgumentParser:
        """Configure the argument parser with all supported command-line options.

        :return: Configured ArgumentParser instance with all options and flags.
        :rtype: ArgumentParser
        """
        parser = ArgumentParser(description="Start AFK script for Russ


# === tools\move.py ===
"""Movement automation for Russian Fishing 4 using keyboard controls.

This module automates character movement in Russian Fishing 4 by simulating W key presses.
Supports toggling movement state and includes optional Shift key integration for sprinting.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

# pylint: disable=no-member

import argparse
import sys
from pathlib import Path

import pyautogui as pag
from pynput import keyboard

sys.path.append(".")

from rf4s import utils
from rf4s.app.app import App
from rf4s.config.config import print_cfg

ROOT = Path(__file__).resolve().parents[1]


class MoveApp(App):
    """Main controller for movement automation in Russian Fishing 4.

    Manages configuration, keyboard event listeners, and W/Shift key simulation.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        window (Window): Game window controller instance.
        w_key_pressed (bool): Tracks current state of W key simulation.
    """

    def __init__(self):
        """Initialize configuration, CLI arguments, and game window.

        Merges configurations from multiple sources (YAML, CLI) and prepares
        the game window controller.
        """
        super().__init__()

        # Format key
        self.cfg.defrost()
        self.cfg.ARGS.EXIT_KEY = f"'{self.cfg.ARGS.EXIT_KEY}'"
        self.cfg.ARGS.PAUSE_KEY = f"'{self.cfg.ARGS.PAUSE_KEY}'"
        self.cfg.freeze()
        print_cfg(self.cfg.ARGS)

        self.w_key_pressed = True

    def _parse_args(self) -> argparse.Namespace:
        """Parse command-line arguments.

        :return: Parsed arguments containing runtime configuration.
        :rtype: argparse.Namespace
        """
        parser = argparse.ArgumentParser(
            description="Moving the game character forward with W key."
        )
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-s", "--shift", action="store_true", help="Hold Shift key while moving"
        )
        parser.add_argument(
            "-e",
            "--exit-key",
            default="s",
            type=str,
            help="key to quit the script, s by default",
            metavar="KEY",
        )
        parser.add_argument(
            "-r",
            "--pause-key",
            default="w",
            type=str,
            help="key to pause the script, w by default",
            metavar="KEY",
        )
        return parser.parse_args()

    def _on_release(self, key: keyboard.KeyCode) -> None:
        """Handle keyboard release events for script control.

        :param key: Key released by the user.
        :type key: keyboard.KeyCode
        """
        if str(key).lower() == self.cfg.ARGS.EXIT_KEY:
            sys.exit()
        elif str(key).lower() == self.cfg.ARGS.PAUSE_KEY:
            if self.w_key_pressed:
                self.w_key_pressed = False
                return
            pag.keyDown("w")
            self.w_key_pressed = True

    @utils.release_keys_after(arrow_keys=True)
    def _start(self) -> None:
        """Start automation and keyboard listener.

        Begins W key simulation (with optional Shift key) and enters blocking listener loop.
        Automatically releases keys when stopped via decorator.
        """

        if self.cfg.ARGS.SHIFT:
            pag.keyDown("shift")
        pag.keyDown("w")

        # blocking listener loop
        with keyboard.Listener(on_release=self._on_release) as listener:
            listener.join()


if __name__ == "__main__":
    MoveApp().start()

