Структура папки:
📁 docs/
    📁 en/
            📄 CHANGELOG.md  [Текстовый файл]:
**[[中文版]][CHANGELOG]**

## 0.5.0 (2025-06-06)

### 🆕 New Features
- **Discord Webhook Integration**: Added support for termination notifications via Discord webhooks. Set it with `NOTIFICATION.DISCORD_WEBHOOK_URL`.
- **Enhanced Tag Detection**: Added precise colored tag identification. Configure filtering with `KEEPNET.TAGS`.
- **Tag Filtering in Screenshots**: Integrated tag detection into screenshots. Use `SCRIPT.SCREENSHOT_TAGS` for filtering.
- **Profile-Specific Launch Options**: Profiles now support `LAUNCH_OPTIONS` that override global `SCRIPT.LAUNCH_OPTIONS`.
- **Bottom Mode Enhancement**: Added `PUT_DOWN_DELAY` to wait before checking other rods after hooking a fish.
- **Automated Gift Handling**: Automatically accepts gifts. Configure delay with `GIFT_DELAY`.
- **Random Rod Cast (`-RC`)**: Added flag for redundant casts. Adjust probability via `SCRIPT.RANDOM_CAST_PROBABILITY`.

### 🔧 Improvements
- **Result Table**: More detailed information has been added.
- **Stage Transitions**: Smoother reset/retrieve/pull sequences.
- **Gear Protection**: Decreases friction brake before quitting when using `-f` flag.
- **Configuration Fallback**: Gracefully defaults to built-in settings on missing configurations.

### 🐛 Bug Fixes
- Fixed PVA/groundbait refill issues across different rigs.
- Fixed missing material checks during crafting.
- Fixed crash caused by small `CHECK_DELAY` values.
- Fixed improper merging of `opts` into launch options.
- Resolved incompatibility between `-E` and `-g` flags.
- Fixed unexpected termination of `pirk` mode in edge cases.

### 🗃️ Deprecations & Renames
- `KEEPNET.DELAY` → `KEEPNET.FISH_DELAY`.
- `KEEPNET.RELEASE_WHITELIST` → `KEEPNET.WHITELIST`.
- Renamed launch options for clarity and consistency. Run `python tools\main.py -h` for details.

### 🧼 Maintenance
- Migrated code formatting/linting from Pylint/Black to Ruff.

## 0.4.2 (2025-04-07)
- Fixed a bug where the friction brake threshold was not being applied correctly.
- Fixed unexpected termination due to running out of fillet when using pirk/elevator mode.

## 0.4.1 (2025-03-30)
- Fixed a bug that left/right trolling mode doesn't work properly.
- Fixed an issue where electro mode doesn't work and compatible with `-g` flag.
- Fixed broken lure detection mechanism.
- Fixed a bug that pause is hard to trigger when using "toggle moving forward" tool.
- Added missing `POST_ACCELERATION` setting to `BOLOGNESE` mode.
- Tools now display config before running.
- Improved configuration guide.

## 0.4.0 (2025-03-16)
- Fixed a bug that the casting power level cannot be set to a value other than 1 or 5.
- Added `RETRIEVAL_TIMEOUT` to `SPIN` mode, allowing the script fall back to normal retrieval after retrieval with lift/pause timed out.

## 0.3.0 (2025-03-16)
- Reduced the sensitivity of lure break detection to avoid abnormal termination in the RU version.
- Added a new `KEEPNET.BLACKLIST` setting, blacklisted fish will always be released.
- Added a new `SHIFT` setting to `PIRK` mode, allowing users to hold shift while pirking.
- Increased check frequency for better user experience.
- Fixed a bug that the auto-friction-brake is not working properly.
- Updated READMEs.

## 0.2.1 (2025-03-08)
- Fixed a bug that auto-friction-brake, snag detection, and spooling detection are always disabled even the correct flags are used.

## 0.2.0 (2025-03-07)
- Fixed a bug that `-c` feature is not working properly.
- Added a `DEPTH_ADJUST_DURATION` setting to the `pirk` fishing mode to allow the user to set the duration of tightening the fishing line after opening the reel to adjust the depth of the lure.

## 0.1.0 (2025-03-06)
- New config system, bolognese mode, trolling mode, window mode support, and more.

[CHANGELOG]: /docs/zh-TW/CHANGELOG.md
            📄 CONFIGURATION.md  [Текстовый файл]:
**[[中文版]][configuration]**
## Using Launch Options
You can use launch options to enable one or more features at startup.
### Display Help Message
```
python tools\main.py -h
```
### Help Message
```
usage: main.py [-h] [-R] [-t] [-c] [-a] [-r] [-H] [-L] [-m] [-P] [-RC] [-SC] [-l] [-e] [-FB] [-GR] [-b] [-s] [-d] [-E]
               [-M] [-D] [-S] [-SO] [-SR] [-DM] [-GB] [-PVA] [-p PID | -N PROFILE_NAME] [-n FISH_COUNT]
               [-BT [DURATION]] [-T [DIRECTION]] [-BL [ACTION]]
               [opts ...]

Start AFK script for Russian Fishing 4

positional arguments:
  opts                  overwrite configuration

options:
  -h, --help            show this help message and exit
  -R, --rainbow         rainbow line meter for retrieval detection
  -t, --tag             keep only tagged fishes
  -c, --coffee          drink coffee if stamina is low during a fish fight
  -a, --alcohol         drink alcohol before keeping the fish
  -r, --refill          consume tea and carrot if hunger or comfort is low
  -H, --harvest         harvest baits before casting the rod
  -L, --lure            change current lure with a random one, mode: spin
  -m, --mouse           move mouse randomly before casting the rod
  -P, --pause           pause the script before casting the rod occasionally
  -RC, --random-cast    do a redundant rod cast randomly
  -SC, --skip-cast      skip the first rod cast
  -l, --lift            lift the tackle constantly during a fish fight
  -e, --electro         enable electric mode for Electro Raptor series reel
  -FB, --friction-brake
                        adjust friction brake automatically
  -GR, --gear-ratio     switch the gear ratio after the retrieval timed out
  -b, --bite            save a screenshot in screenshots/ before rod cast (for bite spot)
  -s, --screenshot      save a screenshot in screenshots/ after you caught a fish
  -d, --data            save fishing data in /logs
  -E, --email           send email noticication after the script stop
  -M, --miaotixing      send miaotixing notification after the script stop
  -D, --discord         send Discord notification after the script stop
  -S, --shutdown        shutdown computer after the script stop
  -SO, --signout        sign out instead of closing the game
  -SR, --spod-rod       recast spod rod
  -DM, --dry-mix        enable dry mix refill, mode: bottom
  -GB, --groundbait     enable groundbait refill, mode: bottom
  -PVA, --pva           enable pva refill, mode: bottom
  -p PID, --pid PID     id of the profile you want to use
  -N PROFILE_NAME, --pname PROFILE_NAME
                        name of the profile you want to use
  -n FISH_COUNT, --fishes-in-keepnet FISH_COUNT
                        number of fishes in your keepnet, 0 by default
  -BT [DURATION], --boat-ticket [DURATION]
                        renew boat ticket, DURATION: 1, 2, 3 or 5, 5 by default
  -T [DIRECTION], --trolling [DIRECTION]
                        enable trolling mode, DIRECTION: 'forward', 'left', or 'right', 'forward' by default
  -BL [ACTION], --broken-lure [ACTION]
                        replace broken lure, ACTION: 'replace' or 'alarm', 'replace' by default
```
> [!TIP]
> Other tools like `craft.py` or `move.py` also support `-h` for displaying help messages. 

> [!IMPORTANT]
> Add tea and carrot/coffee to your **[favorites][favorite_food]** if you want to use `-r` or `-c` options.  
> To use a option that replaces an item for you, you also need to add items to your **[favorites][favorite_lure]**.

### Examples
**Set the number of fishes in the keepnet to 32 (68 fishes to catch):**
```
python tools\main.py -n 32
```
**Select profile 3, drink the coffee while battling against fish, and send an email to yourself when it stops:**
```
python tools\main.py -p 3 --c --email
```
**Consume carrots, tea, and coffee to replenish player stats, and harvest baits before casting if possible.:**
```
python tools\main.py -rcH
```
**Recast spod rod regularly and refill dry mix if possible:**
```
python tools\main.py -o -dm
```


## Configuration
### Configure Settings
Edit your settings in `config.yaml`, changes will be applied when you run the script again.  
For details on each settings, see [configuration references](#configuration-references).

### Add a New Profile
If you want to add a custom profile for your use case, copy a existing profile from the default configuration file, edit it, and add it back to the `PROFILE` section.

Here we add a new profile called `YOUR_NEW_PROFILE`, it would pop up in the profile list when you run the script again:
```yaml
PROFILE:
  SPIN:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "normal"
            .
            .
            .
  YOUR_NEW_PROFILE:
    MODE: "spin"
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    PRE_ACCELERATION: True
    POST_ACCELERATION: "off"
    TYPE: "normal"
```
> [!IMPORTANT]
> - Use a distint name for your new profile.  
> - Make sure the indentation level of the new profile is correct.
> - `MODE` must be `spin`, `bottom`, `pirk`, `elevator`, `telescopic`, or `bolognese`.

### Overwrite Configuration
Sometimes you might want to change a setting in `config.yaml` for one-time use,  
you can achieve this by using launch options without modifying your configuration file.  
Here's a simple example that overwrites your language setting:
```
python tools\main.py SCRIPT.LANGUAGE "ru"
```

### Two-rod Trolling Mode
Since trolling on a boat is just bottom fishing with trolling and direction keys pressed,  
you can combine a bottom fishing profile with the `-T` flag to get things done.  
There's no 3rd rod pod on the boat, so you should overwrite the bottom rod keys like this:
```
python tools\main.py -T KEY.BOTTOM_RODS "1, 2"
```

## Configuration References
```python
"""Default yacs config node."""

from yacs.config import CfgNode as CN

_C = CN()
_C.VERSION = "0.4.2"

# ---------------------------------------------------------------------------- #
#                                    General                                   #
# ---------------------------------------------------------------------------- #
_C.SCRIPT = CN()
_C.SCRIPT.LANGUAGE = "en"  # Language for the script. Options: en, ru, zh-TW, zh-CN
_C.SCRIPT.LAUNCH_OPTIONS = ""  # Default launch options for the script, e.g., -r -c -H
_C.SCRIPT.SMTP_VERIFICATION = True
_C.SCRIPT.IMAGE_VERIFICATION = True
_C.SCRIPT.SNAG_DETECTION = True
_C.SCRIPT.SPOOLING_DETECTION = True
_C.SCRIPT.RANDOM_ROD_SELECTION = True  # For bottom mode
# Confidence threshold for spooling detection (lower = more sensitive)
_C.SCRIPT.SPOOL_CONFIDENCE = 0.98
# Delay before recasting spod rod (in seconds)
# Use bottom mode and -o to enable it.
_C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800
# Delay before changing lure randomly (in seconds)
# Use spin mode and -L to enable it.
_C.SCRIPT.LURE_CHANGE_DELAY = 1800
_C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # Path to alarm sound file
# Probability to add a redundant rod cast (0.0 to 1.0)
_C.SCRIPT.RANDOM_CAST_PROBABILITY = 0.25
# When using -s flag, only take screenshot of the fishes with tags below
# If left empty, the script will take screenshot of every fish you caught
_C.SCRIPT.SCREENSHOT_TAGS = (
    "green",
    "yellow",
    "blue",
    "purple",
    "pink"
)

# ---------------------------------------------------------------------------- #
#                                  Key Binding                                 #
# ---------------------------------------------------------------------------- #
_C.KEY = CN()
_C.KEY.TEA = -1  # Key binding for tea. Set to -1 to use quick selection menu
_C.KEY.CARROT = -1  # Key binding for carrot. Set to -1 to use quick selection menu
_C.KEY.BOTTOM_RODS = (1, 2, 3)  # Key bindings for bottom rods
_C.KEY.COFFEE = 4  # Key binding for coffee. Set to -1 to use quick selection menu
_C.KEY.DIGGING_TOOL = 5  # Key binding for digging tool
_C.KEY.ALCOHOL = 6  # Key binding for alcohol
# Key binding for the main rod (used when harvesting baits with one rod)
_C.KEY.MAIN_ROD = 1
_C.KEY.SPOD_ROD = 7  # Key binding for the spod rod (used in bottom mode)
# Key binding to stop the script (default is Ctrl-C)
# If you want to use a special quitting shortcut, please refer to pynput's docs:
# https://pynput.readthedocs.io/en/latest/keyboard.html#pynput.keyboard.Key .
_C.KEY.QUIT = "CTRL-C"

# ---------------------------------------------------------------------------- #
#                                 Player Stats                                 #
# ---------------------------------------------------------------------------- #
_C.STAT = CN()
# Minimum energy level before drinking coffee/harvesting baits
_C.STAT.ENERGY_THRESHOLD = 0.74
_C.STAT.HUNGER_THRESHOLD = 0.5  # Minimum hunger level before consuming carrot
_C.STAT.COMFORT_THRESHOLD = 0.51  # Minimum comfort level before consuming tea
_C.STAT.TEA_DELAY = 300  # Delay between tea drinks (in seconds)
_C.STAT.COFFEE_LIMIT = 10  # Maximum coffee drinks per fish fight.
_C.STAT.COFFEE_PER_DRINK = 1  # Amount of coffee consumed per drink
_C.STAT.ALCOHOL_DELAY = 900  # Delay between alcohol drinks (in seconds)
_C.STAT.ALCOHOL_PER_DRINK = 1  # Amount of alcohol consumed per drink

# ---------------------------------------------------------------------------- #
#                   Friction Brake (Use -f flag to enable it)                  #
# ---------------------------------------------------------------------------- #
_C.FRICTION_BRAKE = CN()
_C.FRICTION_BRAKE.INITIAL = 29  # Initial friction brake value
_C.FRICTION_BRAKE.MAX = 30  # Maximum friction brake value
# Delay before starting to adjust friction brake after a fish is hooked
_C.FRICTION_BRAKE.START_DELAY = 2.0
_C.FRICTION_BRAKE.INCREASE_DELAY = 1.0  # Delay before increasing friction brake
_C.FRICTION_BRAKE.SENSITIVITY = "medium"  # Sensitivity of friction brake detection

# ---------------------------------------------------------------------------- #
#                                    Keepnet                                   #
# ---------------------------------------------------------------------------- #
_C.KEEPNET = CN()
_C.KEEPNET.CAPACITY = 100
_C.KEEPNET.FISH_DELAY = 0.0  # Delay before keeping the fish (for screenshots)
_C.KEEPNET.GIFT_DELAY = 4.0  # Delay before keeping the gift (for screenshots)
_C.KEEPNET.FULL_ACTION = "quit"  # Action when keepnet is full. Options: quit, alarm
# Whitelist for unmarked fish releasing when using -m flag
# Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.WHITELIST = (
    "mackerel",
    "saithe",
    "herring",
    "squid",
    "scallop",
    "mussel",
)
# Fish in the blacklist will always be released
# Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.BLACKLIST = ()
# Only the fish with any tags below would be kept when using -t flag
_C.KEEPNET.TAGS = (
    "green",
    "yellow",
    "blue"
    "purple",
    "pink"
)

# ---------------------------------------------------------------------------- #
#                                 Notification                                 #
# ---------------------------------------------------------------------------- #
_C.NOTIFICATION = CN()
_C.NOTIFICATION.EMAIL = "email@example.com"
_C.NOTIFICATION.PASSWORD = "password"
_C.NOTIFICATION.SMTP_SERVER = "smtp.gmail.com"
_C.NOTIFICATION.MIAO_CODE = "example"
_C.NOTIFICATION.DISCORD_WEBHOOK_URL = ""

# ---------------------------------------------------------------------------- #
#                       Pause ( use -X flag to enable it)                      #
# ---------------------------------------------------------------------------- #
_C.PAUSE = CN()
_C.PAUSE.DELAY = 1800  # Delay between pauses (in seconds)
_C.PAUSE.DURATION = 600  # Duration of pause (in seconds)

_C.PROFILE = CN()
# ---------------------------------------------------------------------------- #
#                             Spin Fishing Profile                             #
# ---------------------------------------------------------------------------- #
_C.PROFILE.SPIN = CN()
_C.PROFILE.SPIN.MODE = "spin"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.SPIN.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.SPIN.CAST_POWER_LEVEL = 5.0
# Delay after casting before lure sinks
_C.PROFILE.SPIN.CAST_DELAY = 6.0
# Duration to tighten the fishing line after casting
_C.PROFILE.SPIN.TIGHTEN_DURATION = 0.0
# Duration of retrieving the line or lifting the rod (right mosue button)
_C.PROFILE.SPIN.RETRIEVAL_DURATION = 0.0
# Delay after retrieving the line or lifting the rod (right mosue button)
_C.PROFILE.SPIN.RETRIEVAL_DELAY = 0.0
# Timeout for retrieving with pause/lift, followed by the normal retrieval
_C.PROFILE.SPIN.RETRIEVAL_TIMEOUT = 256.0
# Hold down the Shift key when performing special spin fishing techniques
_C.PROFILE.SPIN.PRE_ACCELERATION = False
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.SPIN.POST_ACCELERATION = "off"
# Type of special spin fishing technique to perform. Options: normal, pause, lift
_C.PROFILE.SPIN.TYPE = "normal"

_C.PROFILE.SPIN_WITH_PAUSE = CN()
_C.PROFILE.SPIN_WITH_PAUSE.MODE = "spin"
_C.PROFILE.SPIN_WITH_PAUSE.LAUNCH_OPTIONS = ""
_C.PROFILE.SPIN_WITH_PAUSE.CAST_POWER_LEVEL = 5.0
_C.PROFILE.SPIN_WITH_PAUSE.CAST_DELAY = 6.0
_C.PROFILE.SPIN_WITH_PAUSE.TIGHTEN_DURATION = 1.0
_C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DURATION = 1.0
_C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DELAY = 3.0
_C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_TIMEOUT = 256.0
_C.PROFILE.SPIN_WITH_PAUSE.PRE_ACCELERATION = False
_C.PROFILE.SPIN_WITH_PAUSE.POST_ACCELERATION = "off"
_C.PROFILE.SPIN_WITH_PAUSE.TYPE = "pause"


_C.PROFILE.SPIN_WITH_LIFT = CN()
_C.PROFILE.SPIN_WITH_LIFT.MODE = "spin"
_C.PROFILE.SPIN_WITH_LIFT.LAUNCH_OPTIONS = ""
_C.PROFILE.SPIN_WITH_LIFT.CAST_POWER_LEVEL = 5.0
_C.PROFILE.SPIN_WITH_LIFT.CAST_DELAY = 6.0
_C.PROFILE.SPIN_WITH_LIFT.TIGHTEN_DURATION = 0.0
_C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DURATION = 1.0
_C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DELAY = 1.0
_C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_TIMEOUT = 256.0
_C.PROFILE.SPIN_WITH_LIFT.PRE_ACCELERATION = False
_C.PROFILE.SPIN_WITH_LIFT.POST_ACCELERATION = "off"
_C.PROFILE.SPIN_WITH_LIFT.TYPE = "lift"


# ---------------------------------------------------------------------------- #
#                            Bottom Fishing Profile                            #
# ---------------------------------------------------------------------------- #
_C.PROFILE.BOTTOM = CN()
_C.PROFILE.BOTTOM.MODE = "bottom"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.BOTTOM.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.BOTTOM.CAST_POWER_LEVEL = 5.0
_C.PROFILE.BOTTOM.CAST_DELAY = 4.0  # Delay after casting before lure sinks
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.BOTTOM.POST_ACCELERATION = "off"
# Delay before checking fish bite on next rod
_C.PROFILE.BOTTOM.CHECK_DELAY = 32.0
# Maximum allowed misses before recasting the rod
_C.PROFILE.BOTTOM.CHECK_MISS_LIMIT = 16
# Delay before checking if a fish is hooked again and putting down the rod
_C.PROFILE.BOTTOM.PUT_DOWN_DELAY = 0.0


# ---------------------------------------------------------------------------- #
#                      Marine / Wakey Rig Pirking Profile                      #
# ---------------------------------------------------------------------------- #
_C.PROFILE.PIRK = CN()
_C.PROFILE.PIRK.MODE = "pirk"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.PIRK.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.PIRK.CAST_POWER_LEVEL = 1.0
_C.PROFILE.PIRK.CAST_DELAY = 4.0  # Delay after casting before lure sinks
_C.PROFILE.PIRK.SINK_TIMEOUT = 60.0  # Maximum time allowed for sinking
# Duration to tighten the line after sinking lure/adjusting lure depth
_C.PROFILE.PIRK.TIGHTEN_DURATION = 1.0
# Delay after opening reel to adjust lure depth, set this to 0 to recast the rod instead
_C.PROFILE.PIRK.DEPTH_ADJUST_DELAY = 4.0
# Durtion to tighten the line after opening reel for DEPTH_ADJUST_DELAY seconds
_C.PROFILE.PIRK.DEPTH_ADJUST_DURATION = 1.0
_C.PROFILE.PIRK.CTRL = False  # Hold Ctrl key during pirking
_C.PROFILE.PIRK.SHIFT = False  # Hold Shift key during pirking
# Duration of lifting the rod, set this to 0 if you want to wait instead of pirking
_C.PROFILE.PIRK.PIRK_DURATION = 0.5
_C.PROFILE.PIRK.PIRK_DELAY = 2.0  # Delay after lifting the rod
# Timeout for pirking session
_C.PROFILE.PIRK.PIRK_TIMEOUT = 32.0
# Retrieve the fishing line during pirking
_C.PROFILE.PIRK.PIRK_RETRIEVAL = False
# When a fish is hooked, check if the fish is still hooked
# after HOOK_DELAY seconds, continue pirking if not
_C.PROFILE.PIRK.HOOK_DELAY = 0.5
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.PIRK.POST_ACCELERATION = "auto"

_C.PROFILE.PIRK_WITH_RETRIEVAL = CN()
_C.PROFILE.PIRK_WITH_RETRIEVAL.MODE = "pirk"
_C.PROFILE.PIRK_WITH_RETRIEVAL.LAUNCH_OPTIONS = ""
_C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_POWER_LEVEL = 1.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_DELAY = 4.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.SINK_TIMEOUT = 60.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.TIGHTEN_DURATION = 1.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DELAY = 0.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DURATION = 1.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.CTRL = False
_C.PROFILE.PIRK_WITH_RETRIEVAL.SHIFT = False
_C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DURATION = 0.5
_C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DELAY = 2.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_TIMEOUT = 32.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_RETRIEVAL = True
_C.PROFILE.PIRK_WITH_RETRIEVAL.HOOK_DELAY = 0.5
_C.PROFILE.PIRK_WITH_RETRIEVAL.POST_ACCELERATION = "auto"

# Spin fishing with wakey rig at Ladoga Archipelago
_C.PROFILE.WAKEY_RIG = CN()
_C.PROFILE.WAKEY_RIG.MODE = "pirk"
_C.PROFILE.WAKEY_RIG.LAUNCH_OPTIONS = ""
_C.PROFILE.WAKEY_RIG.CAST_POWER_LEVEL = 1.0
_C.PROFILE.WAKEY_RIG.CAST_DELAY = 4.0
_C.PROFILE.WAKEY_RIG.SINK_TIMEOUT = 45.0
_C.PROFILE.WAKEY_RIG.TIGHTEN_DURATION = 1.0
_C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DELAY = 4.0
_C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DURATION = 1.0
_C.PROFILE.WAKEY_RIG.CTRL = True
_C.PROFILE.WAKEY_RIG.CTRL = False
_C.PROFILE.WAKEY_RIG.PIRK_DURATION = 1.5
_C.PROFILE.WAKEY_RIG.PIRK_DELAY = 4.0
_C.PROFILE.WAKEY_RIG.PIRK_TIMEOUT = 32.0
_C.PROFILE.WAKEY_RIG.PIRK_RETRIEVAL = False
_C.PROFILE.WAKEY_RIG.HOOK_DELAY = 0.5
_C.PROFILE.WAKEY_RIG.POST_ACCELERATION = "auto"

# ---------------------------------------------------------------------------- #
#                            Marine Elevator Profile                           #
# ---------------------------------------------------------------------------- #
_C.PROFILE.ELEVATOR = CN()
_C.PROFILE.ELEVATOR.MODE = "elevator"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.ELEVATOR.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.ELEVATOR.CAST_POWER_LEVEL = 1.0
# Delay after casting before lure sinks
_C.PROFILE.ELEVATOR.CAST_DELAY = 4.0
# Maximum time allowed for sinking
_C.PROFILE.ELEVATOR.SINK_TIMEOUT = 60.0
# Duration to tighten the line after sinking lure
_C.PROFILE.ELEVATOR.TIGHTEN_DURATION = 1.0
# Duration of retrieving the fishing line/opening the reel
_C.PROFILE.ELEVATOR.ELEVATE_DURATION = 4.0
# Delay after retrieving the fishing line/opening the reel
_C.PROFILE.ELEVATOR.ELEVATE_DELAY = 4.0
# Timeout for pirking session
_C.PROFILE.ELEVATOR.ELEVATE_TIMEOUT = 40.0
# Lock / Unlocking the reel after elevating timed out to drop the lure level by level
_C.PROFILE.ELEVATOR.DROP = False
# When a fish is hooked, check if the fish is still hooked
# after HOOK_DELAY seconds, continue elevating if not
_C.PROFILE.ELEVATOR.HOOK_DELAY = 0.5
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.ELEVATOR.POST_ACCELERATION = "auto"

_C.PROFILE.ELEVATOR_WITH_DROP = CN()
_C.PROFILE.ELEVATOR_WITH_DROP.MODE = "elevator"
_C.PROFILE.ELEVATOR_WITH_DROP.LAUNCH_OPTIONS = ""
_C.PROFILE.ELEVATOR_WITH_DROP.CAST_POWER_LEVEL = 1.0
_C.PROFILE.ELEVATOR_WITH_DROP.CAST_DELAY = 4.0
_C.PROFILE.ELEVATOR_WITH_DROP.SINK_TIMEOUT = 60.0
_C.PROFILE.ELEVATOR_WITH_DROP.TIGHTEN_DURATION = 1.0
_C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DURATION = 4.0
_C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DELAY = 4.0
_C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_TIMEOUT = 40.0
_C.PROFILE.ELEVATOR_WITH_DROP.DROP = True
_C.PROFILE.ELEVATOR_WITH_DROP.HOOK_DELAY = 0.5
_C.PROFILE.ELEVATOR_WITH_DROP.POST_ACCELERATION = "auto"

# ---------------------------------------------------------------------------- #
#                          Telescopic fishing Profile                          #
# ---------------------------------------------------------------------------- #
_C.PROFILE.TELESCOPIC = CN()
_C.PROFILE.TELESCOPIC.MODE = "telescopic"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.TELESCOPIC.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.TELESCOPIC.CAST_POWER_LEVEL = 5.0
# Delay after casting before lure sinks
_C.PROFILE.TELESCOPIC.CAST_DELAY = 4.0
# Sensitivity of float detection
_C.PROFILE.TELESCOPIC.FLOAT_SENSITIVITY = 0.68
_C.PROFILE.TELESCOPIC.CHECK_DELAY = 1.0  # Delay between fish bite checks
_C.PROFILE.TELESCOPIC.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
# Recast rod after timed out, designed for flowing water maps
_C.PROFILE.TELESCOPIC.DRIFT_TIMEOUT = 16.0
# Shape of the float camera, the script tracks the whole camrea window by default
# Options: square, wide, tall
_C.PROFILE.TELESCOPIC.CAMERA_SHAPE = "square"


# ---------------------------------------------------------------------------- #
#                           Bolognese Fishing Profile                          #
# ---------------------------------------------------------------------------- #
_C.PROFILE.BOLOGNESE = CN()
_C.PROFILE.BOLOGNESE.MODE = "bolognese"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.BOLOGNESE.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.BOLOGNESE.CAST_POWER_LEVEL = 5.0
# Delay after casting before lure sinks
_C.PROFILE.BOLOGNESE.CAST_DELAY = 4.0
# Sensitivity of float detection
_C.PROFILE.BOLOGNESE.FLOAT_SENSITIVITY = 0.68
_C.PROFILE.BOLOGNESE.CHECK_DELAY = 1.0  # Delay between fish bite checks
_C.PROFILE.BOLOGNESE.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
# Recast rod after timed out, designed for flowing water maps
_C.PROFILE.BOLOGNESE.DRIFT_TIMEOUT = 32.0
# Shape of the float camera, the script tracks the whole camrea window by default
# Options: square, wide, tall
# (Fallback to float camera detection mode if the window size is not supported)
_C.PROFILE.BOLOGNESE.CAMERA_SHAPE = "square"
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.BOLOGNESE.POST_ACCELERATION = "off"


def get_cfg_defaults():
    """Get a yacs CfgNode object with default values for my_project."""
    # Return a clone so that the defaults will not be altered
    # This is for the "local variable" use pattern
    return _C.clone()

```

[configuration]: /docs/zh-TW/CONFIGURATION.md
[favorite_food]: /static/readme/favorite_food.png
[favorite_lure]: /static/readme/favorite_lure.png
            📄 INSTALLATION.md  [Текстовый файл]:
**[[中文版]][installation]**
### Approach 1: Clone via Git
```
git clone https://github.com/dereklee0310/RussianFishing4Script.git
cd RussianFishing4Script
.\setup.bat
```
> [!IMPORTANT] 
> Git must be installed on your system.
### Approach 2: Manual Download
1. [Download this repository][download].
2. Right-click `RussianFishing4Script-main.zip` and select "Extract here".
3. Open the extracted folder (`RussianFishing4Script-main`) and double-click `setup.bat` to install dependencies.
> [!TIP] 
> Create a virtual environment to avoid version conflicts if you already have Python installed.

> [!WARNING] 
> The download path cannot contain non-English characters.

## Environment Setup
### Enable Mouse ClickLock
- Go to Windows Mouse Settings > Enable **[Mouse ClickLock][clicklock]**.
- Set the time before locking to "Long".
### Language
- Confirm your game language matches the language setting in config.yaml (default is "en").
### Display
- Set both system and in-game interface scales to "1x".
- Use "window mode" or "borderless windowed" for the game window mode.
### Spool Detection
- By default, the bot checks the status of the spool (red box) for retrieval detection.  
  The spool must be filled with fishing line so the bot can decide whether the retriaval is finished.
- If you have rainbow line equiped, use `-R` option to detect meter instead (green box) for better accuracy. 
- Please refer to [configuration guide][configuration] to see how to use launch options.
  
![status]

[installation]: /docs/zh-TW/INSTALLATION.md
[download]: https://github.com/dereklee0310/RussianFishing4Script/archive/refs/heads/main.zip
[configuration]: /docs/en/CONFIGURATION.md
[clicklock]: /static/readme/clicklock.png
[status]: /static/readme/status.png
    📁 zh-TW/
            📄 CHANGELOG.md  [Текстовый файл]:
**[[English version]][CHANGELOG]**

## 0.5.0 (2025-06-06)

### 🆕 新功能
- **Discord Webhook 整合**：新增腳本終止通知的 Discord Webhook 支持。使用 `NOTIFICATION.DISCORD_WEBHOOK_URL` 進行設定。
- **增強標籤檢測**：新增精確識別彩色標籤功能。通過 `KEEPNET.TAGS` 配置過濾條件。
- **截圖標籤過濾**：將標籤檢測整合至截圖功能。使用 `SCRIPT.SCREENSHOT_TAGS` 配置過濾條件。
- **設定檔專屬啟動參數**：設定檔新增 `LAUNCH_OPTIONS` 優先級覆蓋全域 `SCRIPT.LAUNCH_OPTIONS`。
- **底部模式優化**：新增 `PUT_DOWN_DELAY` 參數，在釣到魚後等待指定時間再檢查其他魚竿。
- **自動禮物處理**：新增自動接收禮物功能。通過 `GIFT_DELAY` 配置等待時間。
- **隨機拋竿 (`-RC`)**：新增冗餘拋竿指令。通過 `SCRIPT.RANDOM_CAST_PROBABILITY` 調整概率。

### 🔧 改進
- **結果表格**：新增更詳細的顯示資訊。
- **階段過渡**：重置／回收／提竿流程更流暢。
- **裝備保護**：使用 `-f` 參數退出時自動降低捲線器阻力。
- **設定回退**：遺失設定項時優雅回退至內建預設值。

### 🐛 錯誤修復
- 修復不同釣組下 PVA／誘餌補給異常問題。
- 修復製作物品時未檢測材料耗盡的問題。
- 修復小 `CHECK_DELAY` 值導致崩潰的問題。
- 修復 `opts` 參數未正確合併至啟動參數的問題。
- 解決 `-E` 和 `-g` 參數衝突問題。
- 修復 `pirk` 模式在極端情況下意外終止的問題。

### 🗃️ 棄用與重新命名
- `KEEPNET.DELAY` → `KEEPNET.FISH_DELAY`。
- `KEEPNET.RELEASE_WHITELIST` → `KEEPNET.WHITELIST`。
- 啟動參數名稱優化統一。執行 `python tools\main.py -h` 查看詳細變更。

### 🧼 維護
- 程式碼格式化／檢查工具從 Pylint／Black 遷移至 Ruff。

## 0.4.2 (2025-04-07)
- 修復摩擦制動閾值設定未正確生效的問題。
- 修正使用打狀態／電梯模式時，當魚餌耗盡導致腳本意外終止的問題。

## 0.4.1 (2025-03-30)
- 修復左／右拖釣模式無法正常運作的錯誤。
- 修復電輪模式無法運作及與 `-g` 相容性的問題。
- 修復損壞的誘餌偵測機制。
- 修復使用「切換前進」工具時暫停功能難以觸發的問題。
- 為 `BOLOGNESE` 模式新增遺漏的 `POST_ACCELERATION` 設定。
- 工具現在會在執行前顯示設定。
- 改進設定指南。

## 0.4.0 (2025-03-16)
- 修復了拋竿力度無法設定的問題。
- 為 `SPIN` 模式新增 `RETRIEVAL_TIMEOUT` 設定，讓腳本在打狀態超時後切換至正常收線模式。

## 0.3.0 (2025-03-16)
- 降低擬餌斷裂檢測的靈敏度，避免異常終止問題。
- 新增 `KEEPNET.BLACKLIST` 設定項，黑名單中的魚類將始終被放生。
- 為 `PIRK` 模式新增 `SHIFT` 設定，允許用戶在使用 pirking 時按住 shift 鍵操作。
- 提升檢測頻率以優化用戶體驗。
- 修復自動摩擦制動器無法正常運作的 bug。
- 更新 README 文件。

## 0.2.1 (2025-03-08)
- 修復了即使使用正確參數，自動摩擦制動／卡鉤檢測／捲線檢測仍被強制禁用的 bug。

## 0.2.0 (2025-03-07)
- 修復 `-c` 功能異常問題。
- 為 `pirk` 釣魚模式新增 `DEPTH_ADJUST_DURATION` 設定項，允許用戶設置開捲後收緊釣線調整誘餌深度的持續時間。

## 0.1.0 (2025-03-06)
- 全新配置系統，新增磯釣模式、拖釣模式、視窗模式支援等多項功能。

[CHANGELOG]: /docs/en/CHANGELOG.md
            📄 CONFIGURATION.md  [Текстовый файл]:
**[[English version]][configuration]**
## 使用啟動參數  
可通過啟動參數啟用一項或多項功能。  

### 顯示幫助信息  
```  
python tools\main.py -h  
```  

### 幫助信息說明  
```bash
usage: main.py [-h] [-R] [-t] [-c] [-a] [-r] [-H] [-L] [-m] [-P] [-RC] [-SC] [-l] [-e] [-FB] [-GR] [-b] [-s] [-d] [-E]
               [-M] [-D] [-S] [-SO] [-SR] [-DM] [-GB] [-PVA] [-p PID | -N PROFILE_NAME] [-n FISH_COUNT]
               [-BT [DURATION]] [-T [DIRECTION]] [-BL [ACTION]]
               [opts ...]

啟動《俄羅斯釣魚4》自動腳本

位置參數:
  opts                  覆寫配置文件參數

選項:
  -h, --help            顯示幫助訊息
  -R, --rainbow         使用彩虹線計量器偵測收線
  -t, --tag             僅保留已標記的魚
  -c, --coffee          體力不足時飲用咖啡恢復體力
  -a, --alcohol         在保存魚之前飲酒
  -r, --refill          當飢餓或舒適度過低時自動補充茶與胡蘿蔔
  -H, --harvest         拋竿前自動收餌
  -L, --lure            定期隨機更換擬餌（僅限路亞模式）
  -m, --mouse           拋竿前隨機移動滑鼠
  -P, --pause           偶爾暫停腳本運行
  -RC, --random-cast    隨機添加額外拋竿動作
  -SC, --skip-cast      跳過首次拋竿直接開始收線
  -l, --lift            遛魚時持續提竿以節省時間
  -e, --electro         為Electro Raptor系列捲線器啟用電動模式
  -FB, --friction-brake 啟用自動摩擦調整
  -GR, --gear-ratio     收線超時後切換齒輪比
  -b, --bite            拋竿前截圖保存至 screenshots/（可用於分析咬鉤點）
  -s, --screenshot      捕獲魚隻後自動截圖保存
  -d, --data            在/logs目錄保存釣魚數據
  -E, --email           腳本停止後發送郵件通知
  -M, --miaotixing      腳本停止後發送喵提醒通知
  -D, --discord         腳本停止後發送Discord通知
  -S, --shutdown        腳本結束後關閉電腦
  -SO, --signout        退出遊戲而非關機
  -SR, --spod-rod       定期重拋餌料竿（底釣模式）
  -DM, --dry-mix        補充乾混合餌（底釣模式）
  -GB, --groundbait     補充底餌（底釣模式）
  -PVA, --pva           補充PVA餌（底釣模式）
  -p PID, --pid PID     指定配置檔ID
  -N PROFILE_NAME, --pname PROFILE_NAME
                        指定配置檔名稱
  -n FISH_COUNT, --fishes-in-keepnet FISH_COUNT
                        魚護當前魚量（預設為0）
  -BT [DURATION], --boat-ticket [DURATION]
                        自動續費船票，時長：1, 2, 3或5小時（預設5小時）
  -T [DIRECTION], --trolling [DIRECTION]
                        啟用拖釣模式，方向：'forward','left','right'（預設按'j'前進）
  -BL [ACTION], --broken-lure [ACTION]
                        斷餌自動處理，操作：'replace'或'alarm'（預設更換）
``` 

> [!TIP]  
> 其他工具如`craft.py`或`move.py`也支持`-h`參數顯示幫助信息。

> [!IMPORTANT]
> 若需使用 `-r` 或 `-c` 參數，請將茶和胡蘿蔔/咖啡加入 **[收藏物品][favorite_food]**。  
> 需自動更換物品的功能，請將相關物品加入 **[收藏物品][favorite_lure]**。

### 使用示例  
**設置魚護當前魚量為32條（需捕獲68條）：**  
```  
python tools\main.py -n 32  
```  

**使用3號配置檔，遛魚時飲用咖啡，停止後發送郵件：**  
```  
python tools\main.py -p 3 --c --email  
```  

**自動補充體力/飢餓/舒適度，拋竿前收餌：**  
```  
python tools\main.py -rcH  
```  

**定期重拋餌料竿並補充乾混合餌：**  
```  
python tools\main.py -o -dm  
```  

## 配置文件  
### 修改設置  
編輯`config.yaml`後重新運行腳本即可生效。  
各項參數詳解參見[配置參數說明](#配置參數說明)。  

### 添加新配置檔  
1. 複製現有配置檔結構  
2. 修改參數後添加至`PROFILE`段落  

示例添加名為`YOUR_NEW_PROFILE`的路亞配置：  
```yaml  
PROFILE:  
  SPIN:   
    MODE: "spin"  
    CAST_POWER_LEVEL: 5.0  
    CAST_DELAY: 6.0  
    ...  
  
  YOUR_NEW_PROFILE:  
    MODE: "spin"  
    CAST_POWER_LEVEL: 5.0  
    CAST_DELAY: 4.0  # 縮短拋竿延遲  
    PRE_ACCELERATION: True  # 啟用預加速  
    ...  
```  

> [!IMPORTANT]  
> - 配置檔名稱需唯一  
> - 嚴格保持縮進格式  
> - `MODE`需為`spin`/`bottom`/`pirk`/`elevator`/`telescopic`/`bolognese`  

### 臨時覆寫配置  
無需修改文件，直接通過命令覆寫參數：  
```  
python tools\main.py SCRIPT.LANGUAGE "ru"  # 臨時設置腳本語言為俄語  
```  

### 雙竿拖釣模式  
組合底釣配置與`-T`參數實現：  
```  
python tools\main.py -T KEY.BOTTOM_RODS "1, 2"  # 指定使用1、2號快捷鍵位  
```  


## 配置參數說明  
```python  
"""YACS默認配置節點"""  

from yacs.config import CfgNode as CN  

_C = CN()  
_C.VERSION = "0.0.0"  

# --------------------------------- 通用設置 -------------------------------- #  
_C.SCRIPT = CN()  
_C.SCRIPT.LANGUAGE = "en" # 腳本語言: en/ru/zh-TW/zh-CN  
_C.SCRIPT.LAUNCH_OPTIONS = ""  # 默認啟動參數，如"-r -c -H"  
_C.SCRIPT.SMTP_VERIFICATION = True  # SMTP驗證  
_C.SCRIPT.IMAGE_VERIFICATION = True  # 圖像驗證  
_C.SCRIPT.SNAG_DETECTION = True  # 掛底檢測  
_C.SCRIPT.SPOOLING_DETECTION = True  # 線軸檢測  
_C.SCRIPT.RANDOM_ROD_SELECTION = True  # 底釣隨機選竿  
_C.SCRIPT.SPOOL_CONFIDENCE = 0.98  # 線軸檢測敏感度（值越低越敏感）  
_C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800  # 餌料竿重拋間隔（秒）  
_C.SCRIPT.LURE_CHANGE_DELAY = 1800  # 擬餌更換間隔（秒）  
_C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # 提示音文件路徑
_C.SCRIPT.RANDOM_CAST_PROBABILITY = 0.25 # 隨機拋竿失誤的機率
_C.SCRIPT.SCREENSHOT_TAGS = ( # 魚獲截圖的標記種類，列表為空的話所有的魚都會截圖
    "green",
    "yellow",
    "blue",
    "purple",
    "pink"
)

# --------------------------------- 快捷鍵設置 ------------------------------ #  
_C.KEY = CN()  
_C.KEY.TEA = -1  # 茶快捷鍵（-1使用快捷菜單）  
_C.KEY.CARROT = -1  # 胡蘿蔔快捷鍵  
_C.KEY.BOTTOM_RODS = (1, 2, 3)  # 底釣竿快捷鍵位  
_C.KEY.COFFEE = 4  # 咖啡快捷鍵  
_C.KEY.DIGGING_TOOL = 5  # 挖餌工具快捷鍵  
_C.KEY.ALCOHOL = 6  # 酒精飲品快捷鍵  
_C.KEY.MAIN_ROD = 1  # 主釣竿快捷鍵  
_C.KEY.SPOD_ROD = 7  # 餌料竿快捷鍵  
_C.KEY.QUIT = "CTRL-C"  # 退出快捷鍵  

# --------------------------------- 角色狀態 -------------------------------- #  
_C.STAT = CN()  
_C.STAT.ENERGY_THRESHOLD = 0.74  # 喝咖啡/收餌體力閾值  
_C.STAT.HUNGER_THRESHOLD = 0.5  # 食用胡蘿蔔飢餓閾值  
_C.STAT.COMFORT_THRESHOLD = 0.51  # 飲茶舒適度閾值  
_C.STAT.TEA_DELAY = 300  # 飲茶間隔（秒）  
_C.STAT.COFFEE_LIMIT = 10  # 單次遛魚最大咖啡飲用量  
_C.STAT.COFFEE_PER_DRINK = 1  # 單次飲用咖啡量  
_C.STAT.ALCOHOL_DELAY = 900  # 飲酒間隔（秒）  
_C.STAT.ALCOHOL_PER_DRINK = 1  # 單次飲酒量  

# ----------------------------- 摩擦剎車設置（需-f參數）----------------------- #  
_C.FRICTION_BRAKE = CN()  
_C.FRICTION_BRAKE.INITIAL = 29  # 初始剎車值  
_C.FRICTION_BRAKE.MAX = 30  # 最大剎車值  
_C.FRICTION_BRAKE.START_DELAY = 2.0  # 中魚後開始調整延遲（秒）  
_C.FRICTION_BRAKE.INCREASE_DELAY = 1.0  # 剎車增強間隔  
_C.FRICTION_BRAKE.SENSITIVITY = "medium"  # 檢測敏感度（low/medium/high）  

# --------------------------------- 魚護設置 -------------------------------- #  
_C.KEEPNET = CN()  
_C.KEEPNET.CAPACITY = 100  # 魚護容量  
_C.KEEPNET.FISH_DELAY = 0.0  # 存魚前延遲（用於截圖）
_C.KEEPNET.GIFT_DELAY = 4.0  # 接受禮物前延遲（用於截圖）
_C.KEEPNET.FULL_ACTION = "quit"  # 滿護操作：quit（退出）/alarm（警報）
# -m模式保留魚種
# 選項: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.WHITELIST = (  # -t模式保留魚種  
    "mackerel", "saithe", "herring",  
    "squid", "scallop", "mussel"  
)
# 魚種黑名單
# 選項: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.BLACKLIST = (
)
# -t模式保留魚的標記種類
_C.KEEPNET.TAGS = (
    "green",
    "yellow",
    "blue"
    "purple",
    "pink"
)

# ----------------------------- 通知設置 -------------------------------- #  
_C.NOTIFICATION = CN()  
_C.NOTIFICATION.EMAIL = "email@example.com"  # 郵箱地址  
_C.NOTIFICATION.PASSWORD = "password"  # 郵箱密碼  
_C.NOTIFICATION.SMTP_SERVER = "smtp.gmail.com"  # SMTP服務器  
_C.NOTIFICATION.MIAO_CODE = "example"  # 喵提醒識別碼
_C.NOTIFICATION.DISCORD_WEBHOOK_URL = "" # Discord Webhook 鍊結

# ----------------------------- 暫停設置（需-X參數）------------------------ #  
_C.PAUSE = CN()  
_C.PAUSE.DELAY = 1800  # 暫停間隔（秒）  
_C.PAUSE.DURATION = 600  # 暫停時長（秒）  

# ----------------------------- 配置檔詳解 -------------------------------- #  
_C.PROFILE = CN()  

## 路亞配置 ##  
_C.PROFILE.SPIN = CN()  
_C.PROFILE.SPIN.MODE = "spin"  
# 用於覆蓋 SCRIPT.LAUNCH_OPTIONS 的啟動參數
# 若未設置，將使用 SCRIPT.LAUNCH_OPTIONS 作為預設值
_C.PROFILE.SPIN.LAUNCH_OPTIONS = ""
_C.PROFILE.SPIN.CAST_POWER_LEVEL = 5.0  # 拋投力度等級（1~5級，5為全力拋投）  
_C.PROFILE.SPIN.CAST_DELAY = 6.0  # 拋竿後等待時間（秒）  
_C.PROFILE.SPIN.TIGHTEN_DURATION = 0.0  # 收緊釣線時長（秒）  
_C.PROFILE.SPIN.RETRIEVAL_DURATION = 0.0  # 收線/提竿持續時間（秒）  
_C.PROFILE.SPIN.RETRIEVAL_DELAY = 0.0  # 收線後延遲（秒）  
_C.PROFILE.SPIN.RETRIEVAL_TIMEOUT = 256.0 # 打狀態超時 （秒）
_C.PROFILE.SPIN.PRE_ACCELERATION = False  # 拋竿前按住Shift（特殊技法）  
_C.PROFILE.SPIN.POST_ACCELERATION = "off"  # 遛魚時加速模式（on/off/auto）  
_C.PROFILE.SPIN.TYPE = "normal"  # 操作類型：normal（常規）/pause（停頓）/lift（提拉）  

## 底釣配置 ##  
_C.PROFILE.BOTTOM = CN()
# 用於覆蓋 SCRIPT.LAUNCH_OPTIONS 的啟動參數
# 若未設置，將使用 SCRIPT.LAUNCH_OPTIONS 作為預設值
_C.PROFILE.BOTTOM.LAUNCH_OPTIONS = ""
_C.PROFILE.BOTTOM.MODE = "bottom"  
_C.PROFILE.BOTTOM.CAST_POWER_LEVEL = 5.0  # 拋投力度  
_C.PROFILE.BOTTOM.CAST_DELAY = 4.0  # 拋竿後等待時間（秒）  
_C.PROFILE.BOTTOM.POST_ACCELERATION = "off"  # 遛魚加速模式  
_C.PROFILE.BOTTOM.CHECK_DELAY = 32.0  # 檢查咬口間隔（秒）  
_C.PROFILE.BOTTOM.CHECK_MISS_LIMIT = 16  # 最大空竿次數後重拋  
_C.PROFILE.BOTTOM.PUT_DOWN_DELAY = 0.0  # 放下竿子前再次檢查延遲

## 海釣/維基配置（Pirk技法）##  
_C.PROFILE.PIRK = CN()  
_C.PROFILE.PIRK.MODE = "pirk"
# 用於覆蓋 SCRIPT.LAUNCH_OPTIONS 的啟動參數
# 若未設置，將使用 SCRIPT.LAUNCH_OPTIONS 作為預設值
_C.PROFILE.PIRK.LAUNCH_OPTIONS = ""
_C.PROFILE.PIRK.CAST_POWER_LEVEL = 1.0  # 拋投力度（淺拋）  
_C.PROFILE.PIRK.CAST_DELAY = 4.0  # 拋竿後等待時間（秒）  
_C.PROFILE.PIRK.SINK_TIMEOUT = 60.0  # 餌沉底超時（秒）  
_C.PROFILE.PIRK.TIGHTEN_DURATION = 1.0  # 收線緊繃時長（秒）
_C.PROFILE.PIRK.DEPTH_ADJUST_DELAY = 4.0  # 調整深度延遲（秒）  
_C.PROFILE.PIRK.DEPTH_ADJUST_DURATION = 1.0 # 調整深度後的收線時長（秒）
_C.PROFILE.PIRK.CTRL = False  # 抽竿時按住Ctrl
_C.PROFILE.PIRK.SHIFT = False  # 抽竿時按住Shift
_C.PROFILE.PIRK.PIRK_DURATION = 0.5  # 抽竿時長（秒）  
_C.PROFILE.PIRK.PIRK_DELAY = 2.0  # 抽竿後延遲（秒）  
_C.PROFILE.PIRK.PIRK_TIMEOUT = 32.0  # 抽竿超時（秒）  
_C.PROFILE.PIRK.PIRK_RETRIEVAL = False  # 抽竿時收線  
_C.PROFILE.PIRK.HOOK_DELAY = 0.5  # 中魚後檢查延遲（秒）  
_C.PROFILE.PIRK.POST_ACCELERATION = "auto"  # 遛魚加速模式 

## 升降釣法配置（深海升降釣組）##  
_C.PROFILE.ELEVATOR = CN()
_C.PROFILE.ELEVATOR.MODE = "elevator"
# 用於覆蓋 SCRIPT.LAUNCH_OPTIONS 的啟動參數
# 若未設置，將使用 SCRIPT.LAUNCH_OPTIONS 作為預設值
_C.PROFILE.ELEVATOR.LAUNCH_OPTIONS = ""
_C.PROFILE.ELEVATOR.CAST_POWER_LEVEL = 1.0  # 拋投力度等級（1~5級，1為輕拋）  
_C.PROFILE.ELEVATOR.CAST_DELAY = 4.0  # 拋竿後等待時間（秒）  
_C.PROFILE.ELEVATOR.SINK_TIMEOUT = 60.0  # 餌沉底超時（秒）  
_C.PROFILE.ELEVATOR.TIGHTEN_DURATION = 1.0  # 收緊釣線時長（秒）  
_C.PROFILE.ELEVATOR.ELEVATE_DURATION = 4.0  # 提升釣線持續時間（秒）  
_C.PROFILE.ELEVATOR.ELEVATE_DELAY = 4.0  # 提升後延遲（秒）  
_C.PROFILE.ELEVATOR.ELEVATE_TIMEOUT = 40.0  # 單次升降超時（秒）  
_C.PROFILE.ELEVATOR.DROP = False  # 超時後自動下沉釣組（逐層下降）  
_C.PROFILE.ELEVATOR.HOOK_DELAY = 0.5  # 中魚後檢查延遲（秒）  
_C.PROFILE.ELEVATOR.POST_ACCELERATION = "auto"  # 遛魚加速模式（on/off/auto）

## 浮標釣配置 ##  
_C.PROFILE.TELESCOPIC = CN()  
_C.PROFILE.TELESCOPIC.MODE = "telescopic"
# 用於覆蓋 SCRIPT.LAUNCH_OPTIONS 的啟動參數
# 若未設置，將使用 SCRIPT.LAUNCH_OPTIONS 作為預設值
_C.PROFILE.TELESCOPIC.LAUNCH_OPTIONS = ""
_C.PROFILE.TELESCOPIC.CAST_POWER_LEVEL = 5.0  # 拋投力度  
_C.PROFILE.TELESCOPIC.CAST_DELAY = 4.0  # 拋竿後等待時間（秒）  
_C.PROFILE.TELESCOPIC.FLOAT_SENSITIVITY = 0.68  # 浮標檢測敏感度（0~1）  
_C.PROFILE.TELESCOPIC.CHECK_DELAY = 1.0  # 檢查咬口間隔（秒）  
_C.PROFILE.TELESCOPIC.PULL_DELAY = 0.5  # 中魚後提竿延遲（秒）  
_C.PROFILE.TELESCOPIC.DRIFT_TIMEOUT = 16.0  # 漂流超時重拋（秒）  
_C.PROFILE.TELESCOPIC.CAMERA_SHAPE = "square"  # 浮標視窗形狀（square/wide/tall）  

## 博洛尼亞釣法配置 ##  
_C.PROFILE.BOLOGNESE = CN()  
_C.PROFILE.BOLOGNESE.MODE = "bolognese"
# 用於覆蓋 SCRIPT.LAUNCH_OPTIONS 的啟動參數
# 若未設置，將使用 SCRIPT.LAUNCH_OPTIONS 作為預設值
_C.PROFILE.BOLOGNESE.LAUNCH_OPTIONS = ""
_C.PROFILE.BOLOGNESE.CAST_POWER_LEVEL = 5.0  # 拋投力度  
_C.PROFILE.BOLOGNESE.CAST_DELAY = 4.0  # 拋竿後等待時間（秒）  
_C.PROFILE.BOLOGNESE.FLOAT_SENSITIVITY = 0.68  # 浮標檢測敏感度  
_C.PROFILE.BOLOGNESE.DRIFT_TIMEOUT = 32.0  # 漂流超時重拋（秒）
_C.PROFILE.BOLOGNESE.POST_ACCELERATION = "off"  # 遛魚加速模式（on/off/auto）

def get_cfg_defaults():  
    """獲取默認配置節點"""  
    return _C.clone()  
```  


## 喵提醒的MIAO_CODE配置方式
1. 關注微信公衆號 **[喵提醒][meow]**。
   
2. 新建提醒服務  
![meow_1] ![meow_2]

3. 效果展示  
![meow_3]

[configuration]: /docs/en/CONFIGURATION.md
[favorite_food]: /static/readme/favorite_food.png
[favorite_lure]: /static/readme/favorite_lure.png
[meow]: https://miaotixing.com/how
[meow_1]: /static/readme/mtx1.png
[meow_2]: /static/readme/mtx2.png
[meow_3]: /static/readme/mtx3.png
            📄 INSTALLATION.md  [Текстовый файл]:
**[[English version]][installation]**

## 安裝步驟
### 方法一：透過 Git 克隆
```
git clone https://github.com/dereklee0310/RussianFishing4Script.git
cd RussianFishing4Script
.\setup.bat
```
> [!IMPORTANT]  
> 系統必須已安裝 Git。
### 方法二：手動下載
1. [下載此儲存庫][download]。
2. 對 `RussianFishing4Script-main.zip` 按右鍵並選擇「解壓縮到當前位置」。
3. 開啟解壓後的資料夾 (`RussianFishing4Script-main`)，雙擊 `setup.bat` 以安裝依賴項。
> [!TIP] 
> 若已安裝 Python 其他版本，建議創建虛擬環境以避免依賴衝突。

> [!WARNING]  
> 下載路徑不得包含非英文字元。

## 環境設定
### 啟用滑鼠點擊鎖定
- 前往 Windows 滑鼠設定 > 啟用 **[滑鼠點擊鎖定][clicklock]**。
- 將鎖定前的時間設為「長」。
### 語言設定
- 確認遊戲語言與 `config.yaml` 中的語言設定一致（預設為 "EN"）。
### 顯示設定
- 將系統和遊戲內的介面縮放比例均設為「1x」。
- 遊戲視窗模式請使用「視窗模式」或「無邊框視窗」。
### 線軸偵測
- 預設情況下，機器人會檢查線軸（紅色框）狀態以判斷收線是否完成。  
  線軸必須裝滿線，機器人才能判斷收線是否結束。
- 若裝備彩虹釣線，請使用 `-R` 選項改為偵測線的米數（綠色框）以獲得更佳準確度。
- 請參閱 [設定指南][configuration] 瞭解如何使用啟動選項。
  
![status]

[installation]: /docs/en/INSTALLATION.md
[download]: https://github.com/dereklee0310/RussianFishing4Script/archive/refs/heads/main.zip
[configuration]: /docs/zh-TW/CONFIGURATION.md
[clicklock]: /static/readme/clicklock.png
[status]: /static/readme/status.png
            📄 README.md  [Текстовый файл]:
**[[English version]][readme]**
<div align="center">

![rf4s_logo]
<h1 align="center">RF4S: 俄羅斯釣魚4腳本</h1>

**俄羅斯釣魚4的簡易釣魚機器人，支援路亞、水底、海釣及手竿等模式。**

<a target="_blank" href="https://opensource.org/license/gpl-3-0" style="background:none">
    <img src="https://img.shields.io/badge/License-GPLv3-blue.svg" style="height: 22px;" />
</a>
<a target="_blank" href="https://discord.gg/BZQWQnAMbY" style="background:none">
    <img src="https://img.shields.io/badge/discord-join-rf44.svg?labelColor=191937&color=6F6FF7&logo=discord" style="height: 22px;" />
</a>
<a target="_blank" href="http://makeapullrequest.com" style="background:none">
    <img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat" style="height: 22px;" />
</a>
<!-- <a target="_blank" href="https://github.com/pylint-dev/pylint" style="background:none">
    <img src="https://img.shields.io/badge/代碼檢查-pylint-yellowgreen" style="height: 22px;" />
</a>
<a target="_blank" href="https://github.com/psf/black" style="background:none">
    <img src="https://img.shields.io/badge/代碼風格-black-000000.svg" style="height: 22px;" />
</a> -->
<!-- <a target="_blank" href="link_to_docs, tbd" style="background:none">
    <img src="https://img.shields.io/badge/文件-%23BE1B55" style="height: 22px;" />
</a> -->  

![Python 標章][python_badge]
![Windows 標章][windows_badge]

</div>

> [!TIP]
> 若想建議新功能、回報錯誤或取得使用幫助，請加入 [Discord 伺服器discordDiscord]。


## 快速入門
### 必要條件
下載並安裝 **[Python 3.12.*][python]**。  

> [!IMPORTANT]  
> 安裝時請務必勾選 **「將Python加入PATH」** 選項。  

> [!WARNING]  
> 不支援 Python 3.13 及以上版本。
### 安裝步驟
請參閱 **[安裝指南][installation]**。
## 使用方式
### 開始前注意事項...
- 執行腳本前，請先將角色移動至釣點
- 路亞/海釣/手竿/維基模式：手持要使用的釣竿。
- 底釣模式：
    - 將釣組添加至快捷欄位。
    - 拋竿後將釣竿放置在附近，以便腳本可透過快捷鍵（1 ~ 3）操作。
> [!NOTE]
> 目前僅底釣模式支援多竿操作。

### 開始執行！
1. 開啟 cmd/PowerShell
2. 進入專案目錄並執行腳本（按 `CTRL-C` 退出）：
```
cd "專案目錄路徑"
python tools\main.py
```
> [!TIP]
> `專案目錄路徑` 是克隆或解壓縮專案後存放檔案的目錄。  
> ![路徑示意][path]

> [!TIP]
> 進階設定和使用方式請參閱 **[設定指南][configuration]**。

## 工具集
### 製作物品
執行前選取材料，按 `Ctrl-C` 退出。
```
python tools\craft.py
```
### 自動挖餌
按 `Ctrl-C` 退出。
```
python tools\harvest.py
```
### 自動前進
按 `W` 暫停，按 `S` 退出。
```
python tools\move.py
```
### 自動調整摩擦
按 `G` 重置，按 `H` 退出。
```
python tools\auto_friction_brake.py
```
### 計算釣組數值與摩擦
```
python tools\calculate.py
```

## 疑難排解
<details>
<summary>如何停止腳本？</summary>

- 在終端機中輸入 `CTRL-C`。 
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>無法停止腳本？</summary>

- 可能按鍵被卡住（如 `CTRL-C`、`SHIFT`、滑鼠按鍵等），  
  重新按壓卡住的按鍵後，再輸入 `CTRL-C`。
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>拋竿卡在128%？</summary>

- 確認遊戲語言與腳本語言設定一致。
- 確保線軸已纏滿釣線，或裝備彩虹線並使用 `-R` 參數。 
</details>

<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>收線完成後未抬竿？</summary>

- 確保線軸已纏滿釣線，或裝備彩虹線並使用 `-R` 參數。 
- 調整遊戲視窗大小。
- 降低 `config.yaml` 中的 `SPOOL_CONFIDENCE` 數值。
- 遠離光源或關閉船燈。
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->
<details>
<summary>腳本執行但無反應？</summary>

- 以系統管理員身份開啟 cmd/Powershell 並重新執行。
</details>
<!-- ------------------------------- 分隔線 -------------------------------- -->

## 更新日誌
詳見 **[更新日誌][changelog]**。

## 授權條款
**[GNU General Public License version 3][license]**

## 貢獻指南
歡迎提交錯誤報告、功能建議或任何形式的貢獻。

## 聯絡作者
dereklee0310@gmail.com 

[readme]: /README.md

[rf4s_logo]: /static/readme/RF4S.png
[python_badge]: https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white
[windows_badge]: https://img.shields.io/badge/Windows-0078D6?style=for-the-badge&logo=windows&logoColor=white

[discord]: https://discord.gg/BZQWQnAMbY
[python]: https://www.python.org/downloads/
[installation]: /docs/zh-TW/INSTALLATION.md
[configuration]: /docs/zh-TW/CONFIGURATION.md
[changelog]: /docs/zh-TW/CHANGELOG.md
[path]: /static/readme/path.png
[license]: /LICENSE
    📄 LICENSE  [Текстовый файл]:
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

    📄 README.md  [Текстовый файл]:
**[[中文版]][readme]**
<div align="center">

![RF4S][rf4s_logo]
<h1 align="center">RF4S: Russian Fishing 4 Script</h1>

**A simple Russian Fishing 4 fishing bot, supporting spin, bottom, marine, and float fishing modes.**

<a target="_blank" href="https://opensource.org/license/gpl-3-0" style="background:none">
    <img src="https://img.shields.io/badge/License-GPLv3-blue.svg" style="height: 22px;" />
</a>
<a target="_blank" href="https://discord.gg/BZQWQnAMbY" style="background:none">
    <img src="https://img.shields.io/badge/discord-join-rf44.svg?labelColor=191937&color=6F6FF7&logo=discord" style="height: 22px;" />
</a>
<a target="_blank" href="http://makeapullrequest.com" style="background:none">
    <img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat" style="height: 22px;" />
</a>
<!-- <a target="_blank" href="https://github.com/pylint-dev/pylint" style="background:none">
    <img src="https://img.shields.io/badge/linting-pylint-yellowgreen" style="height: 22px;" />
</a> -->
<!-- <a target="_blank" href="https://github.com/psf/black" style="background:none">
    <img src="https://img.shields.io/badge/code%20style-black-000000.svg" style="height: 22px;" />
</a> -->
<!-- <a target="_blank" href="link_to_docs, tbd" style="background:none">
    <img src="https://img.shields.io/badge/docs-%23BE1B55" style="height: 22px;" />
</a> -->  

![Python badge][python_badge]
![Windows badge][windows_badge]

</div>

> [!TIP]
> Join the [Discord server][discord] if you want to suggest new features, report bugs or get help on how to use the script.


## Getting Started
### Prerequisites
Download and install **[Python 3.12.*][python]**.  

> [!IMPORTANT] 
> Ensure the **"Add Python to PATH"** option is selected during installation.  

> [!WARNING] 
> Python 3.13+ are not supported.
### Installation
See **[INSTALLATION][installation]**.
## Usage
### Before you start...
- Move your character to the fishing spot before running the script
- For Spin/Marine/Float/Wakey Rig Fishing: Pick up the rod you want to use.
- For Bottom Fishing:
    - Add tackles to quick selection slots.
    - Cast them and place them nearby so the bot can access them via shortcuts (1 ~ 3).
> [!NOTE]
> Currently, only bottom fishing mode support multiple rods.

### Let's Run it!
1. Open cmd/PowerShell
2. Navigate into the project directory and run the script with default configuration. Type `CTRL-C` to quit.
```
cd "path\to\the\project"
python tools\main.py
```
> [!TIP]
> `path\to\the\project` is the directory where you placed the files after cloning or extracting the project.  
> ![path]

> [!TIP]
> See **[CONFIGURATION][configuration]** for advanced usage and configuration options.

## Tools
### Craft items
Select materials before you run it, press `Ctrl-C` to quit.
```
python tools\craft.py
```
### Harvest baits
Press `Ctrl-C` to quit.
```
python tools\harvest.py
```
### Toggle moving forward
Press `W`to pause, `S` to quit.
```
python tools\move.py
```
### Automate friction brake
Press `G` to reset, `H` to quit.
```
python tools\auto_friction_brake.py
```
### Calculate tackle's stats and friction brake
```
python tools\calculate.py
```

## Troubleshooting
<details>
<summary>How to stop the script?</summary>

- Type `Ctrl-C` in your terminal. 
</details>
<!-- ------------------------------- divide -------------------------------- -->
<details>
<summary>Can't stop the script?</summary>

- Some keys might have been pressed down (e.g. `Ctrl`, `Shift`, `Mouse button`, etc.),  
  press them again to release it and type `Ctrl-C` as usual.
</details>
<!-- ------------------------------- divide -------------------------------- -->
<details>
<summary>Stuck at casting 128%?</summary>

- Check that the game language and script language settings are the same.
- Make sure your reel is fully loaded, or equip a rainbow line and use `-R` flag. 
</details>

<!-- ------------------------------- divide -------------------------------- -->
<details>
<summary>Didn't lift the rod after the retrieval is finished?</summary>

- Make sure your reel is fully loaded, or equip a rainbow line and use `-R` flag. 
- Change the game window size.
- Reduce the value of `SPOOL_CONFIDENCE` in `config.yaml`.
- Keep away from light sources or turn off the boat light.
</details>
<!-- ------------------------------- divide -------------------------------- -->
<details>
<summary>Script is running but nothing happen?</summary>

- Open cmd/Powershell as administrator and run it again.
</details>
<!-- ------------------------------- divide -------------------------------- -->

## Changelog
See **[CHANGELOG][changelog].**

## License
**[GNU General Public License version 3][license]**

## Contributing
Any contribution, bug report, or idea about new features is welcome.

## Contact me
dereklee0310@gmail.com 

[readme]: /docs/zh-TW/README.md
[rf4s_logo]: /static/readme/RF4S.png
[python_badge]: https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white
[windows_badge]: https://img.shields.io/badge/Windows-0078D6?style=for-the-badge&logo=windows&logoColor=white

[discord]: https://discord.gg/BZQWQnAMbY
[python]: https://www.python.org/downloads/
[installation]: /docs/en/INSTALLATION.md
[configuration]: /docs/en/CONFIGURATION.md
[changelog]: /docs/en/CHANGELOG.md
[path]: /static/readme/path.png
[license]: /LICENSE
    📄 requirements.txt  [Текстовый файл]:
pyautogui==0.9.54
keyboard==0.13.5
pywin32==306
pynput==1.7.6
opencv-python==4.8.0.76
Pillow==10.1.0
PyScreeze==0.1.29
python-dotenv==1.0.1
matplotlib==3.8.0
playsound==1.2.2 # downgrade to avoid bug
pyyaml==6.0.2
yacs==0.1.8
rich==13.9.4
bump-my-version==0.32.1
discord-webhook==1.4.1
# reference: https://stackoverflow.com/questions/68704443/python-playsound-error-261-for-command-the-driver-cannot-recognize-the-specifie

📁 rf4s/
    📁 app/
            📄 app.py  [Текстовый файл]:
"""Base application class for other tools.

Provides core functionality for:
- Configuration management
- Window control
- Result display

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import os
import signal
import sys
from abc import ABC, abstractmethod
from pathlib import Path

from pynput import keyboard
from rich import print
from rich.table import Table
from yacs.config import CfgNode as CN

from rf4s.config import config
from rf4s.controller.detection import Detection
from rf4s.controller.window import Window
from rf4s.result.result import Result

ROOT = Path(__file__).resolve().parents[2]


class App(ABC):
    """A base application class.

    Attributes:
        cfg (yacs.config.CfgNode): Default + user's configuration file
        window (Window): Window controller
    """

    def __init__(self):
        """Initialize a mutable cfg node for further modification."""
        self.cfg = config.setup_cfg()
        self.cfg.merge_from_file(ROOT / "config.yaml")
        self.window = Window()

    def _on_release(self, key: keyboard.KeyCode) -> None:
        """Monitor user's keystrokes and convert a key press to a CTRL_C_EVENT.

        :param key: The key that was released.
        :type key: keyboard.KeyCode

        Exits the application when the configured quit key is pressed.
        """
        # Trigger CTRL_C_EVENT, which will be caught in start() to simulate pressing
        # CTRL-C to terminate the script.
        if key == keyboard.KeyCode.from_char(self.cfg.KEY.QUIT):
            os.kill(os.getpid(), signal.CTRL_C_EVENT)
            sys.exit()

    @abstractmethod
    def _start(self):
        raise NotImplementedError("_start() must be implemented in subclass")

    @abstractmethod
    def start(self):
        raise NotImplementedError("start() must be implemented in subclass")

    @abstractmethod
    def create_parser(self):
        raise NotImplementedError("create_parser() must be implemented in subclass")

    @abstractmethod
    def display_result(self) -> None:
        raise NotImplementedError("display_result() must be implemented in subclass")


class ToolApp(App):
    """General application class for other tools.

    Attributes:
        detection (Detection): Detection controller
    """

    def __init__(self):
        """Set up an immutable cfg node for further modification.

        1. Parse command-line arguments and merge them with the existing cfg node.
        2. Create a Window instance and a Detection instance.
        3. Create an empty dictionary for result
        """
        super().__init__()
        args = self.create_parser().parse_args()
        args_cfg = CN({"ARGS": config.dict_to_cfg(vars(args))})
        self.cfg.merge_from_other_cfg(args_cfg)
        self.cfg.merge_from_list(args.opts)

        # Dummy node
        dummy = CN({"SELECTED": config.dict_to_cfg({"MODE": "spin"})})
        self.cfg.merge_from_other_cfg(dummy)
        self.cfg.freeze()

        self.detection = Detection(self.cfg, self.window)
        self.result = Result()  # This will be used in display_result()

    def display_result(self) -> None:
        """Display the running result in a table format."""
        result_dict = self.result.as_dict()
        if not result_dict:
            return

        table = Table("Result", title="Running Result", show_header=False)
        for name, value in self.result.as_dict().items():
            table.add_row(name, str(value))
        print(table)

    def start(self) -> None:
        """Wrapper method that handle window activation and result display."""
        if self.cfg.KEY.QUIT != "CTRL-C":
            listener = keyboard.Listener(on_release=self._on_release)
            listener.start()

        self.window.activate_game_window()
        try:
            self._start()
        except KeyboardInterrupt:
            pass
        self.display_result()
        self.window.activate_script_window()

    📁 component/
            📄 friction_brake.py  [Текстовый файл]:
"""Module for friction brake related methods.

This module provides functionality for managing the friction brake in Russian Fishing 4,
including resetting, adjusting, and monitoring the friction brake.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
from multiprocessing import Process, Value
from time import sleep, time

import pyautogui as pag

from rf4s.controller.detection import Detection

MAX_FRICTION_BRAKE = 30
MIN_FRICTION_BRAKE = 0
UP = 1
DOWN = -1
FRICTION_BRAKE_MONITOR_DELAY = 2
LOOP_DELAY = 0.04

logger = logging.getLogger("rich")


class FrictionBrake:
    """Friction brake controller.

    This class handles the adjustment and monitoring of the friction brake during gameplay.

    Attributes:
        cfg (CfgNode): Configuration node for friction brake settings.
        detection (Detection): Detection instance for in-game state checks.
        cur (Value): Current value of the friction brake.
        lock (Lock): Lock for thread synchronization.
        monitor_process (Process): Process for monitoring the friction brake.
    """

    def __init__(self, cfg, lock, detection: Detection) -> None:
        """Initialize the FrictionBrake class with configuration, lock, and detection.

        :param cfg: Configuration node for friction brake settings.
        :type cfg: CfgNode
        :param lock: Lock for thread synchronization.
        :type lock: Lock
        :param detection: Detection instance for in-game state checks.
        :type detection: Detection
        """
        self.cfg = cfg
        self.lock = lock
        self.detection = detection
        self.cur = Value("i", cfg.FRICTION_BRAKE.INITIAL)
        self.monitor_process = Process(target=monitor_friction_brake, args=(self,))

    def reset(self, target: int) -> None:
        """Reset the friction brake to the target value.

        :param target: Target friction brake value.
        :type target: int
        """
        logger.info("Resetting friction brake")
        for _ in range(MAX_FRICTION_BRAKE):
            pag.scroll(UP)

        diff = MAX_FRICTION_BRAKE - target
        for _ in range(abs(diff)):
            pag.scroll(DOWN)
        self.cur.value = target

    def change(self, increase: bool) -> None:
        """Increase or decrease the friction brake.

        :param increase: Whether to increase the friction brake.
        :type increase: bool
        """
        if increase:
            if self.cur.value < self.cfg.FRICTION_BRAKE.MAX:
                pag.scroll(UP, _pause=False)
                self.cur.value = min(self.cur.value + 1, MAX_FRICTION_BRAKE)
        else:
            if self.cur.value > 0:
                pag.scroll(DOWN, _pause=False)
                self.cur.value = max(self.cur.value - 1, MIN_FRICTION_BRAKE)
        sleep(LOOP_DELAY)


def monitor_friction_brake(friction_brake: FrictionBrake) -> None:
    """Monitor friction brake bar and change it accordingly.

    This is used as the target function in multiprocess.Process and must be pickable,
    thus it must be declared as a global function instead of an instance method.

    :param friction_brake: Friction brake controller.
    :type friction_brake: FrictionBrake
    """
    logger.info("Monitoring friction brake")

    pre_time = time()
    fish_hooked = False

    try:
        while True:
            if not friction_brake.detection.is_fish_hooked_pixel():
                sleep(FRICTION_BRAKE_MONITOR_DELAY)
                fish_hooked = False
                continue
            if not fish_hooked:
                sleep(friction_brake.cfg.FRICTION_BRAKE.START_DELAY)
                fish_hooked = True
            with friction_brake.lock:
                if friction_brake.detection.is_friction_brake_high():
                    friction_brake.change(increase=False)
                if friction_brake.detection.is_reel_burning():
                    logger.info("Reel burning detected, decreasing friction brake")
                    friction_brake.change(increase=False)
                else:
                    cur_time = time()
                    if (
                        cur_time - pre_time
                        < friction_brake.cfg.FRICTION_BRAKE.INCREASE_DELAY
                    ):
                        continue
                    pre_time = cur_time
                    friction_brake.change(increase=True)
    except KeyboardInterrupt:
        pass

            📄 tackle.py  [Текстовый файл]:
"""Module for Tackle class and some decorators.

This module provides functionality for managing tackle-related actions in Russian Fishing 4,
such as casting, retrieving, and pulling fish. It also includes decorators for handling
common tasks like clicklock and key releases.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import random
from time import sleep
from typing import Literal

import pyautogui as pag
import win32api
import win32con
from pyscreeze import Box

from rf4s import exceptions, utils
from rf4s.controller.detection import Detection
from rf4s.controller.timer import Timer

logger = logging.getLogger("rich")

RESET_TIMEOUT = 16
CAST_SCALE = 0.4  # 25% / 0.4s

# BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
BASE_DELAY = 1.2
LOOP_DELAY = 1

ANIMATION_DELAY = 1

RETRIEVAL_TIMEOUT = 32
PULL_TIMEOUT = 16
RETRIEVAL_WITH_PAUSE_TIMEOUT = 128
LIFT_DURATION = 3
TELESCOPIC_RETRIEVAL_TIMEOUT = 8
LANDING_NET_DURATION = 6
LANDING_NET_DELAY = 0.5
SINK_DELAY = 2


OFFSET = 100
NUM_OF_MOVEMENT = 4


class Tackle:
    """Class for all tackle-dependent methods.

    This class handles actions related to the fishing tackle, such as casting,
    retrieving, and pulling fish. It also manages tackle resetting and gear ratio switching.

    Attributes:
        cfg (CfgNode): Configuration node for tackle settings.
        timer (Timer): Timer instance for timing actions.
        detection (Detection): Detection instance for in-game state checks.
        landing_net_out (bool): Whether the landing net is deployed.
        available (bool): Whether the tackle is available for use.
    """

    def __init__(self, cfg, timer: Timer, detection: Detection):
        """Initialize the Tackle class with configuration, timer, and detection.

        :param cfg: Configuration node for tackle settings.
        :type cfg: CfgNode
        :param timer: Timer instance for timing actions.
        :type timer: Timer
        :param detection: Detection instance for in-game state checks.
        :type detection: Detection
        """
        self.cfg = cfg
        self.timer = timer
        self.detection = detection
        self.landing_net_out = False  # For telescopic pull
        self.available = True

    @staticmethod
    def _check_status(func):
        def wrapper(self, *args, **kwargs):
            if not self.available:
                return
            try:
                func(self, *args)
            except Exception as e:
                raise e

        return wrapper

    def is_disconnected_or_ticketed_expired(self) -> None:
        """Check if the game disconnected or the boat ticket expired."""
        if self.detection.is_disconnected():
            raise exceptions.DisconnectedError
        if self.detection.is_ticket_expired():
            raise exceptions.TicketExpiredError

    @_check_status
    def reset(self) -> None:
        """Reset the tackle until ready and detect unexpected events.

        :raises exceptions.FishHookedError: A fish is hooked.
        :raises exceptions.FishCapturedError: A fish is captured.
        :raises exceptions.LineAtEndError: The line is at its end.
        :raises exceptions.LineSnaggedError: The line is snagged.
        :raises TimeoutError: The loop timed out.
        """
        logger.info("Resetting tackle")
        i = RESET_TIMEOUT
        while i > 0:
            if self.detection.is_tackle_ready():
                return
            if self.detection.is_fish_hooked():
                raise exceptions.FishHookedError
            if self.detection.is_fish_captured():
                raise exceptions.FishCapturedError
            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                raise exceptions.LineAtEndError
            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                raise exceptions.LineSnaggedError
            if self.detection.is_lure_broken():
                raise exceptions.LureBrokenError
            if self.detection.is_tackle_broken():
                raise exceptions.TackleBrokenError
            i = utils.sleep_and_decrease(i, LOOP_DELAY)

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    @_check_status
    def cast(self, lock: bool) -> None:
        """Cast the rod, then wait for the lure/bait to fly and sink.

        :param lock: Whether to lock the reel after casting.
        :type lock: bool
        """
        logger.info("Casting rod")
        if self.cfg.ARGS.MOUSE:
            self.move_mouse_randomly()
        match self.cfg.SELECTED.CAST_POWER_LEVEL:
            case 1:  # 0%
                pag.click()
            case 5:  # power cast
                with pag.hold("shift"):
                    utils.hold_mouse_button(1)
            case _:
                # -1 for backward compatibility
                duration = CAST_SCALE * (self.cfg.SELECTED.CAST_POWER_LEVEL - 1)
                utils.hold_mouse_button(duration)

        sleep(self.cfg.SELECTED.CAST_DELAY)
        if lock:
            pag.click()

    def sink(self) -> None:
        """Sink the lure until an event happens, designed for marine and wakey rig."""
        logger.info("Sinking lure")
        i = self.cfg.SELECTED.SINK_TIMEOUT
        while i > 0:
            i = utils.sleep_and_decrease(i, LOOP_DELAY)
            if self.detection.is_moving_in_bottom_layer():
                logger.info("Lure has reached bottom layer")
                sleep(SINK_DELAY)
                break

            if self.detection.is_fish_hooked_twice():
                pag.click()  # Lock reel
                return

        utils.hold_mouse_button(self.cfg.SELECTED.TIGHTEN_DURATION)

    @_check_status
    @utils.release_keys_after()
    def retrieve(self, first: bool = True) -> None:
        """Retrieve the line until the end is reached and detect unexpected events.

        :param first: Whether it's invoked for the first time, defaults to True.
        :type first: bool, optional

        :raises exceptions.FishCapturedError: A fish is captured.
        :raises exceptions.LineAtEndError: The line is at its end.
        :raises exceptions.LineSnaggedError: The line is snagged.
        :raises TimeoutError: The loop timed out.
        """
        logger.info("Retrieving fishing line")

        i = RETRIEVAL_TIMEOUT
        while i > 0:
            if self.detection.is_fish_hooked():
                if self.cfg.SELECTED.POST_ACCELERATION == "on":
                    pag.keyDown("shift")
                elif self.cfg.SELECTED.POST_ACCELERATION == "auto" and first:
                    pag.keyDown("shift")

                if self.cfg.ARGS.LIFT:
                    utils.hold_mouse_button(LIFT_DURATION, button="right")

            if self.detection.is_retrieval_finished():
                sleep(0 if self.cfg.ARGS.RAINBOW else 2)
                return

            if self.detection.is_fish_captured():
                raise exceptions.FishCapturedError
            if self.cfg.SCRIPT.SPOOLING_DETECTION and self.detection.is_line_at_end():
                raise exceptions.LineAtEndError
            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                raise exceptions.LineSnaggedError
            if self.detection.is_tackle_broken():
                raise exceptions.TackleBrokenError
            i = utils.sleep_and_decrease(i, LOOP_DELAY)

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    @utils.release_keys_after()
    def _special_retrieve(self, button: str) -> None:
        """Retrieve the line with special conditions (pause or lift).

        :param button: The mouse button to use for retrieval.
        :type button: str
        """
        if self.cfg.SELECTED.PRE_ACCELERATION:
            pag.keyDown("shift")
        i = RETRIEVAL_WITH_PAUSE_TIMEOUT
        while i > 0:
            utils.hold_mouse_button(self.cfg.SELECTED.RETRIEVAL_DURATION, button)
            i -= self.cfg.SELECTED.RETRIEVAL_DURATION
            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.RETRIEVAL_DELAY)
            if (
                self.detection.is_fish_hooked()
                or self.detection.is_retrieval_finished()
            ):
                return

    @utils.release_keys_after()
    def pirk(self) -> None:
        """Start pirking until a fish is hooked.

        :raises exceptions.TimeoutError: The loop timed out.
        """
        logger.info("Pirking")

        i = self.cfg.SELECTED.PIRK_TIMEOUT
        while i > 0:
            if self.detection.is_tackle_ready():
                return

            if self.detection.is_fish_hooked_twice():
                pag.click()
                return

            if self.cfg.SELECTED.PIRK_DURATION > 0:
                if self.cfg.SELECTED.CTRL:
                    pag.keyDown("ctrl")
                if self.cfg.SELECTED.SHIFT:
                    pag.keyDown("shift")
                utils.hold_mouse_button(self.cfg.SELECTED.PIRK_DURATION, button="right")
                i -= self.cfg.SELECTED.PIRK_DURATION
                i = utils.sleep_and_decrease(i, self.cfg.SELECTED.PIRK_DELAY)
            else:
                i = utils.sleep_and_decrease(i, LOOP_DELAY)

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    def elevate(self, dropped: bool) -> None:
        """Perform elevator tactic (drop/rise) until a fish is hooked.

        :param dropped: Whether the lure is dropped.
        :type dropped: bool
        :raises exceptions.TimeoutError: The loop timed out.
        """
        locked = True  # Reel is locked after tackle.sink()
        i = self.cfg.SELECTED.ELEVATE_TIMEOUT
        while i > 0:
            if self.detection.is_fish_hooked_twice():
                pag.click()
                return

            if self.cfg.SELECTED.DROP and not dropped:
                pag.press("enter")
                if locked:
                    delay = self.cfg.SELECTED.ELEVATE_DELAY
                else:
                    delay = self.cfg.SELECTED.ELEVATE_DURATION
                i = utils.sleep_and_decrease(i, delay)
            else:
                if locked:
                    i = utils.sleep_and_decrease(i, self.cfg.SELECTED.ELEVATE_DELAY)
                else:
                    utils.hold_mouse_button(self.cfg.SELECTED.ELEVATE_DURATION)
                    i -= self.cfg.SELECTED.ELEVATE_DURATION
            locked = not locked

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    @_check_status
    def pull(self) -> None:
        """Pull the fish until it's captured."""
        logger.info("Pulling fish")
        if self.cfg.SELECTED.MODE == "telescopic":
            self._telescopic_pull()
        else:
            self._pull()

    @utils.toggle_right_mouse_button
    def _pull(self) -> None:
        """Pull the fish until it's captured."""
        i = PULL_TIMEOUT
        while i > 0:
            i = utils.sleep_and_decrease(i, LOOP_DELAY)
            if self.detection.is_fish_captured():
                return
            if self.cfg.SCRIPT.SNAG_DETECTION and self.detection.is_line_snagged():
                raise exceptions.LineSnaggedError

        if not self.detection.is_fish_hooked():
            return
        if self.detection.is_retrieval_finished():
            pag.press("space")
            sleep(LANDING_NET_DURATION)
            if self.detection.is_fish_captured():
                return
            pag.press("space")
            sleep(LANDING_NET_DELAY)
        if self.detection.is_tackle_broken():
            raise exceptions.TackleBrokenError

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    def _telescopic_pull(self) -> None:
        """Pull the fish until it's captured, designed for telescopic rod.

        :raises exceptions.TimeoutError: The loop timed out.
        """
        # Check false postive first because it happens often
        if not self.detection.is_fish_hooked():
            return

        # Toggle landing net when pull() is called for the first time
        if not self.landing_net_out:
            pag.press("space")
            self.landing_net_out = True
        i = TELESCOPIC_RETRIEVAL_TIMEOUT
        while i > 0:
            i = utils.sleep_and_decrease(i, LOOP_DELAY)
            if self.detection.is_fish_captured():
                self.landing_net_out = False
                return
            if self.detection.is_tackle_broken():
                raise exceptions.TackleBrokenError

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    def switch_gear_ratio(self) -> None:
        """Switch the gear ratio of a conventional reel."""
        logger.info("Switching gear ratio")
        with pag.hold("ctrl"):
            pag.press("space")

    def move_mouse_randomly(self) -> None:
        """Randomly move the mouse for four times."""
        logger.info("Moving mouse randomly")
        coords = []
        for _ in range(NUM_OF_MOVEMENT - 1):
            x, y = random.randint(-OFFSET, OFFSET), random.randint(-OFFSET, OFFSET)
            coords.append((x, y))
        coords.append((-sum(x for x, _ in coords), -sum(y for _, y in coords)))
        for x, y in coords:
            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, x, y, 0, 0)
            sleep(ANIMATION_DELAY)

    def equip_item(self, item) -> None:
        """Equip an item from the menu or inventory.

        :param item: The item to equip (e.g., lure, pva, dry_mix, groundbait).
        :type item: str
        """
        if item == "lure":
            self._equip_item_from_menu(item)
        self._equip_item_from_inventory(item)  # groundbait, dry_mix, pva

    def _equip_item_from_menu(self, item: str) -> None:
        """Equip an item from the menu.

        :param item: The item to equip (e.g., lure).
        :type item: str
        """
        logger.info("Equiping new %s from menu", item)
        with pag.hold("b"):
            self._equip_favorite_item(item)
        sleep(ANIMATION_DELAY)

    @utils.press_before_and_after("v")
    def _equip_item_from_inventory(
        self, item: Literal["dry_mix", "groundbait"]
    ) -> None:
        """Equip an item from the inventory.

        :param item: The item to equip (e.g., dry_mix, groundbait).
        :type item: Literal["dry_mix", "groundbait"]
        """
        logger.info("Equiping new %s from inventory", item)
        scrollbar_position = self.detection.get_scrollbar_position()
        if scrollbar_position is None:
            pag.click(utils.get_box_center(self.get_item_position(item)))
            self._equip_favorite_item(item)
            return

        pag.moveTo(scrollbar_position)
        for _ in range(5):
            sleep(ANIMATION_DELAY)
            pag.drag(xOffset=0, yOffset=125, duration=0.5, button="left")
            position = self.get_item_position(item)
            if position is not None:
                pag.click(utils.get_box_center(position))
                self._equip_favorite_item(item)
                break

    def get_item_position(self, item: str) -> Box | None:
        """Get the position of an item.
        :param item: The item to get the position for (e.g., pva, dry_mix, groundbait)
        :type item: str
        :return: position of the item
        :rtype: Box | None
        """
        if item == "groundbait":
            return self.detection.get_groundbait_position()
        elif item == "dry_mix":
            return self.detection.get_dry_mix_position()
        else:  # pva
            return self.detection.get_pva_position()

    def _equip_favorite_item(self, item: bool):
        """Select a favorite item for replacement and replace the broken one.

        :param item: The item to equip (e.g., lure, pva, dry_mix, groundbait).
        :type item: str
        :raises exceptions.ItemNotFoundError: The item was not found.
        """
        sleep(ANIMATION_DELAY)
        logger.info("Looking for favorite items")
        favorite_item_positions = list(self.detection.get_favorite_item_positions())
        if item == "lure":
            random.shuffle(favorite_item_positions)

        for favorite_item_position in favorite_item_positions:
            x, y = utils.get_box_center(favorite_item_position)
            if item == "lure" and pag.pixel(x - 70, y + 190) == (178, 59, 30):
                continue
            pag.click(x - 70, y + 190, clicks=2, interval=0.1)
            logger.info("New %s equiped successfully", item)
            return

        # Close selection window when equiping from inventory
        if item in ("dry_mix", "groundbait"):
            pag.press("esc")
        raise exceptions.ItemNotFoundError

    def _monitor_float_state(self) -> None:
        """Monitor the state of the float."""
        logger.info("Monitoring float state")
        reference_img = pag.screenshot(region=self.detection.float_camera_rect)
        i = self.cfg.SELECTED.DRIFT_TIMEOUT
        while i > 0:
            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.CHECK_DELAY)
            if self.detection.is_float_state_changed(reference_img):
                logger.info("Float status changed")
                return

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    def _monitor_clip_state(self) -> None:
        """Monitor the state of the bolognese clip."""
        i = self.cfg.SELECTED.DRIFT_TIMEOUT
        while i > 0:
            i = utils.sleep_and_decrease(i, self.cfg.SELECTED.CHECK_DELAY)
            if self.detection.is_clip_open():
                return

        self.is_disconnected_or_ticketed_expired()
        raise TimeoutError

    📁 config/
            📄 config.py  [Текстовый файл]:
"""
Configuration module for managing and manipulating configuration settings.

This module provides utilities for setting up, converting, and printing
configuration nodes using the YACS library.
"""

from yacs.config import CfgNode as CN

from rf4s.config.defaults import get_cfg_defaults


def setup_cfg() -> CN:
    """
    Set up and return a default configuration node.

    This function initializes a default configuration node and allows new keys
    to be added to the configuration.

    :return: A cloned configuration node with default settings.
    :rtype: CN
    """
    cfg = get_cfg_defaults()
    cfg.set_new_allowed(True)
    return cfg.clone()


def dict_to_cfg(args: dict) -> CN:
    """
    Convert a dictionary to a configuration node.

    This function recursively converts a dictionary into a configuration node,
    allowing nested dictionaries to be converted into nested configuration nodes.

    :param args: Dictionary to be converted into a configuration node.
    :type args: dict
    :return: Configuration node created from the dictionary.
    :rtype: CN
    """
    cfg = CN()
    for k, v in args.items():
        k = k.upper()
        if isinstance(v, dict):
            cfg[k] = dict_to_cfg(v)
        else:
            cfg[k] = v
    return cfg


def print_cfg(cfg: CN, level: int = 0) -> None:
    """
    Print the configuration node in a readable format.

    This function recursively prints the configuration node, with indentation
    to represent nested levels.

    :param cfg: Configuration node to be printed.
    :type cfg: CN
    :param level: Current indentation level (used for recursion).
    :type level: int
    """
    cfg = dict(cfg)
    indent = "  " * level if level > 0 else ""
    for k, v in cfg.items():
        if isinstance(v, CN):
            print(f"{indent}{k}:")
            print_cfg(v, level + 1)
        else:
            print(f"{indent}{k}: {v}")


def to_list(profile: dict) -> list:
    """
    Convert a dictionary into a flat list of key-value pairs.

    This function flattens a dictionary into a list where keys and values
    are alternated.

    :param profile: Dictionary to be converted into a list.
    :type profile: dict
    :return: List containing alternating keys and values from the dictionary.
    :rtype: list
    """
    pairs = []
    for k, v in profile.items():
        pairs.extend([k, v])
    return pairs

            📄 config.yaml  [Текстовый файл]:
VERSION: "0.5.0"

SCRIPT:
  LANGUAGE: "en"
  LAUNCH_OPTIONS: ""
  SMTP_VERIFICATION: true
  IMAGE_VERIFICATION: true
  SNAG_DETECTION: true
  SPOOLING_DETECTION: true
  RANDOM_ROD_SELECTION: true
  SPOOL_CONFIDENCE: 0.98
  SPOD_ROD_RECAST_DELAY: 1800
  LURE_CHANGE_DELAY: 1800
  ALARM_SOUND: "./static/sound/guitar.wav"
  RANDOM_CAST_PROBABILITY: 0.25
  SCREENSHOT_TAGS:
    - "green"
    - "yellow"
    - "blue"
    - "purple"
    - "pink"

KEY:
  TEA: -1
  CARROT: -1
  BOTTOM_RODS: [1, 2, 3]
  COFFEE: 4
  DIGGING_TOOL: 5
  ALCOHOL: 6
  MAIN_ROD: 1
  SPOD_ROD: 7
  QUIT: "CTRL-C"

STAT:
  ENERGY_THRESHOLD: 0.74
  HUNGER_THRESHOLD: 0.5
  COMFORT_THRESHOLD: 0.51
  TEA_DELAY: 300
  COFFEE_LIMIT: 10
  COFFEE_PER_DRINK: 1
  ALCOHOL_DELAY: 900
  ALCOHOL_PER_DRINK: 1

FRICTION_BRAKE:
  INITIAL: 29
  MAX: 30
  START_DELAY: 2.0
  INCREASE_DELAY: 1.0
  SENSITIVITY: "medium"

KEEPNET:
  CAPACITY: 100
  FISH_DELAY: 0.0
  GIFT_DELAY: 4.0
  FULL_ACTION: "quit"
  WHITELIST:
    - "mackerel"
    - "saithe"
    - "herring"
    - "squid"
    - "scallop"
    - "mussel"
  BLACKLIST: []
  TAGS:
    - "green"
    - "yellow"
    - "blue"
    - "purple"
    - "pink"

NOTIFICATION:
  EMAIL: "email@example.com"
  PASSWORD: "password"
  SMTP_SERVER: "smtp.gmail.com"
  MIAO_CODE: "example"
  DISCORD_WEBHOOK_URL: ""

PAUSE:
  DELAY: 1800
  DURATION: 600

PROFILE:
  SPIN:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 0.0
    RETRIEVAL_DELAY: 0.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "normal"
  SPIN_WITH_PAUSE:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 1.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 3.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "pause"
  SPIN_WITH_LIFT:
    MODE: "spin"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 6.0
    TIGHTEN_DURATION: 0.0
    RETRIEVAL_DURATION: 1.0
    RETRIEVAL_DELAY: 1.0
    RETRIEVAL_TIMEOUT: 256.0
    PRE_ACCELERATION: false
    POST_ACCELERATION: "off"
    TYPE: "lift"
  BOTTOM:
    MODE: "bottom"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    POST_ACCELERATION: "off"
    CHECK_DELAY: 32.0
    CHECK_MISS_LIMIT: 16
    PUT_DOWN_DELAY: 0.0
  PIRK:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  PIRK_WITH_RETRIEVAL:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 0.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: false
    SHIFT: false
    PIRK_DURATION: 0.5
    PIRK_DELAY: 2.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  WAKEY_RIG:
    MODE: "pirk"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 45.0
    TIGHTEN_DURATION: 1.0
    DEPTH_ADJUST_DELAY: 4.0
    DEPTH_ADJUST_DURATION: 1.0
    CTRL: true
    SHIFT: false
    PIRK_DURATION: 1.5
    PIRK_DELAY: 4.0
    PIRK_TIMEOUT: 32.0
    PIRK_RETRIEVAL: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR:
    MODE: "elevator"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: false
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  ELEVATOR_WITH_DROP:
    MODE: "elevator"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 1.0
    CAST_DELAY: 4.0
    SINK_TIMEOUT: 60.0
    TIGHTEN_DURATION: 1.0
    ELEVATE_DURATION: 4.0
    ELEVATE_DELAY: 4.0
    ELEVATE_TIMEOUT: 40.0
    DROP: true
    HOOK_DELAY: 0.5
    POST_ACCELERATION: "auto"
  TELESCOPIC:
    MODE: "telescopic"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 16.0
    CAMERA_SHAPE: "square"
  BOLOGNESE:
    MODE: "bolognese"
    LAUNCH_OPTIONS: ""
    CAST_POWER_LEVEL: 5.0
    CAST_DELAY: 4.0
    FLOAT_SENSITIVITY: 0.68
    CHECK_DELAY: 1.0
    PULL_DELAY: 0.5
    DRIFT_TIMEOUT: 32.0
    CAMERA_SHAPE: "square"
    POST_ACCELERATION: "off"

            📄 defaults.py  [Текстовый файл]:
"""Default yacs config node."""

from yacs.config import CfgNode as CN

_C = CN()
_C.VERSION = "0.5.0"

# ---------------------------------------------------------------------------- #
#                                    General                                   #
# ---------------------------------------------------------------------------- #
_C.SCRIPT = CN()
_C.SCRIPT.LANGUAGE = "en"  # Language for the script. Options: en, ru, zh-TW, zh-CN
_C.SCRIPT.LAUNCH_OPTIONS = ""  # Default launch options for the script, e.g., -r -c -H
_C.SCRIPT.SMTP_VERIFICATION = True
_C.SCRIPT.IMAGE_VERIFICATION = True
_C.SCRIPT.SNAG_DETECTION = True
_C.SCRIPT.SPOOLING_DETECTION = True
_C.SCRIPT.RANDOM_ROD_SELECTION = True  # For bottom mode
# Confidence threshold for spooling detection (lower = more sensitive)
_C.SCRIPT.SPOOL_CONFIDENCE = 0.98
# Delay before recasting spod rod (in seconds)
# Use bottom mode and -o to enable it.
_C.SCRIPT.SPOD_ROD_RECAST_DELAY = 1800
# Delay before changing lure randomly (in seconds)
# Use spin mode and -L to enable it.
_C.SCRIPT.LURE_CHANGE_DELAY = 1800
_C.SCRIPT.ALARM_SOUND = "./static/sound/guitar.wav"  # Path to alarm sound file
# Probability to add a redundant rod cast (0.0 to 1.0)
_C.SCRIPT.RANDOM_CAST_PROBABILITY = 0.25
# When using -s flag, only take screenshot of the fishes with tags below
# If left empty, the script will take screenshot of every fish you caught
_C.SCRIPT.SCREENSHOT_TAGS = ("green", "yellow", "blue", "purple", "pink")

# ---------------------------------------------------------------------------- #
#                                  Key Binding                                 #
# ---------------------------------------------------------------------------- #
_C.KEY = CN()
_C.KEY.TEA = -1  # Key binding for tea. Set to -1 to use quick selection menu
_C.KEY.CARROT = -1  # Key binding for carrot. Set to -1 to use quick selection menu
_C.KEY.BOTTOM_RODS = (1, 2, 3)  # Key bindings for bottom rods
_C.KEY.COFFEE = 4  # Key binding for coffee. Set to -1 to use quick selection menu
_C.KEY.DIGGING_TOOL = 5  # Key binding for digging tool
_C.KEY.ALCOHOL = 6  # Key binding for alcohol
# Key binding for the main rod (used when harvesting baits with one rod)
_C.KEY.MAIN_ROD = 1
_C.KEY.SPOD_ROD = 7  # Key binding for the spod rod (used in bottom mode)
# Key binding to stop the script (default is Ctrl-C)
# If you want to use a special quitting shortcut, please refer to pynput's docs:
# https://pynput.readthedocs.io/en/latest/keyboard.html#pynput.keyboard.Key .
_C.KEY.QUIT = "CTRL-C"

# ---------------------------------------------------------------------------- #
#                                 Player Stats                                 #
# ---------------------------------------------------------------------------- #
_C.STAT = CN()
# Minimum energy level before drinking coffee/harvesting baits
_C.STAT.ENERGY_THRESHOLD = 0.74
_C.STAT.HUNGER_THRESHOLD = 0.5  # Minimum hunger level before consuming carrot
_C.STAT.COMFORT_THRESHOLD = 0.51  # Minimum comfort level before consuming tea
_C.STAT.TEA_DELAY = 300  # Delay between tea drinks (in seconds)
_C.STAT.COFFEE_LIMIT = 10  # Maximum coffee drinks per fish fight.
_C.STAT.COFFEE_PER_DRINK = 1  # Amount of coffee consumed per drink
_C.STAT.ALCOHOL_DELAY = 900  # Delay between alcohol drinks (in seconds)
_C.STAT.ALCOHOL_PER_DRINK = 1  # Amount of alcohol consumed per drink

# ---------------------------------------------------------------------------- #
#                   Friction Brake (Use -f flag to enable it)                  #
# ---------------------------------------------------------------------------- #
_C.FRICTION_BRAKE = CN()
_C.FRICTION_BRAKE.INITIAL = 29  # Initial friction brake value
_C.FRICTION_BRAKE.MAX = 30  # Maximum friction brake value
# Delay before starting to adjust friction brake after a fish is hooked
_C.FRICTION_BRAKE.START_DELAY = 2.0
_C.FRICTION_BRAKE.INCREASE_DELAY = 1.0  # Delay before increasing friction brake
_C.FRICTION_BRAKE.SENSITIVITY = "medium"  # Sensitivity of friction brake detection

# ---------------------------------------------------------------------------- #
#                                    Keepnet                                   #
# ---------------------------------------------------------------------------- #
_C.KEEPNET = CN()
_C.KEEPNET.CAPACITY = 100
_C.KEEPNET.FISH_DELAY = 0.0  # Delay before keeping the fish (for screenshots)
_C.KEEPNET.GIFT_DELAY = 4.0  # Delay before keeping the gift (for screenshots)
_C.KEEPNET.FULL_ACTION = "quit"  # Action when keepnet is full. Options: quit, alarm
# Whitelist for untagged fish releasing when using -t flag
# Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.WHITELIST = (
    "mackerel",
    "saithe",
    "herring",
    "squid",
    "scallop",
    "mussel",
)
# Fish in the blacklist will always be released
# Options: mackerel, saithe, herring, squid, scallop, mussel, perch, shorthorn_sculpin
_C.KEEPNET.BLACKLIST = ()
# When using -t flag, only the fish with tags below would be kept
_C.KEEPNET.TAGS = ("green", "yellow", "blue", "purple", "pink")


# ---------------------------------------------------------------------------- #
#                                 Notification                                 #
# ---------------------------------------------------------------------------- #
_C.NOTIFICATION = CN()
_C.NOTIFICATION.EMAIL = "email@example.com"
_C.NOTIFICATION.PASSWORD = "password"
_C.NOTIFICATION.SMTP_SERVER = "smtp.gmail.com"
_C.NOTIFICATION.MIAO_CODE = "example"
_C.NOTIFICATION.DISCORD_WEBHOOK_URL = ""

# ---------------------------------------------------------------------------- #
#                       Pause ( use -X flag to enable it)                      #
# ---------------------------------------------------------------------------- #
_C.PAUSE = CN()
_C.PAUSE.DELAY = 1800  # Delay between pauses (in seconds)
_C.PAUSE.DURATION = 600  # Duration of pause (in seconds)

_C.PROFILE = CN()
# ---------------------------------------------------------------------------- #
#                             Spin Fishing Profile                             #
# ---------------------------------------------------------------------------- #
_C.PROFILE.SPIN = CN()
_C.PROFILE.SPIN.MODE = "spin"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.SPIN.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.SPIN.CAST_POWER_LEVEL = 5.0
# Delay after casting before lure sinks
_C.PROFILE.SPIN.CAST_DELAY = 6.0
# Duration to tighten the fishing line after casting
_C.PROFILE.SPIN.TIGHTEN_DURATION = 0.0
# Duration of retrieving the line or lifting the rod (right mosue button)
_C.PROFILE.SPIN.RETRIEVAL_DURATION = 0.0
# Delay after retrieving the line or lifting the rod (right mosue button)
_C.PROFILE.SPIN.RETRIEVAL_DELAY = 0.0
# Timeout for retrieving with pause/lift, followed by the normal retrieval
_C.PROFILE.SPIN.RETRIEVAL_TIMEOUT = 256.0
# Hold down the Shift key when performing special spin fishing techniques
_C.PROFILE.SPIN.PRE_ACCELERATION = False
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.SPIN.POST_ACCELERATION = "off"
# Type of special spin fishing technique to perform. Options: normal, pause, lift
_C.PROFILE.SPIN.TYPE = "normal"

_C.PROFILE.SPIN_WITH_PAUSE = CN()
_C.PROFILE.SPIN_WITH_PAUSE.MODE = "spin"
_C.PROFILE.SPIN_WITH_PAUSE.LAUNCH_OPTIONS = ""
_C.PROFILE.SPIN_WITH_PAUSE.CAST_POWER_LEVEL = 5.0
_C.PROFILE.SPIN_WITH_PAUSE.CAST_DELAY = 6.0
_C.PROFILE.SPIN_WITH_PAUSE.TIGHTEN_DURATION = 1.0
_C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DURATION = 1.0
_C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_DELAY = 3.0
_C.PROFILE.SPIN_WITH_PAUSE.RETRIEVAL_TIMEOUT = 256.0
_C.PROFILE.SPIN_WITH_PAUSE.PRE_ACCELERATION = False
_C.PROFILE.SPIN_WITH_PAUSE.POST_ACCELERATION = "off"
_C.PROFILE.SPIN_WITH_PAUSE.TYPE = "pause"


_C.PROFILE.SPIN_WITH_LIFT = CN()
_C.PROFILE.SPIN_WITH_LIFT.MODE = "spin"
_C.PROFILE.SPIN_WITH_LIFT.LAUNCH_OPTIONS = ""
_C.PROFILE.SPIN_WITH_LIFT.CAST_POWER_LEVEL = 5.0
_C.PROFILE.SPIN_WITH_LIFT.CAST_DELAY = 6.0
_C.PROFILE.SPIN_WITH_LIFT.TIGHTEN_DURATION = 0.0
_C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DURATION = 1.0
_C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_DELAY = 1.0
_C.PROFILE.SPIN_WITH_LIFT.RETRIEVAL_TIMEOUT = 256.0
_C.PROFILE.SPIN_WITH_LIFT.PRE_ACCELERATION = False
_C.PROFILE.SPIN_WITH_LIFT.POST_ACCELERATION = "off"
_C.PROFILE.SPIN_WITH_LIFT.TYPE = "lift"


# ---------------------------------------------------------------------------- #
#                            Bottom Fishing Profile                            #
# ---------------------------------------------------------------------------- #
_C.PROFILE.BOTTOM = CN()
_C.PROFILE.BOTTOM.MODE = "bottom"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.BOTTOM.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.BOTTOM.CAST_POWER_LEVEL = 5.0
_C.PROFILE.BOTTOM.CAST_DELAY = 4.0  # Delay after casting before lure sinks
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.BOTTOM.POST_ACCELERATION = "off"
# Delay before checking fish bite on next rod
_C.PROFILE.BOTTOM.CHECK_DELAY = 32.0
# Maximum allowed misses before recasting the rod
_C.PROFILE.BOTTOM.CHECK_MISS_LIMIT = 16
# Delay before checking if a fish is hooked again and putting down the rod
_C.PROFILE.BOTTOM.PUT_DOWN_DELAY = 0.0


# ---------------------------------------------------------------------------- #
#                      Marine / Wakey Rig Pirking Profile                      #
# ---------------------------------------------------------------------------- #
_C.PROFILE.PIRK = CN()
_C.PROFILE.PIRK.MODE = "pirk"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.PIRK.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.PIRK.CAST_POWER_LEVEL = 1.0
_C.PROFILE.PIRK.CAST_DELAY = 4.0  # Delay after casting before lure sinks
_C.PROFILE.PIRK.SINK_TIMEOUT = 60.0  # Maximum time allowed for sinking
# Duration to tighten the line after sinking lure/adjusting lure depth
_C.PROFILE.PIRK.TIGHTEN_DURATION = 1.0
# Delay after opening reel to adjust lure depth, set this to 0 to recast the rod instead
_C.PROFILE.PIRK.DEPTH_ADJUST_DELAY = 4.0
# Durtion to tighten the line after opening reel for DEPTH_ADJUST_DELAY seconds
_C.PROFILE.PIRK.DEPTH_ADJUST_DURATION = 1.0
_C.PROFILE.PIRK.CTRL = False  # Hold Ctrl key during pirking
_C.PROFILE.PIRK.SHIFT = False  # Hold Shift key during pirking
# Duration of lifting the rod, set this to 0 if you want to wait instead of pirking
_C.PROFILE.PIRK.PIRK_DURATION = 0.5
_C.PROFILE.PIRK.PIRK_DELAY = 2.0  # Delay after lifting the rod
# Timeout for pirking session
_C.PROFILE.PIRK.PIRK_TIMEOUT = 32.0
# Retrieve the fishing line during pirking
_C.PROFILE.PIRK.PIRK_RETRIEVAL = False
# When a fish is hooked, check if the fish is still hooked
# after HOOK_DELAY seconds, continue pirking if not
_C.PROFILE.PIRK.HOOK_DELAY = 0.5
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.PIRK.POST_ACCELERATION = "auto"

_C.PROFILE.PIRK_WITH_RETRIEVAL = CN()
_C.PROFILE.PIRK_WITH_RETRIEVAL.MODE = "pirk"
_C.PROFILE.PIRK_WITH_RETRIEVAL.LAUNCH_OPTIONS = ""
_C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_POWER_LEVEL = 1.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.CAST_DELAY = 4.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.SINK_TIMEOUT = 60.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.TIGHTEN_DURATION = 1.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DELAY = 0.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.DEPTH_ADJUST_DURATION = 1.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.CTRL = False
_C.PROFILE.PIRK_WITH_RETRIEVAL.SHIFT = False
_C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DURATION = 0.5
_C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_DELAY = 2.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_TIMEOUT = 32.0
_C.PROFILE.PIRK_WITH_RETRIEVAL.PIRK_RETRIEVAL = True
_C.PROFILE.PIRK_WITH_RETRIEVAL.HOOK_DELAY = 0.5
_C.PROFILE.PIRK_WITH_RETRIEVAL.POST_ACCELERATION = "auto"

# Spin fishing with wakey rig at Ladoga Archipelago
_C.PROFILE.WAKEY_RIG = CN()
_C.PROFILE.WAKEY_RIG.MODE = "pirk"
_C.PROFILE.WAKEY_RIG.LAUNCH_OPTIONS = ""
_C.PROFILE.WAKEY_RIG.CAST_POWER_LEVEL = 1.0
_C.PROFILE.WAKEY_RIG.CAST_DELAY = 4.0
_C.PROFILE.WAKEY_RIG.SINK_TIMEOUT = 45.0
_C.PROFILE.WAKEY_RIG.TIGHTEN_DURATION = 1.0
_C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DELAY = 4.0
_C.PROFILE.WAKEY_RIG.DEPTH_ADJUST_DURATION = 1.0
_C.PROFILE.WAKEY_RIG.CTRL = True
_C.PROFILE.WAKEY_RIG.CTRL = False
_C.PROFILE.WAKEY_RIG.PIRK_DURATION = 1.5
_C.PROFILE.WAKEY_RIG.PIRK_DELAY = 4.0
_C.PROFILE.WAKEY_RIG.PIRK_TIMEOUT = 32.0
_C.PROFILE.WAKEY_RIG.PIRK_RETRIEVAL = False
_C.PROFILE.WAKEY_RIG.HOOK_DELAY = 0.5
_C.PROFILE.WAKEY_RIG.POST_ACCELERATION = "auto"

# ---------------------------------------------------------------------------- #
#                            Marine Elevator Profile                           #
# ---------------------------------------------------------------------------- #
_C.PROFILE.ELEVATOR = CN()
_C.PROFILE.ELEVATOR.MODE = "elevator"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.ELEVATOR.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.ELEVATOR.CAST_POWER_LEVEL = 1.0
# Delay after casting before lure sinks
_C.PROFILE.ELEVATOR.CAST_DELAY = 4.0
# Maximum time allowed for sinking
_C.PROFILE.ELEVATOR.SINK_TIMEOUT = 60.0
# Duration to tighten the line after sinking lure
_C.PROFILE.ELEVATOR.TIGHTEN_DURATION = 1.0
# Duration of retrieving the fishing line/opening the reel
_C.PROFILE.ELEVATOR.ELEVATE_DURATION = 4.0
# Delay after retrieving the fishing line/opening the reel
_C.PROFILE.ELEVATOR.ELEVATE_DELAY = 4.0
# Timeout for pirking session
_C.PROFILE.ELEVATOR.ELEVATE_TIMEOUT = 40.0
# Lock / Unlocking the reel after elevating timed out to drop the lure level by level
_C.PROFILE.ELEVATOR.DROP = False
# When a fish is hooked, check if the fish is still hooked
# after HOOK_DELAY seconds, continue elevating if not
_C.PROFILE.ELEVATOR.HOOK_DELAY = 0.5
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.ELEVATOR.POST_ACCELERATION = "auto"

_C.PROFILE.ELEVATOR_WITH_DROP = CN()
_C.PROFILE.ELEVATOR_WITH_DROP.MODE = "elevator"
_C.PROFILE.ELEVATOR_WITH_DROP.LAUNCH_OPTIONS = ""
_C.PROFILE.ELEVATOR_WITH_DROP.CAST_POWER_LEVEL = 1.0
_C.PROFILE.ELEVATOR_WITH_DROP.CAST_DELAY = 4.0
_C.PROFILE.ELEVATOR_WITH_DROP.SINK_TIMEOUT = 60.0
_C.PROFILE.ELEVATOR_WITH_DROP.TIGHTEN_DURATION = 1.0
_C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DURATION = 4.0
_C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_DELAY = 4.0
_C.PROFILE.ELEVATOR_WITH_DROP.ELEVATE_TIMEOUT = 40.0
_C.PROFILE.ELEVATOR_WITH_DROP.DROP = True
_C.PROFILE.ELEVATOR_WITH_DROP.HOOK_DELAY = 0.5
_C.PROFILE.ELEVATOR_WITH_DROP.POST_ACCELERATION = "auto"

# ---------------------------------------------------------------------------- #
#                          Telescopic fishing Profile                          #
# ---------------------------------------------------------------------------- #
_C.PROFILE.TELESCOPIC = CN()
_C.PROFILE.TELESCOPIC.MODE = "telescopic"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.TELESCOPIC.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.TELESCOPIC.CAST_POWER_LEVEL = 5.0
# Delay after casting before lure sinks
_C.PROFILE.TELESCOPIC.CAST_DELAY = 4.0
# Sensitivity of float detection
_C.PROFILE.TELESCOPIC.FLOAT_SENSITIVITY = 0.68
_C.PROFILE.TELESCOPIC.CHECK_DELAY = 1.0  # Delay between fish bite checks
_C.PROFILE.TELESCOPIC.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
# Recast rod after timed out, designed for flowing water maps
_C.PROFILE.TELESCOPIC.DRIFT_TIMEOUT = 16.0
# Shape of the float camera, the script tracks the whole camrea window by default
# Options: square, wide, tall
_C.PROFILE.TELESCOPIC.CAMERA_SHAPE = "square"


# ---------------------------------------------------------------------------- #
#                           Bolognese Fishing Profile                          #
# ---------------------------------------------------------------------------- #
_C.PROFILE.BOLOGNESE = CN()
_C.PROFILE.BOLOGNESE.MODE = "bolognese"
# Launch options that overwrites SCRIPT.LAUNCH_OPTIONS
# Fall back to SCRIPT.LAUNCH_OPTIONS if left empty
_C.PROFILE.BOLOGNESE.LAUNCH_OPTIONS = ""
# Power level for casting, 1 ~ 5
# 1: 0%, 2: ~25%, 3: ~50%, 4: ~75% 5: 100%+ (power cast), FYR
# For instance, 2.5 cast_power_level equals to 37.5% casting power
_C.PROFILE.BOLOGNESE.CAST_POWER_LEVEL = 5.0
# Delay after casting before lure sinks
_C.PROFILE.BOLOGNESE.CAST_DELAY = 4.0
# Sensitivity of float detection
_C.PROFILE.BOLOGNESE.FLOAT_SENSITIVITY = 0.68
_C.PROFILE.BOLOGNESE.CHECK_DELAY = 1.0  # Delay between fish bite checks
_C.PROFILE.BOLOGNESE.PULL_DELAY = 0.5  # Delay pulling a fish after it's hooked
# Recast rod after timed out, designed for flowing water maps
_C.PROFILE.BOLOGNESE.DRIFT_TIMEOUT = 32.0
# Shape of the float camera, the script tracks the whole camrea window by default
# Options: square, wide, tall
# (Fallback to float camera detection mode if the window size is not supported)
_C.PROFILE.BOLOGNESE.CAMERA_SHAPE = "square"
# Hold Shift key during fish fight. Options: on, off, auto
_C.PROFILE.BOLOGNESE.POST_ACCELERATION = "off"


def get_cfg_defaults():
    """Get a yacs CfgNode object with default values for my_project."""
    # Return a clone so that the defaults will not be altered
    # This is for the "local variable" use pattern
    return _C.clone()

            📄 __init__.py  [Текстовый файл]:

    📁 controller/
            📄 detection.py  [Текстовый файл]:
"""Module for pyautogui.locateOnScreen and pag.pixel wrappers.

This module provides functionality for detecting in-game elements using image recognition
and pixel color analysis. It is used for automating tasks in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import time
from enum import Enum
from functools import partial
from pathlib import Path
from typing import Generator

import cv2
import numpy as np
import pyautogui as pag
from PIL import Image
from pyscreeze import Box

from rf4s.controller.window import Window

CRITICAL_COLOR = (206, 56, 21)
WARNING_COLOR = (227, 149, 23)
WHITE = (255, 255, 255)

MIN_GRAY_SCALE_LEVEL = 150
YELLOW_FRICTION_BRAKE = (200, 214, 63)
ORANGE_FRICTION_BRAKE = (229, 188, 0)
RED_FRICTION_BRAKE = (206, 56, 21)
COLOR_TOLERANCE = 32
CAMERA_OFFSET = 40
SIDE_LENGTH = 160
SIDE_LENGTH_HALF = 80
ORANGE_REEL = (227, 149, 23)

ROOT = Path(__file__).resolve().parents[2]


class TagColor(Enum):
    GREEN = "green_tag"
    YELLOW = "yellow_tag"
    PINK = "pink_tag"
    BLUE = "blue_tag"
    PURPLE = "purple_tag"


COORD_OFFSETS = {
    "1600x900": {
        "friction_brake_very_high": (502, 872),  # Left point only
        "friction_brake_high": (459, 872),
        "friction_brake_medium": (417, 872),
        "friction_brake_low": (396, 872),
        "fish_icon": (389, 844),
        "clip_icon": (1042, 844),
        "spool_icon": (1077, 844),  # x + 15, y + 15
        "reel_burning_icon": (1112, 842),
        "snag_icon": (1147, 829),  # x + 15, y
        "float_camera": (720, 654),
        "bait_icon": (35, 31),
    },
    "1920x1080": {
        "friction_brake_very_high": (662, 1052),
        "friction_brake_high": (619, 1052),
        "friction_brake_medium": (577, 1052),
        "friction_brake_low": (556, 1052),
        "fish_icon": (549, 1024),
        "clip_icon": (1202, 1024),
        "spool_icon": (1237, 1024),
        "reel_burning_icon": (1271, 1023),
        "snag_icon": (1307, 1009),
        "float_camera": (880, 834),
        "bait_icon": (35, 31),
    },
    "2560x1440": {
        "friction_brake_very_high": (982, 1412),
        "friction_brake_high": (939, 1412),
        "friction_brake_medium": (897, 1412),
        "friction_brake_low": (876, 1412),
        "fish_icon": (869, 1384),
        "clip_icon": (1522, 1384),
        "spool_icon": (1557, 1384),
        "reel_burning_icon": (1593, 1383),
        "snag_icon": (1627, 1369),
        "float_camera": (1200, 1194),
        "bait_icon": (35, 31),
    },
}

# ------------------------ Friction brake coordinates ------------------------ #
# ----------------------------- 900p - 1080p - 2k ---------------------------- #
# ------ left - red - yellow - center(left + 424) - yellow - red - right ----- #
# "bases": ((480, 270), (320, 180), (0, 0))
# "absolute": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702, "y": (1146, 1236, 1412)}
# "1600x900": {"x": (375, 480, 586, 799, 1011, 1118, 1222), "y": 876},
# "1920x1080": {"x": (535, 640, 746, 959, 1171, 1278, 1382), "y": 1056},
# "2560x1440": {"x": (855, 960, 1066, 1279, 1491, 1598, 1702), "y": 1412},


class Detection:
    """A class that holds different aliases of locateOnScreen(image).

    This class provides methods for detecting various in-game elements such as fish,
    icons, and UI components using image recognition and pixel color analysis.

    Attributes:
        cfg (CfgNode): Configuration node for the detection settings.
        window (Window): Game window controller instance.
        image_dir (Path): Directory containing reference images for detection.
        coord_offsets (dict): Dictionary of coordinate offsets for different window sizes.
        bait_icon_reference_img (Image): Reference image for bait icon detection.
    """

    def __init__(self, cfg, window: Window):
        """Initialize the Detection class with configuration and window settings.

        :param cfg: Configuration node for detection settings.
        :type cfg: CfgNode
        :param window: Game window controller instance.
        :type window: Window
        """
        self.cfg = cfg
        self.window = window
        self.image_dir = ROOT / "static" / cfg.SCRIPT.LANGUAGE

        if window.is_size_supported():
            self._set_absolute_coords()
            self.is_fish_hooked = self.is_fish_hooked_pixel
        else:
            self.is_fish_hooked = partial(
                self._get_image_box,
                image="fish_icon",
                confidence="0.9",
            )

        self.bait_icon_reference_img = Image.open(self.image_dir / "bait_icon.png")

    def _get_image_box(
        self, image: str, confidence: float, multiple: bool = False
    ) -> Box | Generator[Box, None, None] | None:
        """A wrapper for locateOnScreen method and path resolving.

        :param image: Base name of the image.
        :type image: str
        :param confidence: Matching confidence for locateOnScreen.
        :type confidence: float
        :param multiple: Whether to locate all matching images, defaults to False.
        :type multiple: bool, optional
        :return: Image box, None if not found.
        :rtype: Box | None
        """
        image_path = str(self.image_dir / f"{image}.png")
        if multiple:
            return pag.locateAllOnScreen(image_path, confidence=confidence)
        return pag.locateOnScreen(image_path, confidence=confidence)

    def _set_absolute_coords(self) -> None:
        """Add offsets to the base coordinates to get absolute ones."""
        self.coord_offsets = COORD_OFFSETS[self.window.get_resolution_str()]

        for key in self.coord_offsets:
            setattr(self, f"{key}_coord", self._get_absolute_coord(key))

        self.bait_icon_coord = self._get_absolute_coord("bait_icon") + [44, 52]
        friction_brake_key = f"friction_brake_{self.cfg.FRICTION_BRAKE.SENSITIVITY}"
        self.friction_brake_coord = self._get_absolute_coord(friction_brake_key)

        bases = self._get_absolute_coord("float_camera")
        if self.cfg.SELECTED.MODE in ("telescopic", "bolognese"):
            match self.cfg.SELECTED.CAMERA_SHAPE:
                case "tall":
                    bases[0] += CAMERA_OFFSET
                    width, height = SIDE_LENGTH_HALF, SIDE_LENGTH
                case "wide":
                    bases[1] += CAMERA_OFFSET
                    width, height = SIDE_LENGTH, SIDE_LENGTH_HALF
                case "square":
                    width, height = SIDE_LENGTH, SIDE_LENGTH
                case _:
                    raise ValueError(self.cfg.SELECTED.CAMERA_SHAPE)
            self.float_camera_rect = (*bases, width, height)  # (left, top, w, h)

    def _get_absolute_coord(self, offset_key: str) -> list[int]:
        """Calculate absolute coordinate based on given key.

        :param offset_key: A key in the offset dictionary.
        :type offset_key: str
        :return: Converted absolute coordinate.
        :rtype: list[int]
        """
        box = self.window.get_box()
        return [box[i] + self.coord_offsets[offset_key][i] for i in range(2)]

    # ----------------------------- Untagged release ----------------------------- #
    def is_tag_exist(self, color: TagColor):
        match color:
            case TagColor.GREEN:
                lower = np.array([30, 128, 128])
                upper = np.array([36, 255, 255])
            case TagColor.YELLOW:
                lower = np.array([22, 128, 128])
                upper = np.array([28, 255, 255])
            case TagColor.PINK:
                lower = np.array([142, 64, 128])
                upper = np.array([148, 255, 255])
            case TagColor.BLUE:
                lower = np.array([101, 64, 128])
                upper = np.array([107, 255, 255])
            case TagColor.PURPLE:
                lower = np.array([127, 64, 128])
                upper = np.array([133, 255, 255])
            case _:
                raise ValueError("Invalid tag color")
        hsv_img = cv2.cvtColor(np.array(pag.screenshot()), cv2.COLOR_RGB2HSV)
        mask = cv2.inRange(hsv_img, lower, upper)
        haystack_img = Image.fromarray(mask)
        needle_img = Image.open(self.image_dir / f"{color.value}.png")
        return pag.locate(needle_img, haystack_img, grayscale=True, confidence=0.9)

    def is_fish_species_matched(self, species: str):
        return self._get_image_box(species, 0.9)

    # -------------------------------- Fish status ------------------------------- #
    def is_fish_hooked(self):
        pass  # It's initialized in the constructor

    def is_fish_hooked_pixel(self) -> bool:
        return all(c > MIN_GRAY_SCALE_LEVEL for c in pag.pixel(*self.fish_icon_coord))

    def is_fish_hooked_twice(self) -> bool:
        if not self.is_fish_hooked():
            return False

        # check if the fish got away after a short delay
        time.sleep(self.cfg.SELECTED.HOOK_DELAY)
        if self.is_fish_hooked():
            return True
        return False

    def is_fish_captured(self):
        return self._get_image_box("keep", 0.9)

    def is_fish_whitelisted(self) -> bool:
        """Check if the fish is in the whitelist.

        :return: True if the fish is in the whitelist, False otherwise.
        :rtype: bool
        """
        return self._is_fish_in_list(self.cfg.KEEPNET.WHITELIST)

    def is_fish_blacklisted(self) -> bool:
        """Check if the fish is in the blacklist.

        :return:  True if the fish is in the blacklist, False otherwise
        :rtype: bool
        """
        return self._is_fish_in_list(self.cfg.KEEPNET.BLACKLIST)

    def _is_fish_in_list(self, fish_species_list: tuple | list) -> bool:
        """Check if the fish species matches any in the table.

        :param fish_species_list: fish species list
        :type fish_species_list: tuple | list
        :return: True if the fish species matches, False otherwise
        :rtype: bool
        """
        for species in fish_species_list:
            if self.is_fish_species_matched(species):
                return True
        return False

    # ---------------------------- Retrieval detection --------------------------- #
    def is_retrieval_finished(self):
        ready = self.is_tackle_ready()
        if self.cfg.ARGS.RAINBOW:
            return ready or self._is_rainbow_line_0or5m()
        return ready or self._is_spool_full()

    def _is_rainbow_line_0or5m(self):
        return self._get_image_box(
            "5m", self.cfg.SCRIPT.SPOOL_CONFIDENCE
        ) or self._get_image_box("0m", self.cfg.SCRIPT.SPOOL_CONFIDENCE)

    def _is_spool_full(self):
        return self._get_image_box("wheel", self.cfg.SCRIPT.SPOOL_CONFIDENCE)

    def is_line_snagged(self) -> bool:
        return pag.pixel(*self.snag_icon_coord) == CRITICAL_COLOR

    def is_line_at_end(self) -> bool:
        return pag.pixel(*self.spool_icon_coord) in (WARNING_COLOR, CRITICAL_COLOR)

    def is_clip_open(self) -> bool:
        return not all(
            c > MIN_GRAY_SCALE_LEVEL for c in pag.pixel(*self.clip_icon_coord)
        )

    # ------------------------------ Text detection ------------------------------ #
    def is_tackle_ready(self):
        return self._get_image_box("ready", 0.6)

    def is_tackle_broken(self):
        return self._get_image_box("broke", 0.8)

    def is_lure_broken(self):
        return self._get_image_box("lure_is_broken", 0.8)

    def is_moving_in_bottom_layer(self):
        return self._get_image_box("movement", 0.7)

    # ------------------------------ Hint detection ------------------------------ #
    def is_disconnected(self):
        return self._get_image_box("disconnected", 0.9)

    def is_ticket_expired(self):
        return self._get_image_box("ticket", 0.9)

    # ------------------------------- Item crafting ------------------------------ #
    def is_operation_failed(self):
        return self._get_image_box("warning", 0.8)

    def is_operation_success(self):
        return self._get_image_box("ok_black", 0.8) or self._get_image_box(
            "ok_white", 0.8
        )

    def is_material_complete(self):
        return not self._get_image_box("material_slot", 0.7)

    # ---------------------- Quiting game from control panel --------------------- #
    def get_quit_position(self):
        return self._get_image_box("quit", 0.8)

    def get_yes_position(self):
        return self._get_image_box("yes", 0.8)

    def get_make_button_position(self):
        return self._get_image_box("make", 0.9)

    # ------------------------ Quiting game from main menu ----------------------- #
    def get_exit_icon_position(self):
        return self._get_image_box("exit", 0.8)

    def get_confirm_button_position(self):
        return self._get_image_box("confirm", 0.8)

    # ------------------------------- Player stats ------------------------------- #
    def _get_energy_icon_position(self):
        box = self._get_image_box("energy", 0.8)
        return box if box is None else pag.center(box)

    def _get_food_icon_position(self):
        box = self._get_image_box("food", 0.8)
        return box if box is None else pag.center(box)

    def _get_comfort_icon_position(self):
        box = self._get_image_box("comfort", 0.8)
        return box if box is None else pag.center(box)

    def get_food_position(self, food: str):
        return self._get_image_box(food, 0.8)

    def is_energy_high(self) -> bool:
        pos = self._get_energy_icon_position()
        if not pos:
            return False
        x, y = int(pos.x), int(pos.y)
        # default threshold: 0.74,  well done FishSoft
        last_point = int(19 + 152 * self.cfg.STAT.ENERGY_THRESHOLD) - 1
        return pag.pixel(x + 19, y) == pag.pixel(x + last_point, y)

    def is_hunger_low(self) -> bool:
        pos = self._get_food_icon_position()
        if not pos:
            return False
        x, y = int(pos.x), int(pos.y)
        last_point = int(18 + 152 * self.cfg.STAT.HUNGER_THRESHOLD) - 1
        return not pag.pixel(x + 18, y) == pag.pixel(x + last_point, y)

    def is_comfort_low(self) -> bool:
        pos = self._get_comfort_icon_position()
        if not pos:
            return False
        x, y = int(pos.x), int(pos.y)
        last_point = int(18 + 152 * self.cfg.STAT.COMFORT_THRESHOLD) - 1
        return not pag.pixel(x + 18, y) == pag.pixel(x + last_point, y)

    # ----------------------------- Item replacement ----------------------------- #
    def get_scrollbar_position(self):
        return self._get_image_box("scrollbar", 0.97)

    def get_100wear_position(self):
        return self._get_image_box("100wear", 0.98)

    def get_favorite_item_positions(self):
        return self._get_image_box("favorite", 0.95, multiple=True)

    def is_pva_chosen(self):
        return self._get_image_box("pva_icon", 0.6) is None

    def is_bait_chosen(self):
        if self.cfg.SELECTED.MODE in ("pirk", "elevator"):
            return True

        # Two bait slots, check only the first one
        if self.cfg.SELECTED.MODE in ("telescopic", "bolognese"):
            return (
                pag.locate(
                    pag.screenshot(region=self.bait_icon_coord),
                    self.bait_icon_reference_img,
                    confidence=0.6,
                )
                is None
            )
        return self._get_image_box("bait_icon", 0.6) is None

    def is_groundbait_chosen(self):
        return self._get_image_box("groundbait_icon", 0.6) is None

    def get_groundbait_position(self):
        return self._get_image_box("classic_feed_mix", 0.95)

    def get_dry_mix_position(self):
        return self._get_image_box("dry_feed_mix", 0.95)

    def get_pva_position(self):
        return self._get_image_box("pva_stick_or_pva_stringer", 0.95)

    # ------------------------------ Friction brake ------------------------------ #
    def is_friction_brake_high(self) -> bool:
        return pag.pixelMatchesColor(
            *self.friction_brake_coord, RED_FRICTION_BRAKE, COLOR_TOLERANCE
        )

    def is_reel_burning(self) -> bool:
        return pag.pixel(*self.reel_burning_icon_coord) == ORANGE_REEL

    def is_float_state_changed(self, reference_img):
        current_img = pag.screenshot(region=self.float_camera_rect)
        return not pag.locate(
            current_img,
            reference_img,
            grayscale=True,
            confidence=self.cfg.SELECTED.FLOAT_SENSITIVITY,
        )

    def get_ticket_position(self, duration: int):
        return self._get_image_box(f"ticket_{duration}", 0.95)

    def is_harvest_success(self):
        return self._get_image_box("harvest_confirm", 0.8)

    def is_gift_receieved(self):
        return self._get_image_box("gift", 0.8)

            📄 notification.py  [Текстовый файл]:
import json
import logging
import smtplib
from datetime import datetime, timezone
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from enum import Enum
from urllib import parse, request

from discord_webhook import DiscordEmbed, DiscordWebhook
from rich import box
from rich.console import Console
from rich.table import Table

logger = logging.getLogger("rich")

ICON_URL = "https://i.ibb.co/RpLYcdkm/icon.png"

# Name                             | Int value | Hex code
# ---------------------------------|-----------|----------
# `BLURPLE`                        | 5793266   | `#5865F2`
# `GREEN`                          | 5763719   | `#57F287`
# `YELLOW`                         | 16705372  | `#FEE75C`
# `FUSCHIA`                        | 15418782  | `#EB459E`
# `RED`                            | 15548997  | `#ED4245`
# `WHITE`                          | 16777215  | `#FFFFFF`
# `BLACK`                          | 2303786   | `#23272A`


class DiscordColor(Enum):
    BLURPLE = 5793266
    GREEN = 5763719
    YELLOW = 16705372
    FUSCHIA = 15418782
    RED = 15548997
    WHITE = 16777215
    BLACK = 2303786


class DiscordNotification:
    def __init__(self, cfg, result):
        self.cfg = cfg
        self.result = result

    def build_raw_table(self) -> str:
        console = Console(width=100, force_terminal=True, color_system=None)
        table = Table("Field", "Value", box=box.DOUBLE, show_header=False)

        for key, value in self.result.items():
            table.add_row(key, str(value))

        with console.capture() as capture:
            console.print(table)

        return capture.get().strip()

    def send(self, color: DiscordColor):
        logger.info("Sending Discord notification")
        raw_table = self.build_raw_table()
        webhook = DiscordWebhook(
            url=self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL,
            username="RF4S",
            avatar_url=ICON_URL,
        )

        embed = DiscordEmbed(
            title="Running Result",
            color=color,
            timestamp=datetime.now(timezone.utc).isoformat(),
            footer={"text": "RF4S: Russian Fishing 4 Script", "icon_url": ICON_URL},
        )
        embed.description = f"```\n{raw_table}\n```"  # Wrap in code block

        webhook.add_embed(embed)
        response = webhook.execute()

        if response.status_code == 200:
            logger.info("Result successfully sent to Discord")
        else:
            logger.error(f"Failed to send result to Discord: {response.text}")


class EmailNotification:
    def __init__(self, cfg, result):
        self.cfg = cfg
        self.result = result

    def send(self) -> None:
        """Send a notification email to the user's email address."""
        logger.info("Sending email notification")

        msg = MIMEMultipart()
        msg["Subject"] = "RF4S: Notice of Program Termination"
        msg["From"] = self.cfg.NOTIFICATION.EMAIL
        recipients = [self.cfg.NOTIFICATION.EMAIL]
        msg["To"] = ", ".join(recipients)

        text = ""
        for k, v in self.result.items():
            text += f"{k}: {v}\n"
        msg.attach(MIMEText(text))

        try:
            with smtplib.SMTP_SSL(self.cfg.NOTIFICATION.SMTP_SERVER, 465) as server:
                # smtp_server.ehlo()
                server.login(
                    self.cfg.NOTIFICATION.EMAIL, self.cfg.NOTIFICATION.PASSWORD
                )
                server.sendmail(
                    self.cfg.NOTIFICATION.EMAIL, recipients, msg.as_string()
                )
            logger.info("Email sent successfully")
        except Exception as e:
            logger.error(f"Failed to send email: {e}")


class MiaotixingNotification:
    def __init__(self, cfg, result):
        self.cfg = cfg
        self.result = result

    def send(self) -> None:
        """Send a notification to the user's miaotixing service.

        :param result: running result
        :type result: dict
        """
        logger.info("Sending miaotixing notification")

        text = ""
        for k, v in self.result.items():
            text += f"{k}: {v}\n"

        url = "http://miaotixing.com/trigger?" + parse.urlencode(
            {"id": self.cfg.NOTIFICATION.MIAO_CODE, "text": text, "type": "json"}
        )

        with request.urlopen(url) as page:
            result = page.read()
            json_object = json.loads(result)
            if json_object["code"] == 0:
                logger.info("Miaotixing notification sent successfully")
            else:
                logger.error(
                    "Miaotixing notification with error code: %s\nDescription: %s",
                    str(json_object["code"]),
                    json_object["msg"],
                )

            📄 timer.py  [Текстовый файл]:
"""Module for Timer class.

This module provides functionality for managing timers and generating timestamps
for logging and automation purposes in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import datetime
import logging
import time

from matplotlib import pyplot as plt
from matplotlib.ticker import MaxNLocator

logger = logging.getLogger("rich")


class Timer:
    """Class for calculating and generating timestamps for logs.

    This class manages various timers and counters for tracking in-game events,
    such as casting times, consumable cooldowns, and script pauses.

    Attributes:
        cfg (CfgNode): Configuration node for timer settings.
        start_time (float): Timestamp when the timer was initialized.
        start_datetime (str): Formatted start date and time.
        cast_rhour (int | None): Real-time hour of the last cast.
        cast_ghour (int | None): In-game hour of the last cast.
        cast_rhour_list (list[int]): List of real-time hours for casts.
        cast_ghour_list (list[int]): List of in-game hours for casts.
        last_tea_drink (float): Timestamp of the last tea consumption.
        last_alcohol_drink (float): Timestamp of the last alcohol consumption.
        last_lure_change (float): Timestamp of the last lure change.
        last_spod_rod_recast (float): Timestamp of the last spod rod recast.
        last_pause (float): Timestamp of the last script pause.
    """

    def __init__(self, cfg):
        """Initialize the Timer class with configuration settings.

        :param cfg: Configuration node for timer settings.
        :type cfg: CfgNode
        """
        self.cfg = cfg
        self.start_time = time.time()
        self.start_datetime = time.strftime("%m/%d %H:%M:%S", time.localtime())

        self.cast_rhour = None
        self.cast_ghour = None
        self.cast_rhour_list = []
        self.cast_ghour_list = []

        self.last_tea_drink = 0
        self.last_alcohol_drink = 0
        self.last_lure_change = self.start_time
        self.last_spod_rod_recast = self.start_time
        self.last_pause = self.start_time

    def get_running_time(self) -> str:
        """Calculate the execution time of the program.

        :return: Formatted execution time (hh:mm:ss).
        :rtype: str
        """
        return time.time() - self.start_time

    def get_running_time_str(self) -> str:
        """Calculate the execution time of the program.

        :return: Formatted execution time (hh:mm:ss).
        :rtype: str
        """
        return str(
            datetime.timedelta(seconds=int(time.time() - self.start_time))
        )  # truncate to seconds

    def get_cur_timestamp(self) -> str:
        """Generate timestamp for images in screenshots/.

        :return: Current timestamp.
        :rtype: str
        """
        return time.strftime("%Y-%m-%d--%H-%M-%S", time.localtime())

    def get_start_datetime(self) -> str:
        """Generate a simplified timestamp for quit message.

        :return: Start date and time.
        :rtype: str
        """
        return self.start_datetime

    def get_cur_datetime(self) -> str:
        """Generate a simplified timestamp for quit message.

        :return: Current date and time.
        :rtype: str
        """
        return time.strftime("%m/%d %H:%M:%S", time.localtime())

    def update_cast_time(self) -> None:
        """Update the latest real and in-game hour of casting."""
        dt = datetime.datetime.now()
        self.cast_rhour = int((time.time() - self.start_time) // 3600)
        self.cast_ghour = int((dt.minute / 60 + dt.second / 3600) * 24 % 24)

    def add_cast_time(self) -> None:
        """Record the latest real and in-game hour of casting."""
        self.cast_rhour_list.append(self.cast_rhour)
        self.cast_ghour_list.append(self.cast_ghour)

    def get_cast_time_list(self) -> tuple[list[int]]:
        """Get lists of real and in-game hours for casts.

        :return: Lists of real and in-game hours.
        :rtype: tuple[list[int]]
        """
        return self.cast_rhour_list, self.cast_ghour_list

    def is_tea_drinkable(self) -> bool:
        """Check if it has been a long time since the last tea consumption.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_tea_drink > self.cfg.STAT.TEA_DELAY:
            self.last_tea_drink = cur_time
            return True
        return False

    def is_alcohol_drinkable(self) -> bool:
        """Check if it has been a long time since the last alcohol consumption.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_alcohol_drink > self.cfg.STAT.ALCOHOL_DELAY:
            self.last_alcohol_drink = cur_time
            self.last_tea_drink = cur_time  # Alcohol also refill comfort
            return True
        return False

    def is_lure_changeable(self):
        """Check if it has been a long time since the last lure change.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_lure_change > self.cfg.SCRIPT.LURE_CHANGE_DELAY:
            self.last_lure_change = cur_time
            return True
        return False

    def is_spod_rod_castable(self):
        """Check if it has been a long time since the last spod rod recast.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_spod_rod_recast > self.cfg.SCRIPT.SPOD_ROD_RECAST_DELAY:
            self.last_spod_rod_recast = cur_time
            return True
        return False

    def is_script_pausable(self):
        """Check if it has been a long time since the last script pause.

        :return: True if long enough, False otherwise.
        :rtype: bool
        """
        cur_time = time.time()
        if cur_time - self.last_pause > self.cfg.PAUSE.DELAY:
            self.last_pause = cur_time
            return True
        return False

    def plot_and_save(self) -> None:
        """Plot and save an image using rhour and ghour lists from the timer object."""
        logger.info("Plotting line chart")

        cast_rhour_list, cast_ghour_list = self.get_cast_time_list()
        _, ax = plt.subplots(nrows=1, ncols=2)
        # _.canvas.manager.set_window_title('Record')
        ax[0].set_ylabel("Fish")

        last_rhour = cast_rhour_list[-1]  # Hour: 0, 1, 2, 3, 4, "5"
        fish_per_rhour = [0] * (last_rhour + 1)  # Idx: (0, 1, 2, 3, 4, 5) = 6
        for hour in cast_rhour_list:
            fish_per_rhour[hour] += 1
        ax[0].plot(range(last_rhour + 1), fish_per_rhour)
        ax[0].set_title("Fish Caughted per Real Hour")
        ax[0].set_xticks(range(last_rhour + 2))
        ax[0].set_xlabel("Hour (real running time)")
        ax[0].yaxis.set_major_locator(MaxNLocator(integer=True))

        fish_per_ghour = [0] * 24
        for hour in cast_ghour_list:
            fish_per_ghour[hour] += 1
        ax[1].bar(range(0, 24), fish_per_ghour)
        ax[1].set_title("Fish Caughted per Game Hour")
        ax[1].set_xticks(range(0, 24, 2))
        ax[1].set_xlabel("Hour (game time)")
        ax[1].yaxis.set_major_locator(MaxNLocator(integer=True))

        # plt.tight_layout()
        plt.savefig(f"../logs/{self.get_cur_timestamp()}.png")
        logger.info("Chart has been saved under logs/")

            📄 window.py  [Текстовый файл]:
"""Module for window controller.

This module provides functionality for managing and interacting with the game window
and terminal window in Russian Fishing 4.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import sys
from pathlib import Path
from time import sleep

# import win32api, win32con
import pyautogui as pag
import win32con
import win32gui

logger = logging.getLogger("rich")

ROOT = Path(__file__).resolve().parents[2]
ANIMATION_DELAY = 0.25


class Window:
    """Controller for terminal and game windows management.

    This class handles window focus, size detection, and screenshot functionality
    for the game and terminal windows.

    Attributes:
        game_title (str): Title of the game window.
        terminal_hwnd (int): Handle of the terminal window.
    """

    def __init__(self, game_title: str = "Russian Fishing 4"):
        """Set the hwnd of the terminal where user run the script.

        We didn't retrieve the game window's hwnd here because we don't want to check
        if the window is open right away. Instead, we perform the check after the
        configuration is set.

        :param game_title: Title of the game, defaults to "Russian Fishing 4".
        :type game_title: str, optional
        """
        self.game_title = game_title
        self.terminal_hwnd = win32gui.GetForegroundWindow()

    def _get_game_hwnd(self) -> int:
        """Get the handle of the game window.

        :return: Process handle of the game window.
        :rtype: int
        """
        hwnd = win32gui.FindWindow(None, self.game_title)  # class name: UnityWndClass
        if hwnd == 0:
            logger.critical("Failed to locate the game window: %s", self.game_title)
            sys.exit(1)
        return hwnd

    def is_title_bar_exist(self) -> bool:
        """Check if the game window is in windowed mode.

        :return: True if the game window has a title bar, False otherwise.
        :rtype: bool
        """
        style = win32gui.GetWindowLong(self._get_game_hwnd(), win32con.GWL_STYLE)
        return style & win32con.WS_CAPTION

    def get_box(self) -> tuple[int, int, int, int]:
        """Get the coordinates and dimensions of the game window.

        :return: Tuple containing (x, y, width, height) of the game window.
        :rtype: tuple[int, int, int, int]
        """
        # Absolute coordinates
        base_x, base_y, _, _ = win32gui.GetWindowRect(self._get_game_hwnd())
        if self.is_title_bar_exist():
            base_x += 8
            base_y += 31
        # Relative coordinates
        left, top, right, bottom = win32gui.GetClientRect(self._get_game_hwnd())
        return base_x, base_y, right - left, bottom - top

    def get_base_coordinates(self) -> tuple[int, int]:
        """Get the base coordinates of the game window.

        :return: Tuple containing (x, y) of the base coordinates.
        :rtype: tuple[int, int]
        """
        return self.get_box()[:2]

    def get_resolution_str(self) -> tuple[int, int]:
        """Get the resolution of the game window.

        :return: Tuple containing (width, height) of the game window.
        :rtype: tuple[int, int]
        """
        width, height = self.get_box()[2:]
        return f"{width}x{height}"

    def activate_script_window(self) -> None:
        """Focus the terminal where user run the script."""
        pag.press("alt")
        win32gui.SetForegroundWindow(self.terminal_hwnd)
        sleep(ANIMATION_DELAY)

    def activate_game_window(self) -> None:
        """Focus game window."""
        pag.press("alt")
        win32gui.SetForegroundWindow(self._get_game_hwnd())
        sleep(ANIMATION_DELAY)

    def is_size_supported(self) -> bool:
        """Check if the game window size is supported.

        :return: True if it's supported, False otherwise.
        :rtype: bool
        """
        return self.get_resolution_str() in (
            "2560x1440",
            "1920x1080",
            "1600x900",
        )

    def save_screenshot(self, time) -> None:
        """Save a screenshot of the game window to the screenshots directory.

        :param time: Timestamp for the filename.
        :type time: str
        """
        pag.screenshot(
            imageFilename=ROOT / "screenshots" / f"{time}.png",
            region=self.get_box(),
        )


if __name__ == "__main__":
    w = Window("Russian Fishing 4")
    # w.activate_game_window()
    print(w.get_box())
    print(w.get_base_coordinates())
    print(w.get_resolution_str())
    print(w.is_size_supported())

# SetForegroundWindow bug reference :
# https://stackoverflow.com/questions/56857560/win32gui-setforegroundwindowhandle-not-working-in-loop

        📄 exceptions.py  [Текстовый файл]:
"""
A module reserved for exception classes.
"""


class FishHookedError(Exception):
    """A fish is hooked during a wrong routine."""


class FishCapturedError(Exception):
    """A fish is captured during a wrong routine."""


class LineAtEndError(Exception):
    """Fishing line is at the end during retrieval."""


class LineSnaggedError(Exception):
    """Fishing line is snagged."""


class ItemNotFoundError(Exception):
    """Failed to find an available item for replacement."""


class LureBrokenError(Exception):
    """Lure is broken."""


class TackleBrokenError(Exception):
    """Tackle is broken."""


class DisconnectedError(Exception):
    """Disconnected from the game."""


class TicketExpiredError(Exception):
    """Ticket expired."""

        📄 player.py  [Текстовый файл]:
"""Module for Player class.

This module provides the main interface for automating fishing activities in a game.
It includes functionality for managing fishing loops, handling player stats, and
automating various fishing techniques.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import os
import random
import sys
from contextlib import contextmanager
from datetime import datetime
from multiprocessing import Lock

# from email.mime.image import MIMEImage
from pathlib import Path
from time import sleep

import pyautogui as pag
from playsound import playsound
from pynput import keyboard
from rich import box, print
from rich.table import Table

from rf4s import exceptions, utils
from rf4s.component.friction_brake import FrictionBrake
from rf4s.component.tackle import Tackle
from rf4s.controller.detection import Detection, TagColor
from rf4s.controller.notification import (
    DiscordColor,
    DiscordNotification,
    EmailNotification,
    MiaotixingNotification,
)
from rf4s.controller.timer import Timer
from rf4s.controller.window import Window
from rf4s.result.result import RF4SResult

logger = logging.getLogger("rich")
random.seed(datetime.now().timestamp())

PRE_RETRIEVAL_DURATION = 0.5
PULL_OUT_DELAY = 3
DIG_DELAY = 5
DIG_TIMEOUT = 32
ANIMATION_DELAY = 1
TICKET_EXPIRE_DELAY = 16
DISCONNECTED_DELAY = 8
WEAR_TEXT_UPDATE_DELAY = 2
PUT_DOWN_DELAY = 4

SCREENSHOT_DELAY = 2

TROLLING_KEY = "j"

FORWARD = "w"
LEFT_KEY = "a"
RIGHT_KEY = "d"


class Player:
    """Main interface of fishing loops and stages.

    This class manages the automation of fishing activities, including casting,
    retrieving, and handling fish. It also handles player stats, equipment, and
    various in-game mechanics.

    :param cfg: Configuration object containing settings for the fishing process.
    :type cfg: Config
    :param window: Window object for managing the game window.
    :type window: Window
    """

    def __init__(self, cfg, window: Window):
        """Initialize monitor, timer, and some trivial counters.

        :param cfg: Configuration object containing settings for the fishing process.
        :type cfg: Config
        :param window: Window object for managing the game window.
        :type window: Window
        """
        self.cfg = cfg
        self.window = window
        self.timer = Timer(cfg)
        self.detection = Detection(cfg, window)

        self.tackle_idx = 0
        if self.cfg.SELECTED.MODE == "bottom":
            self.num_tackle = len(self.cfg.KEY.BOTTOM_RODS)
        else:
            self.num_tackle = 1
        self.tackles = [
            Tackle(cfg, self.timer, self.detection) for _ in range(self.num_tackle)
        ]
        self.tackle = self.tackles[self.tackle_idx]

        self.friction_brake_lock = Lock()
        self.friction_brake = FrictionBrake(
            cfg, self.friction_brake_lock, self.detection
        )

        self.cur_coffee = 0
        self.have_new_lure = True
        self.have_new_groundbait = True
        self.have_new_dry_mix = True
        self.have_new_pva = True
        self.result = RF4SResult()

        self.clicklock_enabled = False

    def start_fishing(self) -> None:
        """Start the main fishing loop with the specified fishing strategy."""
        if self.cfg.ARGS.FRICTION_BRAKE:
            logger.info("Spawing new process, do not quit the script")
            self.friction_brake.monitor_process.start()

        if (
            self.cfg.SELECTED.MODE not in ("telescopic", "bottom")
            and not self.cfg.ARGS.SKIP_CAST
            and not self.detection.is_retrieval_finished()
        ):
            logger.critical(
                "The spool is not fully loaded, "
                "try moving your camera, "
                "changing your game window size or fishing line"
            )
            sys.exit(1)

        logger.info("Starting fishing mode: '%s'", self.cfg.SELECTED.MODE)
        self._start_trolling()
        getattr(self, f"start_{self.cfg.SELECTED.MODE}_mode")()

    # ---------------------------------------------------------------------------- #
    #                              main fishing loops                              #
    # ---------------------------------------------------------------------------- #
    def start_spin_mode(self) -> None:
        """Main spin fishing loop for 'spin' and 'spin_with_pause' modes."""
        skip_cast = self.cfg.ARGS.SKIP_CAST
        while True:
            if not skip_cast:
                self._refill_stats()
                self._harvest_baits(pickup=True)
                self.reset_tackle()
                self._change_tackle_lure()
                self._cast_tackle()
            skip_cast = False

            if self.cfg.SELECTED.TYPE != "normal":
                utils.hold_mouse_button(self.cfg.SELECTED.TIGHTEN_DURATION)
                getattr(self, f"retrieve_with_{self.cfg.SELECTED.TYPE}")()
            self.retrieve_line()

            if self.detection.is_fish_hooked():
                self.pull_fish()

    def retrieve_with_pause(self) -> None:
        """Retrieve the line, pausing periodically."""
        logger.info("Retrieving fishing line with pause")
        self.tackle._special_retrieve(button="left")

    def retrieve_with_lift(self) -> None:
        """Retrieve the line, lifting periodically."""
        logger.info("Retrieving fishing line with lift")
        with self.toggle_clicklock():
            self.tackle._special_retrieve(button="right")

    def start_bottom_mode(self) -> None:
        """Main bottom fishing loop."""
        check_miss_counts = [0] * self.num_tackle

        while True:
            if self.cfg.ARGS.SPOD_ROD and self.timer.is_spod_rod_castable():
                self._cast_spod_rod()
            self._refill_stats()
            self._harvest_baits()

            logger.info("Checking rod %s", self.tackle_idx + 1)
            pag.press(str(self.cfg.KEY.BOTTOM_RODS[self.tackle_idx]))
            sleep(ANIMATION_DELAY)
            if self.detection.is_fish_hooked():
                check_miss_counts[self.tackle_idx] = 0
                self.retrieve_and_recast()
            else:
                sleep(self.cfg.SELECTED.PUT_DOWN_DELAY)
                if self.detection.is_fish_hooked():
                    check_miss_counts[self.tackle_idx] = 0
                    self.retrieve_and_recast()
                else:
                    self._put_down_tackle(check_miss_counts)
            self._update_tackle()

    def retrieve_and_recast(self) -> None:
        self.retrieve_line()
        self.pull_fish()
        self.reset_tackle()
        self._refill_groundbait()
        self._refill_pva()
        self._cast_tackle(lock=True)

    def start_pirk_mode(self) -> None:
        """Main marine fishing loop for pirk mode."""
        self._start_sink_mode(pirk=True)

    def start_elevator_mode(self) -> None:
        """Main marine fishing loop for elevator mode."""
        self._start_sink_mode(pirk=False)

    def _start_sink_mode(self, pirk: bool) -> None:
        """Main marine fishing loop for pirk or elevator mode.

        :param pirk: Whether to perform pirking or elevating.
        :type pirk: bool
        """
        perform_technique = self.do_pirking if pirk else self.do_elevating
        skip_cast = self.cfg.ARGS.SKIP_CAST
        while True:
            if not skip_cast:
                self._refill_stats()
                self.reset_tackle()
                self._cast_tackle()
                self.tackle.sink()
            skip_cast = False

            perform_technique()
            self.retrieve_line()
            self.pull_fish()

    def start_telescopic_mode(self) -> None:
        """Main telescopic fishing loop."""
        self._start_float_mode(telescopic=True)

    def start_bolognese_mode(self) -> None:
        """Main bolognese fishing loop."""
        self._start_float_mode(telescopic=False)

    def _start_float_mode(self, telescopic: bool) -> None:
        """Main float fishing loop.

        :param telescopic: Whether the fishing mode is telescopic.
        :type telescopic: bool
        """
        monitor, hold_mouse_button = self._get_controllers(telescopic)

        while True:
            self._refill_stats()
            self._harvest_baits(pickup=True)
            self.reset_tackle()
            self._cast_tackle()

            try:
                with self.error_handler():
                    monitor()
                break
            except TimeoutError:
                pass

            sleep(self.cfg.SELECTED.PULL_DELAY)
            hold_mouse_button(PRE_RETRIEVAL_DURATION)
            self.pull_fish()

    def _harvest_baits(self, pickup: bool = False) -> None:
        """Harvest baits if energy is high.

        :param pickup: Whether to pick up the main rod after harvesting.
        :type pickup: bool
        """
        if not self.cfg.ARGS.HARVEST or not self.detection.is_energy_high():
            return
        logger.info("Harvesting baits")
        self._use_item("digging_tool")
        sleep(PULL_OUT_DELAY)
        pag.click()

        i = DIG_TIMEOUT
        while i > 0:
            i = utils.sleep_and_decrease(i, DIG_DELAY)
            if self.detection.is_harvest_success():
                logger.info("Baits harvested successfully")
                pag.press("space")
                pag.press("backspace")
                sleep(ANIMATION_DELAY)
                self.result.bait += 1
                break

        if pickup:
            self._use_item("main_rod")
            sleep(PULL_OUT_DELAY)

        # When timed out, do not raise a TimeoutError but defer it to resetting stage

    def _refill_stats(self) -> None:
        """Refill player stats using tea and carrot."""
        if not self.cfg.ARGS.REFILL:
            return

        logger.info("Refilling player stats")
        # Comfort is affected by weather, add a check to avoid over drink
        if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
            self._use_item("tea")
            self.result.tea += 1

        if self.detection.is_hunger_low():
            self._use_item("carrot")
            self.result.carrot += 1

    def _drink_alcohol(self) -> None:
        """Drink alcohol with the given quantity."""
        if not self.cfg.ARGS.ALCOHOL or not self.timer.is_alcohol_drinkable():
            return

        logger.info("Drinking alcohol")
        for _ in range(self.cfg.STAT.ALCOHOL_PER_DRINK):
            self._use_item("alcohol")
        self.result.alcohol += self.cfg.STAT.ALCOHOL_PER_DRINK

    def _drink_coffee(self) -> None:
        """Drink coffee to refill energy if energy is low."""
        if not self.cfg.ARGS.COFFEE or self.detection.is_energy_high():
            return

        if self.cur_coffee > self.cfg.STAT.COFFEE_LIMIT:
            pag.press("esc")  # Just back to control panel to reduce power usage
            self._handle_termination("Coffee limit reached", shutdown=False)

        logger.info("Drinking coffee")
        for _ in range(self.cfg.STAT.COFFEE_PER_DRINK):
            self._use_item("coffee")
        self.cur_coffee += self.cfg.STAT.COFFEE_PER_DRINK
        self.result.coffee += self.cfg.STAT.COFFEE_PER_DRINK

    def _use_item(self, item: str) -> None:
        """Access an item by name using quick selection shortcut or menu.

        :param item: The name of the item to access.
        :type item: str
        """
        logger.info("Using %s", item)
        key = str(self.cfg.KEY[item.upper()])
        if key != "-1":  # Use shortcut
            pag.press(key)
        else:  # Open food menu
            with pag.hold("t"):
                sleep(ANIMATION_DELAY)
                food_position = self.detection.get_food_position(item)
                pag.moveTo(food_position)
                pag.click()
        sleep(ANIMATION_DELAY)

    def enable_clicklock(self):
        pag.mouseDown()
        sleep(2.2)
        self.clicklock_enabled = True

    def disable_clicklock(self):
        pag.click()
        self.clicklock_enabled = False

    @contextmanager
    def toggle_clicklock(self):
        self.enable_clicklock()
        yield
        self.disable_clicklock()

    @utils.reset_friction_brake_after
    def reset_tackle(self) -> None:
        """Reset the tackle until it is ready."""
        sleep(ANIMATION_DELAY)
        if self.detection.is_tackle_ready():
            return

        if self.detection.is_lure_broken():
            self._handle_broken_lure()
            return

        if self.cfg.ARGS.SPOD_ROD and not self.detection.is_groundbait_chosen():
            self._refill_dry_mix()
            return

        if not self.detection.is_bait_chosen():
            if len(self.tackles) == 1:
                self.general_quit("Run out of bait")
            self.tackle.available = False
            return

        with self.toggle_clicklock():
            while True:
                try:
                    # Outer -> inner
                    with (
                        self.error_handler(),
                        self.clicklock_disable_handler(),
                        pag.hold("shift"),
                    ):
                        self.tackle.reset()
                    break
                except TimeoutError:
                    # If it's a TimeoutError or an exception was transformed into a
                    # TimeoutError, enable clicklock again if necessary.
                    if not self.clicklock_enabled:
                        self.enable_clicklock()

    @contextmanager
    def error_handler(self):
        try:
            yield
        except exceptions.FishHookedError:
            self.pull_fish()
        except exceptions.FishCapturedError:
            self.handle_fish()
        except exceptions.LineAtEndError:
            if self.cfg.ARGS.FRICTION_BRAKE:
                with self.friction_brake.lock:
                    self.friction_brake.change(increase=False)
            self.general_quit("Fishing line is at its end")
        except exceptions.LineSnaggedError:
            self._handle_snagged_line()
        except exceptions.LureBrokenError:
            self._handle_broken_lure()
            raise TimeoutError  # Transform into TimeoutError to continue
        except exceptions.TackleBrokenError:
            self.general_quit("Tackle is broken")
        except exceptions.DisconnectedError:
            self.disconnected_quit()
        except exceptions.TicketExpiredError:
            self._handle_expired_ticket()
            raise TimeoutError  # Transform into TimeoutError to continue
        except TimeoutError:
            raise

    @contextmanager
    def clicklock_disable_handler(self):
        try:
            yield
        except (
            exceptions.FishHookedError,
            exceptions.FishCapturedError,
            exceptions.LineAtEndError,
            exceptions.LineSnaggedError,
            exceptions.LureBrokenError,
            exceptions.TackleBrokenError,
            exceptions.DisconnectedError,
            exceptions.TicketExpiredError,
        ):
            if self.clicklock_enabled:
                self.disable_clicklock()
            raise

    def _cast_spod_rod(self) -> None:
        """Cast the spod rod if dry mix is available."""
        self._use_item("spod_rod")
        self.reset_tackle()

        # If no dry mix is available, skip casting
        if not self.tackle.available:
            self.tackle.available = True
            return
        self._cast_tackle(lock=True, update=False)
        pag.press("0")
        sleep(ANIMATION_DELAY)

    def _cast_tackle(self, lock: bool = False, update: bool = True) -> None:
        """Cast the current tackle.

        :param lock: Whether to lock the tackle after casting.
        :type lock: bool
        :param update: Whether to update the cast time.
        :type update: bool
        """
        if self.cfg.ARGS.PAUSE and self.timer.is_script_pausable():
            self._pause_script()

        if self.cfg.ARGS.BITE:
            self.window.save_screenshot(self.timer.get_cur_timestamp())

        if (
            self.cfg.ARGS.RANDOM_CAST
            and random.random() <= self.cfg.SCRIPT.RANDOM_CAST_PROBABILITY
        ):
            logger.info("Casting rod redundantly")
            pag.click()
            sleep(2)
            self.reset_tackle()

        self.tackle.cast(lock)
        if update:
            self.timer.update_cast_time()

    def retrieve_line(self) -> None:
        """Retrieve the fishing line until it is fully retrieved."""
        if self.detection.is_retrieval_finished():
            return

        first = True
        gr_switched = False
        if self.cfg.ARGS.ELECTRO:
            self.tackle.switch_gear_ratio()  # Use electro mode

        self.cur_coffee = 0

        with self.toggle_clicklock():
            while True:
                try:
                    with (
                        self.error_handler(),
                        self.clicklock_disable_handler(),
                    ):
                        self.tackle.retrieve(first)
                    break
                except TimeoutError:
                    if not self.clicklock_enabled:
                        self.enable_clicklock()
                    first = False
                    if self.cfg.ARGS.GEAR_RATIO and not gr_switched:
                        self.tackle.switch_gear_ratio()
                        gr_switched = True
                    pag.keyUp("shift")
                    self._drink_coffee()

            pag.keyUp("shift")
            if gr_switched:
                self.tackle.switch_gear_ratio()

    def do_pirking(self) -> None:
        """Perform pirking until a fish is hooked."""
        if self.cfg.SELECTED.PIRK_RETRIEVAL:
            with self.toggle_clicklock():
                self._do_pirking()
        else:
            self._do_pirking()

    def _do_pirking(self) -> None:
        while True:
            try:
                with self.error_handler(), self.clicklock_disable_handler():
                    self.tackle.pirk()
                break
            except TimeoutError:
                if self.cfg.SELECTED.PIRK_RETRIEVAL:
                    if not self.clicklock_enabled:
                        self.enable_clicklock()
                    continue

                if self.cfg.SELECTED.DEPTH_ADJUST_DELAY > 0:
                    logger.info("Adjusting lure depth")
                    pag.press("enter")  # Open reel
                    sleep(self.cfg.SELECTED.DEPTH_ADJUST_DELAY)
                    utils.hold_mouse_button(self.cfg.SELECTED.DEPTH_ADJUST_DURATION)
                else:
                    self.reset_tackle()
                    self._cast_tackle()
                    self.tackle.sink()

    def do_elevating(self) -> None:
        """Perform elevating until a fish is hooked."""
        dropped = False
        while True:
            try:
                dropped = not dropped
                with self.error_handler():
                    self.tackle.elevate(dropped)
                break
            except TimeoutError:
                pass

    def pull_fish(self) -> None:
        """Pull the fish up and handle it."""
        if not self.detection.is_fish_hooked():
            return

        self._drink_alcohol()
        with self.toggle_clicklock():
            while True:
                try:
                    with self.error_handler(), self.clicklock_disable_handler():
                        self.tackle.pull()
                    self.handle_fish()
                    break
                except TimeoutError:
                    if not self.clicklock_enabled:
                        self.enable_clicklock()

                    if self.cfg.SELECTED.MODE == "float":
                        sleep(PUT_DOWN_DELAY)
                        continue
                    self.retrieve_line()

    def _put_down_tackle(self, check_miss_counts: list[int]) -> None:
        """Put down the tackle and wait for a while.

        :param check_miss_counts: List of miss counts for all rods.
        :type check_miss_counts: list[int]
        """
        check_miss_counts[self.tackle_idx] += 1
        if check_miss_counts[self.tackle_idx] >= self.cfg.SELECTED.CHECK_MISS_LIMIT:
            check_miss_counts[self.tackle_idx] = 0
            self.reset_tackle()
            self._refill_groundbait()
            self._refill_pva()
            self._cast_tackle(lock=True)

        pag.press("0")
        bound = self.cfg.SELECTED.CHECK_DELAY // 5
        random_offset = random.uniform(-bound, bound)
        sleep(self.cfg.SELECTED.CHECK_DELAY + random_offset)

    def _start_trolling(self) -> None:
        """Start trolling and change moving direction based on the trolling setting."""
        if self.cfg.ARGS.TROLLING is None:
            return
        logger.info("Starting trolling")
        pag.press(TROLLING_KEY)
        if self.cfg.ARGS.TROLLING not in ("left", "right"):  # Forward
            return
        pag.keyDown(LEFT_KEY if self.cfg.ARGS.TROLLING == "left" else RIGHT_KEY)

    def _update_tackle(self) -> None:
        """Update the current tackle (rod) being used."""
        candidates = self._get_available_rods()
        if not candidates:
            self.general_quit("All rods are unavailable")
        if self.cfg.SCRIPT.RANDOM_ROD_SELECTION:
            self.tackle_idx = random.choice(candidates)
        else:
            self.tackle_idx = candidates[0]
        self.tackle = self.tackles[self.tackle_idx]

    def _get_available_rods(self) -> list[int]:
        """
        Get a list of available rods.

        :return: List of indices of available rods.
        :rtype: list[int]
        """
        if self.num_tackle == 1 and self.tackle.available:
            return [self.tackle]

        candidates = list(range(len(self.tackles)))
        # Rotate the candidates for sequential polling
        start = candidates.index(self.tackle_idx)
        candidates = candidates[start:] + candidates[:start]
        candidates = [i for i in candidates if self.tackles[i].available]

        #  Exclude current rod only if there's another available tackle
        if len(candidates) > 1 and self.tackle_idx in candidates:
            candidates.remove(self.tackle_idx)
        return candidates

    def _change_tackle_lure(self) -> None:
        """Change the lure on the current tackle if possible."""
        if not self.cfg.ARGS.LURE or not self.have_new_lure:
            return

        if self.timer.is_lure_changeable():
            logger.info("Changing lure randomly")
            try:
                self.tackle.equip_item("lure")
            except exceptions.ItemNotFoundError:
                logger.error("New lure not found")
                self.have_new_lure = False

    def _refill_pva(self) -> None:
        """Refill the PVA bag if it has been used up."""
        if not self.cfg.ARGS.PVA or not self.have_new_pva:
            return

        if not self.detection.is_pva_chosen():
            try:
                self.tackle.equip_item("pva")
            except exceptions.ItemNotFoundError:
                logger.error("New pva not found")
                self.have_new_pva = False

    def _refill_dry_mix(self) -> None:
        """Refill the dry mix if it has been used up."""
        if not self.cfg.ARGS.DRY_MIX or not self.have_new_dry_mix:
            return
        try:
            self.tackle.equip_item("dry_mix")
        except exceptions.ItemNotFoundError:
            logger.error("New dry mix not found")
            self.tackle.available = False  # Skip following stages
            self.have_new_dry_mix = False

    def _refill_groundbait(self) -> None:
        """Refill the groundbait if it has been used up."""
        if not self.cfg.ARGS.GROUNDBAIT or not self.have_new_groundbait:
            return

        if self.detection.is_groundbait_chosen():
            logger.info("Groundbait is not used up yet")
        else:
            try:
                self.tackle.equip_item("groundbait")
            except exceptions.ItemNotFoundError:
                logger.error("New groundbait not found")
                self.have_new_groundbait = False

    def test(self):
        """Boo!"""
        self.retrieve_line()

    # TBD: Menu, Plotter, Result, Handler
    def _get_controllers(self, telescopic: bool) -> tuple[callable, callable]:
        """Get the monitor and hold_mouse_button functions based on the fishing mode.

        :param telescopic: Whether the fishing mode is telescopic.
        :type telescopic: bool
        :return: Tuple containing the monitor and hold_mouse_button functions.
        :rtype: tuple[callable, callable]
        """
        if telescopic:
            hold_mouse_button = utils.hold_mouse_button
            monitor = self.tackle._monitor_float_state
        else:
            if self.detection.is_clip_open():
                logger.warning("Clip is not set, fall back to camera mode")
                monitor = self.tackle._monitor_float_state
            else:
                monitor = self.tackle._monitor_clip_state
            hold_mouse_button = utils.hold_mouse_buttons

        return monitor, hold_mouse_button

    def _pause_script(self) -> None:
        """Pause the script for a specified duration."""
        logger.info("Pausing script")
        pag.press("esc")
        bound = self.cfg.PAUSE.DURATION // 5
        offset = random.randint(-bound, bound)
        sleep(self.cfg.PAUSE.DURATION + offset)
        pag.press("esc")

    def _handle_timeout(self) -> None:
        """Handle common timeout events."""
        if self.detection.is_tackle_broken():
            self.general_quit("Tackle is broken")

        if self.detection.is_disconnected():
            self.disconnected_quit()

        if self.detection.is_ticket_expired():
            self._handle_expired_ticket()

    def _handle_broken_lure(self) -> None:
        """Handle the broken lure event according to the settings."""
        match self.cfg.ARGS.BROKEN_LURE:
            case "replace":
                self._replace_broken_lures()
            case "alarm":
                playsound(str(Path(self.cfg.SCRIPT.ALARM_SOUND).resolve()))
                self.window.activate_script_window()
                print("Please replace your lure")
                input("Press enter to continue...")
                self.window.activate_game_window()
            case _:
                self.general_quit("Lure is broken")

    @utils.release_keys_after(arrow_keys=True)
    def _handle_termination(self, msg: str, shutdown: bool) -> None:
        """Handle script termination.

        :param msg: The reason for termination.
        :type msg: str
        :param shutdown: Whether to shutdown the computer after termination.
        :type shutdown: bool
        """
        result = self.build_result_dict(msg)
        table = self.build_result_table(result)
        if self.cfg.ARGS.DISCORD:
            # TODO: dynamic color
            DiscordNotification(self.cfg, result).send(DiscordColor.BLURPLE)
        if self.cfg.ARGS.EMAIL:
            EmailNotification(self.cfg, result).send()
        if self.cfg.ARGS.MIAOTIXING:
            MiaotixingNotification(self.cfg, result).send()
        if self.cfg.ARGS.PLOT and self.result.kept != 0:
            self.timer.plot_and_save()
        if shutdown and self.cfg.ARGS.SHUTDOWN:
            os.system("shutdown /s /t 5")
        print(table)
        sys.exit()

    def _handle_snagged_line(self) -> None:
        """Handle a snagged line event."""
        if len(self.tackles) == 1:
            self.general_quit("Line is snagged")
        self.tackle.available = False

    def handle_fish(self) -> None:
        if not self.detection.is_fish_captured():
            return
        logger.info("Handling fish")
        self._handle_fish()
        sleep(ANIMATION_DELAY)
        if self.detection.is_gift_receieved():
            sleep(self.cfg.KEEPNET.GIFT_DELAY)
            pag.press("space")
            return

    def _handle_fish(self) -> None:
        """Keep or release the fish and record the fish count."""
        tagged = False
        for tag in self.cfg.SCRIPT.SCREENSHOT_TAGS:
            if self.detection.is_tag_exist(TagColor[tag.upper()]):
                tagged = True
        tagged = not self.cfg.SCRIPT.SCREENSHOT_TAGS or tagged
        if self.cfg.ARGS.SCREENSHOT and tagged:
            self.window.save_screenshot(self.timer.get_cur_timestamp())

        self.result.total += 1
        if self.detection.is_fish_blacklisted():
            pag.press("backspace")
            return

        tagged = False
        for tag in TagColor:
            if self.detection.is_tag_exist(tag):
                tag_color = tag.name.lower()
                setattr(self.result, tag_color, getattr(self.result, tag_color) + 1)
                if tag_color in self.cfg.KEEPNET.TAGS:
                    tagged = True

        if (
            self.cfg.ARGS.TAG
            and not tagged
            and not self.detection.is_fish_whitelisted()
        ):
            pag.press("backspace")
            return

        # Fish is tagged, ARGS.TAG is disabled, or fish is in whitelist
        sleep(self.cfg.KEEPNET.FISH_DELAY)
        pag.press("space")

        self.result.kept += 1
        limit = self.cfg.KEEPNET.CAPACITY - self.cfg.ARGS.FISHES_IN_KEEPNET
        if self.result.kept == limit:
            self._handle_full_keepnet()

        # Avoid wrong cast hour
        if self.cfg.SELECTED.MODE in ["bottom", "pirk", "elevator"]:
            self.timer.update_cast_time()
        self.timer.add_cast_time()

    def _handle_full_keepnet(self) -> None:
        """Handle a full keepnet event."""
        match self.cfg.KEEPNET.FULL_ACTION:
            case "alarm":
                playsound(str(Path(self.cfg.SCRIPT.ALARM_SOUND).resolve()))
                self.window.activate_script_window()
                print(input("Press enter to continue..."))
                self.window.activate_game_window()
                with keyboard.Listener(on_release=self._on_release) as listner:
                    listner.join()
                logger.info("Continue running script")
            case "quit":
                self.general_quit("Keepnet is full")
            case _:
                raise ValueError

    def _on_release(self, _: keyboard.KeyCode) -> None:
        """Handle key release events."""
        sys.exit()

    def general_quit(self, msg: str) -> None:
        """Quit the game through the control panel.

        :param msg: reason for termination
        :type msg: str
        """
        logger.critical(msg)
        sleep(ANIMATION_DELAY)
        pag.press("esc")
        sleep(ANIMATION_DELAY)

        if self.cfg.ARGS.SIGNOUT:
            pag.keyDown("shift")
        pag.moveTo(self.detection.get_quit_position())
        pag.click()
        pag.keyUp("shift")
        sleep(ANIMATION_DELAY)
        pag.moveTo(self.detection.get_yes_position())
        pag.click()

        self._handle_termination(msg, shutdown=True)

    def disconnected_quit(self) -> None:
        """Quit the game through the main menu."""
        pag.press("space")
        # Sleep to bypass the black screen (experimental)
        sleep(DISCONNECTED_DELAY)
        pag.press("space")
        sleep(ANIMATION_DELAY)
        if not self.cfg.ARGS.SIGNOUT:
            pag.moveTo(self.detection.get_exit_icon_position())
            pag.click()
            sleep(ANIMATION_DELAY)
            pag.moveTo(self.detection.get_confirm_button_position())
            pag.click()

        self._handle_termination("Game disconnected", shutdown=True)

    def build_result_dict(self, msg: str):
        return self.result.as_dict(msg, self.timer)

    def build_result_table(self, result) -> Table:
        """Create a Rich table from running result.

        :return: formatted running result table
        :rtype: Table
        """
        table = Table(
            "Field", "Value", title="Running Result", box=box.DOUBLE, show_header=False
        )

        for k, v in result.items():
            table.add_row(k, str(v))
        return table

    def _handle_expired_ticket(self) -> None:
        """Handle an expired boat ticket event."""
        if self.cfg.ARGS.BOAT_TICKET is None:
            pag.press("esc")
            sleep(TICKET_EXPIRE_DELAY)
            self.general_quit("Boat ticket expired")

        logger.info("Renewing boat ticket")
        ticket_loc = self.detection.get_ticket_position(self.cfg.ARGS.BOAT_TICKET)
        if ticket_loc is None:
            pag.press("esc")  # Close ticket menu
            sleep(ANIMATION_DELAY)
            self.general_quit("New boat ticket not found")
        pag.moveTo(ticket_loc)
        pag.click(clicks=2, interval=0.1)  # pag.doubleClick() not implemented
        sleep(ANIMATION_DELAY)

    @utils.press_before_and_after("v")
    def _replace_broken_lures(self) -> None:
        """Replace multiple broken lures."""
        logger.info("Replacing broken lures")

        scrollbar_position = self.detection.get_scrollbar_position()
        if scrollbar_position is None:
            logger.info("Scroll bar not found, changing lures for normal rig")
            while self._open_broken_lure_menu():
                self._replace_item()
            pag.press("v")
            return

        logger.info("Scroll bar found, changing lures for dropshot rig")
        pag.moveTo(scrollbar_position)
        for _ in range(5):
            sleep(ANIMATION_DELAY)
            pag.drag(xOffset=0, yOffset=125, duration=0.5, button="left")

            replaced = False
            while self._open_broken_lure_menu():
                self._replace_item()
                replaced = True

            if replaced:
                pag.moveTo(self.detection.get_scrollbar_position())

    def _open_broken_lure_menu(self) -> bool:
        """Open the broken lure menu.

        :return: True if the broken lure is found, False otherwise.
        :rtype: bool
        """
        logger.info("Looking for broken lure")
        broken_item_position = self.detection.get_100wear_position()
        if broken_item_position is None:
            logger.warning("Broken lure not found")
            return False

        # click item to open selection menu
        pag.moveTo(broken_item_position)
        sleep(ANIMATION_DELAY)
        pag.click()
        sleep(ANIMATION_DELAY)
        return True

    def _replace_item(self) -> None:
        """Replace a broken item with a favorite item."""
        logger.info("Looking for favorite items")
        favorite_item_positions = self.detection.get_favorite_item_positions()
        while True:
            favorite_item_position = next(favorite_item_positions, None)
            if favorite_item_position is None:
                pag.press("esc")
                sleep(ANIMATION_DELAY)
                pag.press("esc")
                sleep(ANIMATION_DELAY)
                self.general_quit("Favorite item not found")

            # Check if the lure for replacement is already broken
            x, y = utils.get_box_center(favorite_item_position)
            if pag.pixel(x - 60, y + 190) != (178, 59, 30):  # Magic value #TODO
                logger.info("Lure replaced successfully")
                pag.moveTo(x - 60, y + 190)
                pag.click(clicks=2, interval=0.1)
                sleep(WEAR_TEXT_UPDATE_DELAY)
                break

    📁 result/
            📄 result.py  [Текстовый файл]:
from dataclasses import dataclass

from rf4s.controller.timer import Timer


@dataclass
class Result:
    """Dummy result."""

    def as_dict(self) -> dict:
        return {}


@dataclass
class RF4SResult:
    tea: int = 0
    carrot: int = 0
    alcohol: int = 0
    coffee: int = 0
    bait: int = 0
    kept: int = 0
    total: int = 0
    green: int = 0
    yellow: int = 0
    blue: int = 0
    purple: int = 0
    pink: int = 0

    def as_dict(self, msg: str, timer: Timer) -> dict:
        # Will be 0 if total_fish_count = 0
        kept_ratio = f"{int(self.kept / max(1, self.total) * 100)}%"
        bite_rate = f"{int((self.total / (timer.get_running_time() / 3600)))}/hr"

        return {
            "Stop reason": msg,
            "Start time": timer.get_start_datetime(),
            "End time": timer.get_cur_datetime(),
            "Running time": timer.get_running_time_str(),
            "Bite rate": bite_rate,
            "Total fish": self.total,
            "Kept fish": self.kept,
            "Kept ratio": kept_ratio,
            "Green tag fish": self.green,
            "Yellow tag fish": self.yellow,
            "Blue tag fish": self.blue,
            "Purple tag fish": self.purple,
            "Pink tag fish": self.pink,
            "Tea consumed": self.tea,
            "Carrot consumed": self.carrot,
            "Alcohol consumed": self.alcohol,
            "Coffee consumed": self.coffee,
            "Bait harvested": self.bait,
        }


@dataclass
class CraftResult:
    succes: int = 0
    fail: int = 0
    material: int = 0

    def as_dict(self) -> dict:
        return {
            "Successful crafts": self.succes,
            "Failed crafts": self.fail,
            "Materials used": self.material,
        }


@dataclass
class HarvestResult:
    tea: int = 0
    carrot: int = 0
    bait: int = 0

    def as_dict(self) -> dict:
        return {
            "Tea consumed": self.tea,
            "Carrot consumed": self.carrot,
            "Bait harvested": self.bait,
        }

        📄 utils.py  [Текстовый файл]:
"""Helper functions for automation scripts.

This module provides utility functions for common tasks such as mouse control,
keyboard input, and result display. It also includes decorators for managing
key and mouse states during automation.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import logging
import sys
from time import sleep

import pyautogui as pag
from pyscreeze import Box
from rich.console import Console
from rich.logging import RichHandler
from rich.text import Text

# BASE_DELAY + LOOP_DELAY >= 2.2 to trigger clicklock
BASE_DELAY = 1.2
LOOP_DELAY = 1

ANIMATION_DELAY = 1

logger = logging.getLogger("rich")

# ---------------------------------------------------------------------------- #
#                            common functionalities                            #
# ---------------------------------------------------------------------------- #


def hold_mouse_button(duration: float = 1, button: str = "left") -> None:
    """Hold left or right mouse button.

    :param duration: Hold time, defaults to 1.
    :type duration: float, optional
    :param button: Button to click, defaults to "left".
    :type button: str, optional
    """
    if duration == 0:
        return

    pag.mouseDown(button=button)
    sleep(duration)
    pag.mouseUp(button=button)
    if button == "left" and duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
        pag.click()


def hold_mouse_buttons(duration: float = 1) -> None:
    """Hold left and right mouse buttons simultaneously.

    :param duration: Hold time, defaults to 1.
    :type duration: float, optional
    """
    pag.mouseDown()
    pag.mouseDown(button="right")
    sleep(duration)
    pag.mouseUp()
    pag.mouseUp(button="right")
    if duration >= 2.1:  # + 0.1 due to pag.mouseDown() delay
        pag.click()


def sleep_and_decrease(num: int, delay: int) -> int:
    """Self-decrement with a delay.

    :param num: The variable to decrease.
    :type num: int
    :param delay: Sleep time.
    :type delay: int
    :return: Decreased num.
    :rtype: int
    """
    sleep(delay)
    return num - delay


def ask_for_confirmation(msg: str = "Ready to start") -> None:
    """Ask for confirmation of user settings if it's enabled.

    :param msg: Confirmation message, defaults to "Ready to start".
    :type msg: str
    """
    while True:
        ans = input(f"{msg}? [Y/n] ").strip().lower()
        if ans in ("y", ""):
            break
        if ans == "n":
            sys.exit()


def get_box_center(box: Box) -> tuple[int, int]:
    """Get the center coordinate (x, y) of the given box.

    # (x, y, w, h) -> (x, y), np.int64 -> int

    :param box: Box coordinates (x, y, w, h).
    :type box: Box
    :return: x and y coordinates of the center point.
    :rtype: tuple[int, int]
    """
    return int(box.left + box.width // 2), int(box.top + box.height // 2)


def create_rich_logger() -> RichHandler:
    """Create a default RichHandler for logging.

    :return: Logging handler from rich.
    :rtype: RichHandler
    """
    # Ignore %(name)s because it's too verbose
    # https://rich.readthedocs.io/en/latest/logging.html
    logging.basicConfig(
        level=logging.INFO,
        format="%(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        handlers=[RichHandler(rich_tracebacks=True)],
    )
    return logging.getLogger("rich")


# ---------------------------------------------------------------------------- #
#                                  decorators                                  #
# ---------------------------------------------------------------------------- #


# def toggle_clicklock(func):
#     """Toggle clicklock before and after calling the function."""

#     def wrapper(self, *args, **kwargs):
#         # ELECTRO must be enabled, always use electric mode if GEAR_RATIO is disabled
#         # otherwise, only use electric mode when it's the first time
#         if self.cfg.ARGS.ELECTRO and (
#             not self.cfg.ARGS.GEAR_RATIO or (not args or args[0])
#         ):
#             pag.click(clicks=2, interval=0.1)
#         else:
#             pag.mouseDown()
#         sleep(BASE_DELAY + LOOP_DELAY)
#         try:
#             func(self, *args, **kwargs)
#         finally:
#             if self.cfg.ARGS.ELECTRO:
#                 pag.click(clicks=2, interval=0.1)
#             else:
#                 pag.click()

#     return wrapper


def toggle_right_mouse_button(func):
    """Toggle right mouse button before and after calling the function."""

    def wrapper(*args, **kwargs):
        pag.mouseDown(button="right")
        try:
            func(*args, **kwargs)
        finally:
            pag.mouseUp(button="right")

    return wrapper


def press_before_and_after(key):
    def func_wrapper(func):
        def args_wrapper(*args, **kwargs):
            pag.press(key)
            sleep(ANIMATION_DELAY)
            try:
                func(*args, **kwargs)
            finally:
                pag.press(key)
                sleep(ANIMATION_DELAY)

        return args_wrapper

    return func_wrapper


def release_keys_after(arrow_keys: bool = False):
    """Release keys that might have been holding down

    :param arrow_keys: whether to toggle arrow keys, defaults to False
    :type arrow_keys: bool, optional
    """

    def release_keys(arrow_keys):
        pag.keyUp("ctrl")
        pag.keyUp("shift")
        if arrow_keys:
            pag.keyUp("w")
            pag.keyUp("a")
            pag.keyUp("d")

    def func_wrapper(func):  # Capture arrow_keys as default arg
        def args_wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            finally:
                release_keys(arrow_keys)  # Uses the captured value

        return args_wrapper

    return func_wrapper


def print_error(msg):
    text = Text(msg)
    text.stylize("red")
    Console().print(text)


# There's lots of early return in player._resetting_stage(),
# so use a decorator here to simplify the code
def reset_friction_brake_after(func):
    """Reset friction brake after calling the function."""

    def wrapper(self, *args, **kwargs):
        func(self, *args, **kwargs)
        if not self.cfg.ARGS.FRICTION_BRAKE:
            return

        with self.friction_brake_lock:
            self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)

    return wrapper

        📄 __init__.py  [Текстовый файл]:

    📄 setup.bat  [Текстовый файл]:
@echo off

echo This might take a while...

@REM for playsound module: https://github.com/TaylorSMarks/playsound/issues/145
python -m pip install wheel setuptools pip --upgrade
python -m pip install -r requirements.txt

if not exist ".\screenshots" mkdir screenshots
if not exist ".\logs" mkdir logs
if not exist ".\config.yaml" copy ".\rf4s\config\config.yaml" ".\config.yaml"
    📄 show_folders_Version3.py  [Текстовый файл]:
import os
import mimetypes

def is_text_file(filepath):
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            f.read(1024)
        return True
    except Exception:
        return False

def describe_file(filepath):
    mime_type, _ = mimetypes.guess_type(filepath)
    if mime_type:
        if mime_type.startswith('image/'):
            return '[Фото]'
        elif mime_type.startswith('video/'):
            return '[Видео]'
        elif mime_type.startswith('audio/'):
            return '[Музыка]'
        elif mime_type.startswith('text/'):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                return f'[Текстовый файл]:\n{content}'
            except Exception:
                return '[Текстовый файл, не удалось прочитать]'
    if is_text_file(filepath):
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            return f'[Текстовый файл]:\n{content}'
        except Exception:
            return '[Текстовый файл, не удалось прочитать]'
    return '[Неизвестный или бинарный файл]'

def show_tree(path, indent="", result=None):
    if result is None:
        result = []
    try:
        items = os.listdir(path)
    except Exception as e:
        result.append(f"{indent}Ошибка доступа к папке: {e}")
        return result
    for item in items:
        item_path = os.path.join(path, item)
        if os.path.isdir(item_path):
            result.append(f"{indent}📁 {item}/")
            show_tree(item_path, indent + "    ", result)
        else:
            desc = describe_file(item_path)
            result.append(f"{indent}    📄 {item}  {desc}")
    return result

if __name__ == "__main__":
    root_dir = os.getcwd()
    output_file = os.path.join(root_dir, "структура_папки.txt")
    print(f"Сканируется текущая папка: {root_dir}")
    tree_info = show_tree(root_dir)
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("Структура папки:\n")
        f.write("\n".join(tree_info))
    print(f"Информация о структуре сохранена в файл: {output_file}")
📁 static/
    📁 en/
            📄 0m.png  [Фото]
            📄 100wear.png  [Фото]
            📄 5m.png  [Фото]
            📄 bait_icon.png  [Фото]
            📄 blue_tag.png  [Фото]
            📄 broke.png  [Фото]
            📄 carrot.png  [Фото]
            📄 classic_feed_mix.png  [Фото]
            📄 coffee.png  [Фото]
            📄 comfort.png  [Фото]
            📄 confirm.png  [Фото]
            📄 disconnected.png  [Фото]
            📄 dry_feed_mix.png  [Фото]
            📄 energy.png  [Фото]
            📄 exit.png  [Фото]
            📄 favorite.png  [Фото]
            📄 fish_icon.png  [Фото]
            📄 food.png  [Фото]
            📄 gift.png  [Фото]
            📄 green_tag.png  [Фото]
            📄 groundbait_icon.png  [Фото]
            📄 harvest_confirm.png  [Фото]
            📄 herring.png  [Фото]
            📄 keep.png  [Фото]
            📄 lure_is_broken.png  [Фото]
            📄 mackerel.png  [Фото]
            📄 make.png  [Фото]
            📄 material_slot.png  [Фото]
            📄 movement.png  [Фото]
            📄 mussel.png  [Фото]
            📄 ok.png  [Фото]
            📄 ok_black.png  [Фото]
            📄 ok_white.png  [Фото]
            📄 perch.png  [Фото]
            📄 pink_tag.png  [Фото]
            📄 purple_tag.png  [Фото]
            📄 pva_icon.png  [Фото]
            📄 pva_stick_or_pva_stringer.png  [Фото]
            📄 quit.png  [Фото]
            📄 ready.png  [Фото]
            📄 saithe.png  [Фото]
            📄 scallop.png  [Фото]
            📄 scrollbar.png  [Фото]
            📄 shorthorn_sculpin.png  [Фото]
            📄 squid.png  [Фото]
            📄 tea.png  [Фото]
            📄 ticket.png  [Фото]
            📄 ticket_1.png  [Фото]
            📄 ticket_2.png  [Фото]
            📄 ticket_3.png  [Фото]
            📄 ticket_5.png  [Фото]
            📄 warning.png  [Фото]
            📄 welcome.png  [Фото]
            📄 wheel.png  [Фото]
            📄 yellow_tag.png  [Фото]
            📄 yes.png  [Фото]
    📁 readme/
            📄 clicklock.png  [Фото]
            📄 favorite_food.png  [Фото]
            📄 favorite_lure.png  [Фото]
            📄 icon.png  [Фото]
            📄 mtx1.png  [Фото]
            📄 mtx2.png  [Фото]
            📄 mtx3.png  [Фото]
            📄 path.png  [Фото]
            📄 RF4S.png  [Фото]
            📄 RF4S_original.png  [Фото]
            📄 status.png  [Фото]
    📁 ru/
            📄 0m.png  [Фото]
            📄 100wear.png  [Фото]
            📄 5m.png  [Фото]
            📄 bait_icon.png  [Фото]
            📄 blue_tag.png  [Фото]
            📄 broke.png  [Фото]
            📄 carrot.png  [Фото]
            📄 classic_feed_mix.png  [Фото]
            📄 coffee.png  [Фото]
            📄 comfort.png  [Фото]
            📄 confirm.png  [Фото]
            📄 disconnected.png  [Фото]
            📄 dry_feed_mix.png  [Фото]
            📄 energy.png  [Фото]
            📄 exit.png  [Фото]
            📄 favorite.png  [Фото]
            📄 fish_icon.png  [Фото]
            📄 food.png  [Фото]
            📄 gift.png  [Фото]
            📄 green_tag.png  [Фото]
            📄 groundbait_icon.png  [Фото]
            📄 harvest_confirm.png  [Фото]
            📄 herring.png  [Фото]
            📄 keep.png  [Фото]
            📄 lure_is_broken.png  [Фото]
            📄 mackerel.png  [Фото]
            📄 make.png  [Фото]
            📄 material_slot.png  [Фото]
            📄 movement.png  [Фото]
            📄 mussel.png  [Фото]
            📄 ok.png  [Фото]
            📄 ok_black.png  [Фото]
            📄 ok_white.png  [Фото]
            📄 perch.png  [Фото]
            📄 pink_tag.png  [Фото]
            📄 purple_tag.png  [Фото]
            📄 pva_icon.png  [Фото]
            📄 pva_stick_or_pva_stringer.png  [Фото]
            📄 quit.png  [Фото]
            📄 ready.png  [Фото]
            📄 saithe.png  [Фото]
            📄 scallop.png  [Фото]
            📄 scrollbar.png  [Фото]
            📄 shorthorn_sculpin.png  [Фото]
            📄 squid.png  [Фото]
            📄 tea.png  [Фото]
            📄 ticket.png  [Фото]
            📄 ticket_1.png  [Фото]
            📄 ticket_2.png  [Фото]
            📄 ticket_3.png  [Фото]
            📄 ticket_5.png  [Фото]
            📄 warning.png  [Фото]
            📄 welcome.png  [Фото]
            📄 wheel.png  [Фото]
            📄 yellow_tag.png  [Фото]
            📄 yes.png  [Фото]
    📁 sound/
            📄 app_1.wav  [Музыка]
            📄 app_2.wav  [Музыка]
            📄 app_3.wav  [Музыка]
            📄 bell_1.wav  [Музыка]
            📄 bell_2.wav  [Музыка]
            📄 bell_3.wav  [Музыка]
            📄 digital.wav  [Музыка]
            📄 door_bell.wav  [Музыка]
            📄 elevator.wav  [Музыка]
            📄 fast_alarm.wav  [Музыка]
            📄 flute_1.wav  [Музыка]
            📄 flute_2.wav  [Музыка]
            📄 guitar.wav  [Музыка]
            📄 marimba.wav  [Музыка]
            📄 ripple.wav  [Музыка]
    📁 zh-CN/
            📄 0m.png  [Фото]
            📄 100wear.png  [Фото]
            📄 5m.png  [Фото]
            📄 bait_icon.png  [Фото]
            📄 blue_tag.png  [Фото]
            📄 broke.png  [Фото]
            📄 carrot.png  [Фото]
            📄 coffee.png  [Фото]
            📄 comfort.png  [Фото]
            📄 confirm.png  [Фото]
            📄 disconnected.png  [Фото]
            📄 energy.png  [Фото]
            📄 exit.png  [Фото]
            📄 favorite.png  [Фото]
            📄 fish_icon.png  [Фото]
            📄 food.png  [Фото]
            📄 gift.png  [Фото]
            📄 green_tag.png  [Фото]
            📄 groundbait_icon.png  [Фото]
            📄 harvest_confirm.png  [Фото]
            📄 keep.png  [Фото]
            📄 lure_is_broken.png  [Фото]
            📄 make.png  [Фото]
            📄 material_slot.png  [Фото]
            📄 movement.png  [Фото]
            📄 ok.png  [Фото]
            📄 pink_tag.png  [Фото]
            📄 purple_tag.png  [Фото]
            📄 pva_icon.png  [Фото]
            📄 quit.png  [Фото]
            📄 ready.png  [Фото]
            📄 scrollbar.png  [Фото]
            📄 tea.png  [Фото]
            📄 ticket.png  [Фото]
            📄 ticket_1.png  [Фото]
            📄 ticket_2.png  [Фото]
            📄 ticket_3.png  [Фото]
            📄 ticket_5.png  [Фото]
            📄 warning.png  [Фото]
            📄 welcome.png  [Фото]
            📄 wheel.png  [Фото]
            📄 yellow_tag.png  [Фото]
            📄 yes.png  [Фото]
    📁 zh-TW/
            📄 0m.png  [Фото]
            📄 100wear.png  [Фото]
            📄 5m.png  [Фото]
            📄 bait_icon.png  [Фото]
            📄 blue_tag.png  [Фото]
            📄 broke.png  [Фото]
            📄 carrot.png  [Фото]
            📄 coffee.png  [Фото]
            📄 comfort.png  [Фото]
            📄 confirm.png  [Фото]
            📄 disconnected.png  [Фото]
            📄 energy.png  [Фото]
            📄 exit.png  [Фото]
            📄 favorite.png  [Фото]
            📄 fish_icon.png  [Фото]
            📄 food.png  [Фото]
            📄 gift.png  [Фото]
            📄 green_tag.png  [Фото]
            📄 groundbait_icon.png  [Фото]
            📄 harvest_confirm.png  [Фото]
            📄 herring.png  [Фото]
            📄 keep.png  [Фото]
            📄 lure_is_broken.png  [Фото]
            📄 mackerel.png  [Фото]
            📄 make.png  [Фото]
            📄 material_slot.png  [Фото]
            📄 movement.png  [Фото]
            📄 mussel.png  [Фото]
            📄 ok.png  [Фото]
            📄 pink_tag.png  [Фото]
            📄 purple_tag.png  [Фото]
            📄 pva_icon.png  [Фото]
            📄 quit.png  [Фото]
            📄 ready.png  [Фото]
            📄 saithe.png  [Фото]
            📄 scallop.png  [Фото]
            📄 scrollbar.png  [Фото]
            📄 squid.png  [Фото]
            📄 tea.png  [Фото]
            📄 ticket.png  [Фото]
            📄 ticket_1.png  [Фото]
            📄 ticket_2.png  [Фото]
            📄 ticket_3.png  [Фото]
            📄 ticket_5.png  [Фото]
            📄 warning.png  [Фото]
            📄 welcome.png  [Фото]
            📄 wheel.png  [Фото]
            📄 yellow_tag.png  [Фото]
            📄 yes.png  [Фото]
📁 tools/
        📄 auto_friction_brake.py  [Текстовый файл]:
"""Automate friction brake adjustments in Russian Fishing 4.

This module provides functionality to automatically adjust the friction brake
based on in-game conditions. It supports key bindings for exiting the script
and resetting the friction brake.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import sys
from multiprocessing import Lock

from pynput import keyboard
from rich import print

sys.path.append(".")
from rf4s.app.app import ToolApp
from rf4s.component.friction_brake import FrictionBrake
from rf4s.config.config import print_cfg
from rf4s.utils import create_rich_logger

logger = create_rich_logger()


class FrictionBrakeApp(ToolApp):
    """Main application class for automating friction brake adjustments.

    This class manages the configuration, detection, and execution of the friction
    brake automation process. It also handles key bindings for exiting and resetting.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        friction_brake (FrictionBrake): Friction brake controller instance.
    """

    def __init__(self):
        """Initialize the application.

        1. Check the game window state.
        2. Format keybinds in cfg node.
        3. Display cfg node.
        4. Initialize a friction brake instance.
        """
        super().__init__()
        if not self.is_game_window_valid():
            sys.exit(1)

        # Format keys
        self.cfg.defrost()
        self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
        self.cfg.ARGS.RESET_KEY = f"'{self.cfg.ARGS.RESET_KEY}'"
        self.cfg.freeze()
        print_cfg(self.cfg.ARGS)
        print_cfg(self.cfg.FRICTION_BRAKE)

        self.friction_brake = FrictionBrake(self.cfg, Lock(), self.detection)

    def is_game_window_valid(self) -> bool:
        """Check if the game window mode and size are valid.

        :return: True if valid, False otherwise
        :rtype: bool
        """
        if self.window.is_title_bar_exist():
            logger.info("Window mode detected. Please don't move the game window")
        if not self.window.is_size_supported():
            logger.critical(
                'Window mode must be "Borderless windowed" or "Window mode"'
            )
            logger.critical(
                "Unsupported window size '%s', "
                "use '2560x1440', '1920x1080' or '1600x900'",
                self.window.get_resolution_str(),
            )
            return False
        return True

    def create_parser(self) -> argparse.ArgumentParser:
        """Create an argument parser for the application.

        :return: Configured argument parser.
        :rtype: argparse.ArgumentParser
        """
        parser = argparse.ArgumentParser(description="Automate friction brake.")
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-r",
            "--reset-key",
            default="g",
            type=str,
            help="key to reset friction brake, g by default",
            metavar="KEY",
        )
        parser.add_argument(
            "-q",
            "--quit-key",
            default="h",
            type=str,
            help="key to quit the script, h by default",
            metavar="KEY",
        )
        return parser

    def _on_release(self, key: keyboard.KeyCode) -> None:
        """Handle exit and quit events.

        :param key: The key that was released.
        :type key: keyboard.KeyCode
        """
        keystroke = str(key).lower()
        if keystroke == self.cfg.ARGS.QUIT_KEY:
            self.friction_brake.monitor_process.terminate()
            sys.exit()
        if keystroke == self.cfg.ARGS.RESET_KEY:
            self.friction_brake.reset(self.cfg.FRICTION_BRAKE.INITIAL)

    def _start(self):
        """Start the friction brake automation process.

        Begins the friction brake monitoring process and starts a keyboard listener
        to handle control keys.
        """
        print(
            f"Press {self.cfg.ARGS.RESET_KEY[1:-1]} to reset friction brake, "
            f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
        )
        self.friction_brake.monitor_process.start()
        with keyboard.Listener(on_release=self._on_release) as listener:
            listener.join()


if __name__ == "__main__":
    FrictionBrakeApp().start()

        📄 calculate.py  [Текстовый файл]:
"""Calculate the maximum friction brake you can use on your tackle.

This module provides functionality to calculate the maximum friction brake and tension
based on the reel's max drag, friction brake wear, leader's load capacity, and wear.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import sys

from rich import print
from rich.prompt import Prompt
from rich.table import Table

sys.path.append(".")
from rf4s import utils

BIAS = 1e-6


def get_tackle_stats():
    """Get actual stats of reel and leader based on their wears.

    Prompts the user for input and calculates the true max drag and load capacity
    after accounting for wear.

    :return: A tuple containing the true max drag and true load capacity.
    :rtype: tuple[float, float]
    """
    prompts = (
        "Reel's max drag (kg)",
        "Reel's friction brake wear (%)",
        "Leader's load capacity (kg)",
        "Leader's wear (%)",
    )

    while True:
        restart = False
        stats = []
        for prompt in prompts:
            validated_input = get_validated_input(prompt)
            if validated_input is None:
                restart = True
                break
            stats.append(validated_input)

        if restart:
            continue

        max_drag, friction_brake_wear, leader_load_capacity, leader_wear = stats
        true_max_drag = max_drag * (100 - friction_brake_wear) / 100
        true_load_capacity = leader_load_capacity * (100 - leader_wear) / 100
        return true_max_drag, true_load_capacity


def get_validated_input(prompt: str) -> float | None:
    """Get validated input from the user.

    Prompts the user for input and validates it. Supports quitting and restarting.

    :param prompt: The prompt message to display to the user.
    :type prompt: str
    :return: The validated input as a float, or None if the user chooses to restart.
    :rtype: float or None
    """
    while True:
        user_input = Prompt.ask(prompt)
        if user_input == "q":
            print("Bye.")
            sys.exit()
        if user_input == "r":
            return None

        try:
            return float(user_input)
        except ValueError:
            utils.print_error("Invalid input. Please enter a number.")


def main():
    """Main function to run the friction brake calculation.

    Prompts the user for input, calculates the result, and displays them in a table.
    """
    print("Please enter your tackle's stats, type q to quit, r to restart. ")
    while True:
        max_drag, load_capacity = get_tackle_stats()
        max_friction_brake = int(min(load_capacity * 30 / (max_drag + BIAS) - 1, 29))
        max_tension = max_drag * max_friction_brake / 30

        table = Table(
            "Result",
            title="Your tackle's real stats 🎣",
            show_header=False,
            min_width=36,
        )
        table.add_row("Reel's true max drag", f"{max_drag:.2f} kg")
        table.add_row("Leader's true load capacity", f"{load_capacity:.2f} kg")
        table.add_row("Friction brake tension", f"{max_tension:.2f} kg")
        table.add_row("Maximum friction brake to use", f"{max_friction_brake}")
        print(table)


if __name__ == "__main__":
    main()

        📄 craft.py  [Текстовый файл]:
"""Activate game window and start crafting things until running out of materials.

This module automates the crafting process in Russian Fishing 4. It supports
discarding crafted items, fast crafting mode, and a configurable crafting limit.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import random
import sys
from datetime import datetime
from pathlib import Path
from time import sleep

import pyautogui as pag
from pynput import keyboard

sys.path.append(".")
from rf4s.app.app import ToolApp
from rf4s.config.config import print_cfg
from rf4s.result.result import CraftResult
from rf4s.utils import create_rich_logger

CRAFT_DELAY = 4.0
CRAFT_DELAY_2X = CRAFT_DELAY * 2
LOOP_DELAY = 0.5
LOOP_DELAY_2X = LOOP_DELAY * 2
ROOT = Path(__file__).resolve().parents[1]

logger = create_rich_logger()


class CraftApp(ToolApp):
    """Main application class for automating crafting.

    This class manages the configuration, detection, and execution of the crafting
    process. It tracks the number of successful and failed crafts, as well as the
    total number of materials used.
    """

    def __init__(self):
        """Initialize the application."""
        super().__init__()
        print_cfg(self.cfg.ARGS)
        self.result = CraftResult()

    def create_parser(self) -> argparse.ArgumentParser:
        """Create an argument parser for the application.

        :return: Configured argument parser.
        :rtype: argparse.ArgumentParser
        """
        parser = argparse.ArgumentParser(description="Craft items automatically.")
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-d",
            "--discard",
            action="store_true",
            help="discard all the crafted items (for groundbaits)",
        )
        parser.add_argument(
            "-f",
            "--fast",
            action="store_true",
            help="disable delay randomization to speed up crafting",
        )
        parser.add_argument(
            "-n",
            "--craft-limit",
            type=int,
            default=-1,
            help="number of items to craft, no limit by default",
            metavar="LIMIT",
        )
        return parser

    def get_action_delays(self) -> tuple[float, float]:
        """Get crafting and checking delays.

        :return: Two delays in seconds
        :rtype: tuple[float, float]
        """
        if self.cfg.ARGS.FAST:
            return CRAFT_DELAY, LOOP_DELAY
        return (
            random.uniform(CRAFT_DELAY, CRAFT_DELAY_2X),
            random.uniform(LOOP_DELAY, LOOP_DELAY_2X),
        )

    def move_cursor_to_make_button(self) -> None:
        """Move the cursor to the make button position.

        This method uses the Detection class to find the position of the make button
        and moves the cursor to that position.
        """
        make_button_position = self.detection.get_make_button_position()
        if make_button_position is None:
            logger.critical(
                "Make button not found, please set the interface scale to "
                "1x or move your mouse around"
            )
            self.window.activate_script_window()
            sys.exit(1)
        pag.moveTo(make_button_position)

    def craft_item(
        self, craft_delay: float, accept_delay: float, accept_key: str
    ) -> None:
        """Craft an item.

        :param craft_delay: Delay in seconds before accepting the crafted item.
        :type craft_delay: float
        :param accept_delay: Delay in seconds after accepting the crafted item.
        :type accept_delay: float
        :param accept_key: Key to press after accepting the crafted item.
        :type accept_key: str
        """
        logger.info("Crafting item")
        pag.click()
        sleep(craft_delay)
        self.result.material += 1
        while True:
            if self.detection.is_operation_success():
                logger.info("Crafting successed")
                self.result.succes += 1
                break

            if self.detection.is_operation_failed():
                logger.warning("Crafting failed")
                self.result.fail += 1
                break
            sleep(LOOP_DELAY)
        pag.press(accept_key)
        sleep(accept_delay)

    def _start(self) -> None:
        """Main loop for crafting items.

        Executes the primary loop for crafting items until materials are exhausted or
        the crafting limit is reached. Supports fast crafting mode and discarding items.
        """
        if self.cfg.KEY.QUIT != "CTRL-C":
            listener = keyboard.Listener(on_release=self._on_release)
            listener.start()
        print(f"Press {self.cfg.KEY.QUIT} to quit.")
        random.seed(datetime.now().timestamp())
        accept_key = "backspace" if self.cfg.ARGS.DISCARD else "space"
        self.move_cursor_to_make_button()
        while True:
            if not self.detection.is_material_complete():
                logger.critical("Running out of materials")
                return
            if self.result.succes == self.cfg.ARGS.CRAFT_LIMIT:
                logger.info("Crafting limit reached")
                return
            self.craft_item(*self.get_action_delays(), accept_key)


if __name__ == "__main__":
    CraftApp().start()

        📄 harvest.py  [Текстовый файл]:
"""Script for automatic baits harvesting and hunger/comfort refill.

This module provides functionality to automate the harvesting of baits and refilling
of hunger and comfort in Russian Fishing 4. It includes options for power-saving
mode and configurable check delays.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import sys
from pathlib import Path
from time import sleep

import pyautogui as pag
from pynput import keyboard

sys.path.append(".")

from rf4s.app.app import ToolApp
from rf4s.config.config import print_cfg
from rf4s.controller.timer import Timer
from rf4s.result.result import HarvestResult
from rf4s.utils import create_rich_logger

ROOT = Path(__file__).resolve().parents[1]
DIG_DELAY = 5  # 4 + 1 s
CHECK_DELAY = 0.5
ANIMATION_DELAY = 0.5

logger = create_rich_logger()


class HarvestApp(ToolApp):
    """Main application class for automating bait harvesting and hunger/comfort refill.

    This class manages the configuration, detection, and execution of the harvesting
    and refill processes. It also handles power-saving mode and check delays.

    Attributes:
        timer (Timer): Timer instance for managing cooldowns.
    """

    def __init__(self):
        """Initialize the application.

        Loads configuration, parses command-line arguments, and sets up the game window,
        detection, and timer instances.
        """
        super().__init__()
        print_cfg(self.cfg.ARGS)

        self.timer = Timer(self.cfg)
        self.result = HarvestResult()

    def create_parser(self) -> argparse.ArgumentParser:
        """Create an argument parser for the application.

        :return: Configured argument parser.
        :rtype: argparse.ArgumentParser
        """
        parser = argparse.ArgumentParser(
            description="Harvest baits and refill hunger/comfort automatically.",
        )
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-r",
            "--refill",
            action="store_true",
            help="refill hunger and comfort by consuming tea and carrot",
        )
        parser.add_argument(
            "-s",
            "--power-saving",
            action="store_true",
            help="open control panel between checks to reduce power consumption",
        )
        parser.add_argument(
            "-n",
            "--check-delay",
            type=int,
            default=32,
            help="delay time between each checks, 32s by default",
        )
        return parser

    def harvest_baits(self) -> None:
        """Harvest baits using shovel/spoon.

        The digging tool should be pulled out before calling this method. Waits for
        harvest success and presses the spacebar to complete the process.
        """
        logger.info("Harvesting baits")
        pag.click()
        sleep(DIG_DELAY)
        while not self.detection.is_harvest_success():
            sleep(CHECK_DELAY)
        pag.press("space")
        logger.info("Baits harvested succussfully")
        sleep(ANIMATION_DELAY)

    def refill_player_stats(self) -> None:
        """Refill player stats using tea and carrot."""
        if not self.cfg.ARGS.REFILL:
            return

        logger.info("Refilling player stats")
        # Comfort is affected by weather, add a check to avoid over drink
        if self.detection.is_comfort_low() and self.timer.is_tea_drinkable():
            self._use_item("tea")
            self.result.tea += 1

        if self.detection.is_hunger_low():
            self._use_item("carrot")
            self.result.carrot += 1

    def _use_item(self, item: str) -> None:
        """Access an item by name using quick selection shortcut or menu.

        :param item: The name of the item to access.
        :type item: str
        """
        logger.info("Using item: %s", item)
        key = str(self.cfg.KEY[item.upper()])
        if key != "-1":  # Use shortcut
            pag.press(key)
        else:  # Open food menu
            with pag.hold("t"):
                sleep(ANIMATION_DELAY)
                food_position = self.detection.get_food_position(item)
                pag.moveTo(food_position)
                pag.click()
        sleep(ANIMATION_DELAY)

    def _start(self) -> None:
        """Main loop for eating and harvesting.

        Executes the primary loop for checking hunger/comfort levels, consuming food,
        and harvesting baits. Supports power-saving mode and configurable check delays.
        """
        if self.cfg.KEY.QUIT != "CTRL-C":
            listener = keyboard.Listener(on_release=self._on_release)
            listener.start()
        print(f"Press {self.cfg.KEY.QUIT} to quit.")

        pag.press(str(self.cfg.KEY.DIGGING_TOOL))
        sleep(3)
        while True:
            self.refill_player_stats()
            if self.detection.is_energy_high():
                self.harvest_baits()
                self.result.bait += 1
            else:
                logger.info("Energy is not high enough")

            if self.cfg.ARGS.POWER_SAVING:
                pag.press("esc")
                sleep(self.cfg.ARGS.CHECK_DELAY)
                pag.press("esc")
            else:
                sleep(self.cfg.ARGS.CHECK_DELAY)
            sleep(ANIMATION_DELAY)


if __name__ == "__main__":
    HarvestApp().start()

        📄 main.py  [Текстовый файл]:
"""Main CLI for Russian Fishing 4 Script.

This module provides the command-line interface and main execution logic
for automating fishing in Russian Fishing 4. It handles configuration,
argument parsing, window management, and fishing automation.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import shlex
import smtplib
import sys
from argparse import ArgumentParser, Namespace
from pathlib import Path
from socket import gaierror

from pynput import keyboard
from rich import box, print
from rich.panel import Panel
from rich.style import Style
from rich.table import Column, Table
from yacs.config import CfgNode as CN

sys.path.append(".")  # python -m module -> python file
from rf4s import utils
from rf4s.app.app import App
from rf4s.config import config
from rf4s.player import Player
from rf4s.utils import create_rich_logger

logger = create_rich_logger()

ARGUMENTS = (
    ("R", "rainbow", "rainbow line meter for retrieval detection"),
    ("t", "tag", "keep only tagged fishes"),
    ("c", "coffee", "drink coffee if stamina is low during a fish fight"),
    ("a", "alcohol", "drink alcohol before keeping the fish"),
    ("r", "refill", "consume tea and carrot if hunger or comfort is low"),
    ("H", "harvest", "harvest baits before casting the rod"),
    ("L", "lure", "change current lure with a random one, mode: spin"),
    ("m", "mouse", "move mouse randomly before casting the rod"),
    ("P", "pause", "pause the script before casting the rod occasionally"),
    ("RC", "random-cast", "do a redundant rod cast randomly"),
    ("SC", "skip-cast", "skip the first rod cast"),
    ("l", "lift", "lift the tackle constantly during a fish fight"),
    ("e", "electro", "enable electric mode for Electro Raptor series reel"),
    ("FB", "friction-brake", "adjust friction brake automatically"),
    ("GR", "gear-ratio", "switch the gear ratio after the retrieval timed out"),
    ("b", "bite", "save a screenshot in screenshots/ before rod cast (for bite spot)"),
    ("s", "screenshot", "save a screenshot in screenshots/ after you caught a fish"),
    ("d", "data", "save fishing data in /logs"),
    ("E", "email", "send email noticication after the script stop"),
    ("M", "miaotixing", "send miaotixing notification after the script stop"),
    ("D", "discord", "send Discord notification after the script stop"),
    ("S", "shutdown", "shutdown computer after the script stop"),
    ("SO", "signout", "sign out instead of closing the game"),
    ("SR", "spod-rod", "recast spod rod"),
    ("DM", "dry-mix", "enable dry mix refill, mode: bottom"),
    ("GB", "groundbait", "enable groundbait refill, mode: bottom"),
    ("PVA", "pva", "enable pva refill, mode: bottom"),
)

LOGO = """
██████╗ ███████╗██╗  ██╗███████╗
██╔══██╗██╔════╝██║  ██║██╔════╝
██████╔╝█████╗  ███████║███████╗
██╔══██╗██╔══╝  ╚════██║╚════██║
██║  ██║██║          ██║███████║
╚═╝  ╚═╝╚═╝          ╚═╝╚══════╝"""
GITHUB_LINK = "GitHub: https://github.com/dereklee0310/RussianFishing4Script"
DISCORD_LINK = "Discord: https://discord.gg/BZQWQnAMbY"
# https://patorjk.com/software/taag/#p=testall&f=3D-ASCII&t=RF4S%0A, ANSI Shadow

ROOT = Path(__file__).resolve().parents[1]


class RF4SApp(App):
    """Main application class for Russian Fishing 4 automation.

    This class orchestrates the entire automation process, from parsing command-line
    arguments to configuring the environment and executing the fishing routine.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments
        args (Namespace): Parsed command-line arguments
        window (Window): Game window controller instance
        player (Player): Player instance for fishing automation
    """

    def __init__(self):
        """Initialize the application.

        Loads configuration, parses command-line arguments, and sets up the environment.
        """
        super().__init__()
        self.parser = self.create_parser()
        # Parser will use the last occurence if the arguments are duplicated,
        # so put argv at the end to overwrite launch options.
        self.args = self.parser.parse_args(
            shlex.split(self.cfg.SCRIPT.LAUNCH_OPTIONS) + sys.argv[1:]
        )
        if not self.is_args_valid(self.args):
            sys.exit(1)
        self.cfg.merge_from_other_cfg(CN({"ARGS": config.dict_to_cfg(vars(self.args))}))

    def create_parser(self) -> ArgumentParser:
        """Configure the argument parser with all supported command-line options.

        :return: Configured ArgumentParser instance with all options and flags.
        :rtype: ArgumentParser
        """
        parser = ArgumentParser(description="Start AFK script for Russian Fishing 4")
        parser.add_argument("opts", nargs="*", help="overwrite configuration")

        for argument in ARGUMENTS:
            flag1 = f"-{argument[0]}"
            flag2 = f"--{argument[1]}"
            help_message = argument[2]
            parser.add_argument(flag1, flag2, action="store_true", help=help_message)

        profile_selection_strategy = parser.add_mutually_exclusive_group()
        profile_selection_strategy.add_argument(
            "-p",
            "--pid",
            type=int,
            help="id of the profile you want to use",
            metavar="PID",
        )
        profile_selection_strategy.add_argument(
            "-N",
            "--pname",
            type=str,
            help="name of the profile you want to use",
            metavar="PROFILE_NAME",
        )
        parser.add_argument(
            "-n",
            "--fishes-in-keepnet",
            default=0,
            type=int,
            help="number of fishes in your keepnet, 0 by default",
            metavar="FISH_COUNT",
        )
        parser.add_argument(
            "-BT",
            "--boat-ticket",
            nargs="?",
            const=5,
            type=int,
            choices=[1, 2, 3, 5],
            help=("renew boat ticket, DURATION: 1, 2, 3 or 5, 5 by default"),
            metavar="DURATION",
        )
        parser.add_argument(
            "-T",
            "--trolling",
            nargs="?",
            const="forward",
            type=str,
            choices=["forward", "left", "right"],
            help=(
                "enable trolling mode, DIRECTION: 'forward', 'left', or 'right', "
                "'forward' by default"
            ),
            metavar="DIRECTION",
        )
        parser.add_argument(
            "-BL",
            "--broken-lure",
            nargs="?",
            const="replace",
            type=str,
            choices=["replace", "alarm"],
            help=(
                "replace broken lure, ACTION: 'replace' or 'alarm', "
                "'replace' by default"
            ),
            metavar="ACTION",
        )
        return parser

    def is_args_valid(self, args: Namespace) -> bool:
        """Validate provided command-line arguments.

        :param args: Parsed command-line arguments to validate.
        :type args: Namespace
        :return: Whether the arguments are valid.
        :rtype: bool
        """
        if not 0 <= args.fishes_in_keepnet < self.cfg.KEEPNET.CAPACITY:
            logger.critical(
                "Invalid number of fishes in keepnet: '%s'", args.fishes_in_keepnet
            )
            return False

        if args.pid is not None and not self.is_pid_valid(str(args.pid)):
            logger.critical("Invalid profile id: '%s'", args.pid)
            return False

        if args.pname is not None and args.pname not in self.cfg.PROFILE:
            logger.critical("Invalid profile name: '%s'", args.pname)
            return False

        # boat_ticket_duration already checked by choices[...]
        return True

    def is_pid_valid(self, pid: str) -> bool:
        """Check if the profile ID is valid.

        :param pid: Profile ID to validate.
        :type pid: str
        :return: Whether the profile ID is valid.
        :rtype: bool
        """
        return pid.isdigit() and 0 <= int(pid) < len(self.cfg.PROFILE)

    def is_smtp_valid(self) -> bool:
        """Verify SMTP server connection for email notifications.

        Tests the connection to the configured SMTP server using stored
        credentials if email notifications are enabled.

        :return: Whether the SMTP configuration is valid or not needed.
        :rtype: bool
        """
        if not self.cfg.ARGS.EMAIL or not self.cfg.SCRIPT.SMTP_VERIFICATION:
            return True

        logger.info("Verifying SMTP connection")

        email = self.cfg.NOTIFICATION.EMAIL
        password = self.cfg.NOTIFICATION.PASSWORD
        smtp_server_name = self.cfg.NOTIFICATION.SMTP_SERVER

        try:
            with smtplib.SMTP_SSL(smtp_server_name, 465) as smtp_server:
                smtp_server.login(email, password)
        except smtplib.SMTPAuthenticationError:
            logger.critical(
                "Email address or app password not accepted,\n"
                "please check your email address and password.\n"
                "For Gmail users, please refer to\n"
                "https://support.google.com/accounts/answer/185833\n"
            )
            return False
        except (TimeoutError, gaierror):
            logger.critical("Invalid SMTP Server or connection timed out")
            return False
        return True

    def is_discord_webhook_url_valid(self) -> bool:
        if not self.cfg.ARGS.DISCORD:
            return True
        if not self.cfg.NOTIFICATION.DISCORD_WEBHOOK_URL:
            logger.critical(
                "Discord Webhook url is not set, see\n"
                "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks"
            )
            return False
        return True

    def is_images_valid(self) -> bool:
        """Verify that all required image files exist for the selected language.

        Compares files in the reference 'en' directory with those in the current
        language directory and reports any missing files.

        :return: Whether all required image files are present.
        :rtype: bool
        """
        if not self.cfg.SCRIPT.IMAGE_VERIFICATION:
            return True

        logger.info("Verifying image files")
        if self.cfg.SCRIPT.LANGUAGE == "en":
            return True
        logger.warning(
            "Language '%s' is not fully supported, consider using EN version",
            self.cfg.SCRIPT.LANGUAGE,
        )
        image_dir = ROOT / "static" / self.cfg.SCRIPT.LANGUAGE
        try:
            current_images = [f.name for f in image_dir.iterdir() if f.is_file()]
        except FileNotFoundError:
            logger.critical("Invalid language: '%s'", self.cfg.SCRIPT.LANGUAGE)
            return False
        template_dir = ROOT / "static" / "en"
        target_images = [f.name for f in template_dir.iterdir() if f.is_file()]
        missing_images = set(target_images) - set(current_images)
        if len(missing_images) > 0:
            logger.critical("Some images are missing, please add them manually")
            table = Table(
                # "Filename",
                Column("Filename", style=Style(color="red")),
                title="Missing Images",
                box=box.DOUBLE,
                show_header=False,
            )
            for filename in missing_images:
                table.add_row(f"static/{self.cfg.SCRIPT.LANGUAGE}/{filename}")
            print(table)
            return False
        return True

    def is_profile_valid(self, profile_name: str) -> bool:
        """Check if a profile configuration is valid and complete.

        :param profile_name: Name of the profile to validate.
        :type profile_name: str
        :return: Whether the profile is valid.
        :rtype: bool
        """
        if profile_name not in self.cfg.PROFILE:
            logger.critical("Invalid profile name: '%s'", profile_name)
            return False

        mode = self.cfg.PROFILE[profile_name].MODE
        if mode.upper() not in self.cfg.PROFILE:
            logger.critical("Invalid mode: '%s'", mode)
            return False

        expected_keys = set(self.cfg.PROFILE[mode.upper()])
        actual_keys = set(self.cfg.PROFILE[profile_name])

        invalid_keys = actual_keys - expected_keys
        missing_keys = expected_keys - actual_keys

        if invalid_keys or missing_keys:
            for key in invalid_keys:
                logger.warning("Invalid setting: '%s'", key)
            for key in missing_keys:
                logger.warning("Missing setting: '%s'", key)
        return True

    def display_available_profiles(self) -> None:
        """Display a table of available profiles for user selection.

        Shows a formatted table with profile IDs and names.
        """
        table = Table(
            "Profile",
            title="Select a profile to start :rocket:",
            show_header=False,
            min_width=36,
        )
        for i, profile in enumerate(self.cfg.PROFILE):
            table.add_row(f"{i:>2}. {profile}")
        print(table)

    def get_pid(self) -> None:
        """Prompt the user to enter a profile ID and validate the input.

        Continuously prompts until a valid profile ID is entered or the
        user chooses to quit.
        """
        print("Enter profile id to use, h to see help message, q to quit:")

        while True:
            user_input = input(">>> ")
            if self.is_pid_valid(user_input):
                break
            if user_input == "q":
                print("Bye.")
                sys.exit()
            if user_input == "h":
                self.parser.print_help()
                continue
            utils.print_error("Invalid profile id, please try again.")

        self.cfg.ARGS.PID = int(user_input)

    def create_user_profile(self) -> None:
        """Configure the user profile based on arguments or interactive selection.

        Selects a profile based on command-line arguments or user input,
        validates the profile, and merges it with the configuration.
        """
        if self.cfg.ARGS.PNAME is not None:
            profile_name = self.cfg.ARGS.PNAME
        else:
            if self.cfg.ARGS.PID is None:
                self.display_available_profiles()
                self.get_pid()
            profile_name = list(self.cfg.PROFILE)[self.cfg.ARGS.PID]

        if not self.is_profile_valid(profile_name):
            sys.exit(1)

        # Merge args.opts here because we can only overwrite cfg.SELECTED
        # after it's constructed using profile id or name.
        # Process list-like values if possible
        if "KEY.BOTTOM_RODS" in self.args.opts:
            value_idx = self.args.opts.index("KEY.BOTTOM_RODS") + 1
            self.args.opts[value_idx] = [
                x.strip() for x in self.args.opts[value_idx].split(",")
            ]
        self.cfg.merge_from_list(self.args.opts)

        mode = self.cfg.PROFILE[profile_name].MODE.upper()
        self.cfg.SELECTED = CN({"NAME": profile_name}, new_allowed=True)
        self.cfg.SELECTED.merge_from_other_cfg(self.cfg.PROFILE[mode])
        self.cfg.SELECTED.merge_from_other_cfg(self.cfg.PROFILE[profile_name])

        if self.cfg.SELECTED.LAUNCH_OPTIONS:  # Overwrite
            args_list = shlex.split(self.cfg.SELECTED.LAUNCH_OPTIONS) + sys.argv[1:]
            self.args = self.parser.parse_args(args_list)
            self.cfg.ARGS = config.dict_to_cfg(vars(self.args))

        # Check here because config might got overwritten
        if (
            not self.is_smtp_valid()
            or not self.is_images_valid()
            or not self.is_discord_webhook_url_valid()
        ):
            sys.exit(1)
        config.print_cfg(self.cfg.ARGS)
        config.print_cfg(self.cfg.SELECTED)

    def is_window_valid(self) -> None:
        """Set up and validate the game window.

        Creates a Window object, checks if the window size is supported,
        and disables incompatible features if needed.
        """
        if self.window.is_title_bar_exist():
            logger.info("Window mode detected. Please don't move the game window")
        if not self.window.is_size_supported():
            logger.warning('Window mode must be "Borderless windowed" or "Window mode"')
            logger.warning(
                "Unsupported window size '%s', "
                "use '2560x1440', '1920x1080' or '1600x900'",
                self.window.get_resolution_str(),
            )
            logger.error(
                "Snag detection will be disabled\n"
                "Spooling detection will be disabled\n"
                "Auto friction brake will be disabled\n"
            )

            self.cfg.ARGS.FRICTION_BRAKE = False
            self.cfg.SCRIPT.SNAG_DETECTION = False
            self.cfg.SCRIPT.SPOOLING_DETECTION = False

        if (
            self.cfg.SELECTED.MODE in ("telescopic", "bolognese")
            and not self.window.is_size_supported()
        ):
            logger.critical(
                "Fishing mode '%s' doesn't support window size '%s'",
                self.cfg.SELECTED.MODE,
                self.window.get_resolution_str(),
            )
            return False
        return True

    def is_electro_valid(self):
        """Display helpful information about the current configuration.

        Checks configuration compatibility and prints warnings for
        potential issues.
        """
        if not self.cfg.ARGS.ELECTRO:
            return True

        if self.cfg.SELECTED.MODE in ("pirk", "elevator"):
            logger.info(
                "Electric mode is enabled, make sure you're using Electro Raptor"
            )
        else:
            logger.error(
                "Electric mode is not compatible with mode '%s'"
                "Electric mode will be disabled",
                self.cfg.SELECTED.MODE,
            )
            self.cfg.ARGS.ELECTRO = False
        return True

    def _start(self) -> None:
        """Entry point."""
        self.player = Player(self.cfg, self.window)
        self.player.start_fishing()

    def start(self) -> None:
        """Start the fishing automation process.

        Sets up all required components, activates the game window,
        registers key listeners, and begins the fishing automation.
        Handles termination and displays result.
        """
        self.create_user_profile()
        if not self.is_window_valid() or not self.is_electro_valid():
            sys.exit(1)
        self.cfg.freeze()

        if self.cfg.KEY.QUIT != "CTRL-C":
            listener = keyboard.Listener(on_release=self._on_release)
            listener.start()
        print(f"Press {self.cfg.KEY.QUIT} to quit.")
        self.window.activate_game_window()
        try:
            self._start()
        except KeyboardInterrupt:
            pass

        self.display_result()
        if self.cfg.ARGS.DATA:
            self.player.plot_and_save()

    def display_result(self):
        print(
            self.player.build_result_table(
                self.player.build_result_dict("Terminated by user")
            )
        )


if __name__ == "__main__":
    print(Panel.fit(LOGO, box=box.HEAVY), GITHUB_LINK, DISCORD_LINK, sep="\n")
    RF4SApp().start()

        📄 move.py  [Текстовый файл]:
"""Movement automation for Russian Fishing 4 using keyboard controls.

This module automates character movement in Russian Fishing 4 by simulating W key presses.
Supports toggling movement state and includes optional Shift key integration for sprinting.

.. moduleauthor:: Derek Lee <dereklee0310@gmail.com>
"""

import argparse
import sys
from pathlib import Path

import pyautogui as pag
from pynput import keyboard
from rich import print

sys.path.append(".")
from rf4s import utils
from rf4s.app.app import ToolApp
from rf4s.config.config import print_cfg

ROOT = Path(__file__).resolve().parents[1]


class MoveApp(ToolApp):
    """Main controller for movement automation in Russian Fishing 4.

    Manages configuration, keyboard event listeners, and W/Shift key simulation.

    Attributes:
        cfg (CfgNode): Configuration node merged from YAML and CLI arguments.
        w_key_pressed (bool): Tracks current state of W key simulation.
    """

    def __init__(self):
        """Initialize configuration, CLI arguments, and game window.

        1. Format keybinds in cfg node.
        2. Create w key flag.
        """
        super().__init__()

        # Format key
        self.cfg.defrost()
        self.cfg.ARGS.PAUSE_KEY = f"'{self.cfg.ARGS.PAUSE_KEY}'"
        self.cfg.ARGS.QUIT_KEY = f"'{self.cfg.ARGS.QUIT_KEY}'"
        self.cfg.freeze()
        print_cfg(self.cfg.ARGS)

        self.w_key_pressed = True

    def create_parser(self) -> argparse.ArgumentParser:
        """Create an argument parser for the application.

        :return: Configured argument parser.
        :rtype: argparse.ArgumentParser
        """
        parser = argparse.ArgumentParser(
            description="Moving the game character forward with W key."
        )
        parser.add_argument("opts", nargs="*", help="overwrite configuration")
        parser.add_argument(
            "-s", "--shift", action="store_true", help="Hold Shift key while moving"
        )
        parser.add_argument(
            "-p",
            "--pause-key",
            default="w",
            type=str,
            help="key to pause the script, w by default",
            metavar="KEY",
        )
        parser.add_argument(
            "-q",
            "--quit-key",
            default="s",
            type=str,
            help="key to quit the script, s by default",
            metavar="KEY",
        )
        return parser

    def _on_release(self, key: keyboard.KeyCode) -> None:
        """Handle keyboard release events for script control.

        :param key: Key released by the user.
        :type key: keyboard.KeyCode
        """
        if str(key).lower() == self.cfg.ARGS.QUIT_KEY:
            sys.exit()
        elif str(key).lower() == self.cfg.ARGS.PAUSE_KEY:
            if self.w_key_pressed:
                self.w_key_pressed = False
                return
            pag.keyDown("w")
            self.w_key_pressed = True

    @utils.release_keys_after(arrow_keys=True)
    def _start(self) -> None:
        """Start W key automation and keyboard listener."""
        print(
            f"Press {self.cfg.ARGS.PAUSE_KEY[1:-1]} to pause, "
            f"{self.cfg.ARGS.QUIT_KEY[1:-1]} to quit."
        )
        if self.cfg.ARGS.SHIFT:
            pag.keyDown("shift")
        pag.keyDown("w")
        # Blocking listener loop
        with keyboard.Listener(on_release=self._on_release) as listener:
            listener.join()


if __name__ == "__main__":
    MoveApp().start()
